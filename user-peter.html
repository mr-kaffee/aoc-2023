<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.16">
<title>Solutions by peter</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700">
<link rel="stylesheet" href="./asciidoctor.css">
<link rel="stylesheet" href="./rouge-github.css">
</head>
<body id="top" class="article toc2 toc-right">
<div style="width:100%;margin:0 auto;max-width:62.5em;*zoom:1;position:relative;padding-left:.9375em;padding-right:.9375em">
    <div class="paragraph">
        <a href="/index.html">AoC 2023 Solutions</a>
        &bull; <a href="https://github.com/mr-kaffee/aoc-2023/">GitHub Repository</a>
        &bull; <a href="https://adventofcode.com/2023/">Advent of Code</a>
    </div>
</div>
<div id="header">
<h1>Solutions by peter</h1>
<div id="toc" class="toc2">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#sol-cpp-0">C++ | Day 0: Hello World</a>
<ul class="sectlevel2">
<li><a href="#_the_code">The code</a></li>
<li><a href="#_run_it_with_cmake">Run it with CMake</a></li>
</ul>
</li>
<li><a href="#sol-kotlin-0">Kotlin | Day 0: Hello World</a>
<ul class="sectlevel2">
<li><a href="#_the_code_2">The code</a></li>
<li><a href="#_run_it">Run it</a></li>
</ul>
</li>
<li><a href="#sol-rust-0">Rust | Day 0: Hello Ferris</a>
<ul class="sectlevel2">
<li><a href="#_general_solution_structure">General solution structure</a></li>
<li><a href="#_hello_world_implementation">Hello World implementation</a></li>
<li><a href="#_hello_world_tests">Hello World tests</a></li>
</ul>
</li>
<li><a href="#sol-haskell-1">Haskell | Day 1: Trebuchet?!</a>
<ul class="sectlevel2">
<li><a href="#_star_1">Star 1</a></li>
<li><a href="#_star_2">Star 2</a></li>
</ul>
</li>
<li><a href="#sol-rust-1">Rust | Day 1: Trebuchet?!</a>
<ul class="sectlevel2">
<li><a href="#_input">Input</a></li>
<li><a href="#_star_1_2">Star 1</a></li>
<li><a href="#_star_2_2">Star 2</a></li>
<li><a href="#_tests">Tests</a></li>
</ul>
</li>
<li><a href="#sol-haskell-2">Haskell | Day 2: Cube Conundrum</a>
<ul class="sectlevel2">
<li><a href="#_star_1_3">Star 1</a></li>
<li><a href="#_star_2_3">Star 2</a></li>
</ul>
</li>
<li><a href="#sol-rust-2">Rust | Day 2: Cube Conundrum</a>
<ul class="sectlevel2">
<li><a href="#_input_2">Input</a></li>
<li><a href="#_star_1_4">Star 1</a></li>
<li><a href="#_star_2_4">Star 2</a></li>
<li><a href="#_tests_2">Tests</a></li>
</ul>
</li>
<li><a href="#sol-rust-3">Rust | Day 3: Gear Ratios</a>
<ul class="sectlevel2">
<li><a href="#_input_3">Input</a></li>
<li><a href="#_star_1_5">Star 1</a></li>
<li><a href="#_star_2_5">Star 2</a></li>
<li><a href="#_tests_3">Tests</a></li>
</ul>
</li>
<li><a href="#sol-rust-4">Rust | Day 4: Scratchcards</a>
<ul class="sectlevel2">
<li><a href="#_input_4">Input</a></li>
<li><a href="#_star_1_6">Star 1</a></li>
<li><a href="#_star_2_6">Star 2</a></li>
<li><a href="#_tests_4">Tests</a></li>
</ul>
</li>
<li><a href="#sol-rust-5">Rust | Day 5: If You Give A Seed A Fertilizer</a>
<ul class="sectlevel2">
<li><a href="#_input_5">Input</a></li>
<li><a href="#_star_1_7">Star 1</a></li>
<li><a href="#_star_2_7">Star 2</a></li>
<li><a href="#_tests_5">Tests</a></li>
</ul>
</li>
<li><a href="#sol-rust-6">Rust | Day 6: Wait For It</a>
<ul class="sectlevel2">
<li><a href="#_star_1_8">Star 1</a></li>
<li><a href="#_star_2_8">Star 2</a></li>
<li><a href="#_benchmarks">Benchmarks</a></li>
<li><a href="#_tests_6">Tests</a></li>
</ul>
</li>
<li><a href="#sol-rust-7">Rust | Day 7: Camel Cards</a>
<ul class="sectlevel2">
<li><a href="#_input_6">Input</a></li>
<li><a href="#_star_1_9">Star 1</a></li>
<li><a href="#_star_2_9">Star 2</a></li>
<li><a href="#_tests_7">Tests</a></li>
</ul>
</li>
<li><a href="#sol-rust-8">Rust | Day 8: Haunted Wasteland</a>
<ul class="sectlevel2">
<li><a href="#_input_7">Input</a></li>
<li><a href="#_star_1_10">Star 1</a></li>
<li><a href="#_star_2_10">Star 2</a></li>
<li><a href="#_tests_8">Tests</a></li>
</ul>
</li>
<li><a href="#sol-rust-9">Rust | Day 9: Mirage Maintenance</a>
<ul class="sectlevel2">
<li><a href="#_input_8">Input</a></li>
<li><a href="#_star_1_11">Star 1</a></li>
<li><a href="#_star_2_11">Star 2</a></li>
<li><a href="#_tests_9">Tests</a></li>
</ul>
</li>
<li><a href="#sol-rust-10">Rust | Day 10: Pipe Maze</a>
<ul class="sectlevel2">
<li><a href="#_input_9">Input</a></li>
<li><a href="#_star_1_12">Star 1</a></li>
<li><a href="#_star_2_12">Star 2</a></li>
<li><a href="#_tests_10">Tests</a></li>
</ul>
</li>
<li><a href="#sol-rust-11">Rust | Day 11: Cosmic Expansion</a>
<ul class="sectlevel2">
<li><a href="#_input_10">Input</a></li>
<li><a href="#_star_1_13">Star 1</a></li>
<li><a href="#_star_2_13">Star 2</a></li>
<li><a href="#_tests_11">Tests</a></li>
</ul>
</li>
<li><a href="#sol-rust-12">Rust | Day 12: Hot Springs</a>
<ul class="sectlevel2">
<li><a href="#_star_1_14">Star 1</a></li>
<li><a href="#_star_2_14">Star 2</a></li>
<li><a href="#_tests_12">Tests</a></li>
</ul>
</li>
<li><a href="#sol-rust-13">Rust | Day 13: Point of Incidence</a>
<ul class="sectlevel2">
<li><a href="#_input_11">Input</a></li>
<li><a href="#_star_1_15">Star 1</a></li>
<li><a href="#_star_2_15">Star 2</a></li>
<li><a href="#_tests_13">Tests</a></li>
</ul>
</li>
<li><a href="#sol-rust-14">Rust | Day 14: Parabolic Reflector Dish</a>
<ul class="sectlevel2">
<li><a href="#_input_12">Input</a></li>
<li><a href="#_star_1_16">Star 1</a></li>
<li><a href="#_star_2_16">Star 2</a></li>
<li><a href="#_tests_14">Tests</a></li>
</ul>
</li>
<li><a href="#sol-rust-15">Rust | Day 15: Lens Library</a>
<ul class="sectlevel2">
<li><a href="#_star_1_17">Star 1</a></li>
<li><a href="#_star_2_17">Star 2</a></li>
<li><a href="#_tests_15">Tests</a></li>
</ul>
</li>
<li><a href="#sol-rust-16">Rust | Day 16: The Floor Will Be Lava</a>
<ul class="sectlevel2">
<li><a href="#_input_13">Input</a></li>
<li><a href="#_star_1_18">Star 1</a></li>
<li><a href="#_star_2_18">Star 2</a></li>
<li><a href="#_tests_16">Tests</a></li>
</ul>
</li>
<li><a href="#sol-rust-17">Rust | Day 17: Clumsy Crucible</a>
<ul class="sectlevel2">
<li><a href="#_input_14">Input</a></li>
<li><a href="#_stars_1_2">Stars 1 &amp; 2</a></li>
<li><a href="#_tests_17">Tests</a></li>
</ul>
</li>
<li><a href="#sol-rust-18">Rust | Day 18: Lavaduct Lagoon</a>
<ul class="sectlevel2">
<li><a href="#_star_1_19">Star 1</a></li>
<li><a href="#_star_2_19">Star 2</a></li>
<li><a href="#_tests_18">Tests</a></li>
</ul>
</li>
<li><a href="#sol-rust-19">Rust | Day 19: Aplenty</a>
<ul class="sectlevel2">
<li><a href="#_input_15">Input</a></li>
<li><a href="#_star_1_20">Star 1</a></li>
<li><a href="#_star_2_20">Star 2</a></li>
<li><a href="#_tests_19">Tests</a></li>
</ul>
</li>
<li><a href="#sol-rust-20">Rust | Day 20: Pulse Propagation</a>
<ul class="sectlevel2">
<li><a href="#_input_16">Input</a></li>
<li><a href="#_star_1_21">Star 1</a></li>
<li><a href="#_star_2_21">Star 2</a></li>
<li><a href="#_tests_20">Tests</a></li>
</ul>
</li>
<li><a href="#sol-rust-21">Rust | Day 21: Step Counter</a></li>
<li><a href="#sol-rust-22">Rust | Day 22: Sand Slabs</a>
<ul class="sectlevel2">
<li><a href="#_input_17">Input</a></li>
<li><a href="#_star_1_2_2">Star 1 &amp; 2</a></li>
<li><a href="#_tests_21">Tests</a></li>
</ul>
</li>
<li><a href="#sol-rust-23">Rust | Day 23: A Long Walk</a>
<ul class="sectlevel2">
<li><a href="#_input_18">Input</a></li>
<li><a href="#_star_1_22">Star 1</a></li>
<li><a href="#_tests_22">Tests</a></li>
</ul>
</li>
<li><a href="#sol-rust-24">Rust | Day 24: Never Tell Me The Odds</a>
<ul class="sectlevel2">
<li><a href="#_input_19">Input</a></li>
<li><a href="#_star_1_23">Star 1</a></li>
<li><a href="#_star_2_22">Star 2</a></li>
<li><a href="#_tests_23">Tests</a></li>
</ul>
</li>
<li><a href="#sol-rust-25">Rust | Day 25: Snowverload</a>
<ul class="sectlevel2">
<li><a href="#_input_20">Input</a></li>
<li><a href="#_star_1_24">Star 1</a></li>
<li><a href="#_tests_24">Tests</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="content">
<div class="sect1">
<h2 id="sol-cpp-0">C++ | Day 0: Hello World</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_the_code">The code</h3>
<div class="paragraph">
<p>This is a simple C++ template.</p>
</div>
<div class="paragraph">
<p>It reads the input in a list of lines using a <code>FileHandler</code> class implementing <em>RAII</em>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
</pre></td><td class="code"><pre><span class="k">class</span> <span class="nc">FileHandler</span> <span class="p">{</span>
<span class="nl">public:</span>
  <span class="n">FileHandler</span><span class="p">(</span><span class="n">string</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">filename</span><span class="p">)</span> <span class="o">:</span> <span class="n">_file</span><span class="p">{</span><span class="n">filename</span><span class="p">}</span> <span class="p">{}</span>
  <span class="o">~</span><span class="n">FileHandler</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">_file</span><span class="p">.</span><span class="n">is_open</span><span class="p">())</span> <span class="p">{</span>
      <span class="n">_file</span><span class="p">.</span><span class="n">close</span><span class="p">();</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">readLines</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">lines</span><span class="p">{};</span>
    <span class="n">string</span> <span class="n">line</span><span class="p">{};</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">getline</span><span class="p">(</span><span class="n">_file</span><span class="p">,</span> <span class="n">line</span><span class="p">))</span> <span class="p">{</span>
      <span class="n">lines</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">line</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">lines</span><span class="p">;</span>
  <span class="p">}</span>

<span class="nl">private:</span>
  <span class="n">ifstream</span> <span class="n">_file</span><span class="p">;</span>
<span class="p">};</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>And it does something incredibly meaningful with the input:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
</pre></td><td class="code"><pre><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">auto</span> <span class="n">start</span> <span class="o">=</span> <span class="n">Clock</span><span class="o">::</span><span class="n">now</span><span class="p">();</span>

  <span class="k">auto</span> <span class="n">lines</span> <span class="o">=</span> <span class="n">FileHandler</span><span class="p">{</span><span class="s">"input00"</span><span class="p">}.</span><span class="n">readLines</span><span class="p">();</span>
  <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">line</span> <span class="o">:</span> <span class="n">lines</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">line</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="n">Duration</span> <span class="n">d</span> <span class="o">=</span> <span class="n">Clock</span><span class="o">::</span><span class="n">now</span><span class="p">()</span> <span class="o">-</span> <span class="n">start</span><span class="p">;</span>
  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Solved puzzle in "</span> <span class="o">&lt;&lt;</span> <span class="n">d</span><span class="p">.</span><span class="n">count</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">DURATION_UNIT</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_run_it_with_cmake">Run it with CMake</h3>
<div class="paragraph">
<p>I use CMake and its integration in VS Code to build (<code>F7</code>) and run (<code>Shift+F5</code>) the solution with this simple <code>CMakeLists.txt</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cmake"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
</pre></td><td class="code"><pre><span class="nb">cmake_minimum_required</span><span class="p">(</span>VERSION 3.12<span class="p">)</span>

<span class="nb">set</span><span class="p">(</span>AOC_DAY <span class="s2">"00"</span><span class="p">)</span>

<span class="nb">project</span><span class="p">(</span>peter_day<span class="si">${</span><span class="nv">AOC_DAY</span><span class="si">}</span> VERSION 0.1.0<span class="p">)</span>

<span class="nb">set</span><span class="p">(</span>CMAKE_CXX_STANDARD 20<span class="p">)</span>
<span class="nb">set</span><span class="p">(</span>CMAKE_CXX_STANDARD_REQUIRED True<span class="p">)</span>

<span class="c1"># copy input to build folder</span>
<span class="nb">file</span><span class="p">(</span>COPY <span class="s2">"../../../inputs/input</span><span class="si">${</span><span class="nv">AOC_DAY</span><span class="si">}</span><span class="s2">"</span> DESTINATION <span class="s2">"</span><span class="si">${</span><span class="nv">CMAKE_BINARY_DIR</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>

<span class="nb">add_executable</span><span class="p">(</span>solution solution.cpp<span class="p">)</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p><a href="#top">Top</a></p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="sol-kotlin-0">Kotlin | Day 0: Hello World</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_the_code_2">The code</h3>
<div class="paragraph">
<p>This is a simple Kotlin template.</p>
</div>
<div class="paragraph">
<p>It reads the input in a list of lines:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="kotlin"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno">1
2
3
</pre></td><td class="code"><pre><span class="k">fun</span> <span class="nf">readLines</span><span class="p">():</span> <span class="nc">List</span><span class="p">&lt;</span><span class="nc">String</span><span class="p">&gt;</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nc">File</span><span class="p">(</span><span class="s">"../../../inputs/input00"</span><span class="p">).</span><span class="nf">useLines</span><span class="p">()</span> <span class="p">{</span> <span class="n">it</span><span class="p">.</span><span class="nf">toList</span><span class="p">()</span> <span class="p">}</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>And it does something incredibly meaningful with the input:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="kotlin"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
</pre></td><td class="code"><pre><span class="k">fun</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">val</span> <span class="py">start</span> <span class="p">=</span> <span class="nc">System</span><span class="p">.</span><span class="nf">currentTimeMillis</span><span class="p">()</span>

    <span class="kd">val</span> <span class="py">lines</span> <span class="p">=</span> <span class="nf">readLines</span><span class="p">()</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">line</span> <span class="k">in</span> <span class="n">lines</span><span class="p">)</span> <span class="p">{</span>
        <span class="nf">println</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="kd">val</span> <span class="py">elapsed</span> <span class="p">=</span> <span class="nc">System</span><span class="p">.</span><span class="nf">currentTimeMillis</span><span class="p">()</span> <span class="p">-</span> <span class="n">start</span>
    <span class="nf">println</span><span class="p">(</span><span class="s">"Solved puzzle in ${elapsed}ms."</span><span class="p">)</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_run_it">Run it</h3>
<div class="paragraph">
<p>The solutions can be run out of VS Code using the <a href="https://marketplace.visualstudio.com/items?itemName=formulahendry.code-runner">Code Runner</a> extension via the <code>Ctrl+Alt+N</code> shortcut or in the terminal using <code>kotlinc solution.kt -include-runtime -d solution.jar &amp;&amp; java -jar solution.jar</code>.</p>
</div>
<div class="paragraph">
<p><a href="#top">Top</a></p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="sol-rust-0">Rust | Day 0: Hello Ferris</h2>
<div class="sectionbody">
<div class="paragraph">
<p><a href="https://rust-lang.org">Rust</a> <strong>Hello World</strong>, <a href="https://adventofcode.com/2023/">AoC|2023</a> starts.</p>
</div>
<div class="paragraph">
<p>It will be another year of Rust solutions for me. It is just so much fun, that I am not tempted to try another language.</p>
</div>
<div class="paragraph">
<p>I will again try to not use any external dependencies and create fast solutions.</p>
</div>
<div class="sect2">
<h3 id="_general_solution_structure">General solution structure</h3>
<div class="paragraph">
<p>The general structure of my solutions will be as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code>+- src
|  +- lib.rs    // the actual implementation
|  +- main.rs   // the code to run the solution
+- Cargo.toml   // cargo manifest
+- README.adoc  // documentation of the solution</code></pre>
</div>
</div>
<div class="paragraph">
<p>The solution is run using <code>cargo run</code> or <code>cargo run --release</code>. Sometimes there will be features for solution variants, that will be run with <code>cargo run --features [some feature] --release</code>.</p>
</div>
<div class="paragraph">
<p>Typically, there will also be tests which can be executed using <code>cargo test</code> or <code>cargo test --release</code></p>
</div>
</div>
<div class="sect2">
<h3 id="_hello_world_implementation">Hello World implementation</h3>
<div class="paragraph">
<p>The implementation will typically consist of the parts detailed below.</p>
</div>
<div class="paragraph">
<p>Some meta and type information:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno">1
2
3
4
</pre></td><td class="code"><pre><span class="k">pub</span> <span class="k">const</span> <span class="n">IDENTIFIER</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span> <span class="o">=</span> <span class="s">"2023/00"</span><span class="p">;</span>

<span class="k">pub</span> <span class="k">type</span> <span class="n">InputType</span> <span class="o">=</span> <span class="nb">str</span><span class="p">;</span>
<span class="k">pub</span> <span class="k">type</span> <span class="n">Sol1Type</span> <span class="o">=</span> <span class="nb">usize</span><span class="p">;</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>Some code to parse the input (in this example, this also includes a simple <code>doctest</code>):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
</pre></td><td class="code"><pre><span class="k">pub</span> <span class="k">const</span> <span class="n">FERRIS</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span> <span class="o">=</span> <span class="s">r"    _~^~^~_
\) /  o o  \ (/
  '_   ¬   _'
  \ '-----' /"</span><span class="p">;</span>

<span class="cd">/// Parse the puzzle input.</span>
<span class="cd">///</span>
<span class="cd">/// # Examples</span>
<span class="cd">/// ```</span>
<span class="cd">/// # use mr_kaffee_2023_00::*;</span>
<span class="cd">/// let input = parse_input();</span>
<span class="cd">/// assert_eq!(FERRIS, input, "Expect input to be ferris");</span>
<span class="cd">/// ```</span>
<span class="k">pub</span> <span class="k">fn</span> <span class="nf">parse_input</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="k">'static</span> <span class="nb">str</span> <span class="p">{</span>
    <span class="n">FERRIS</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>The implementation of the solution functions <code>star_1</code> (and for most days <code>star_2</code>):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno">1
2
3
4
</pre></td><td class="code"><pre><span class="k">pub</span> <span class="k">fn</span> <span class="n">star_1</span><span class="o">&lt;</span><span class="n">T</span><span class="p">:</span> <span class="nb">AsRef</span><span class="o">&lt;</span><span class="n">InputType</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">input</span><span class="p">:</span> <span class="n">T</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Sol1Type</span> <span class="p">{</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="n">input</span><span class="nf">.as_ref</span><span class="p">());</span>
    <span class="mi">0</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_hello_world_tests">Hello World tests</h3>
<div class="paragraph">
<p>And there are typically some tests (mostly based on the example data given in the puzzle inputs):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
</pre></td><td class="code"><pre><span class="nd">#[cfg(test)]</span>
<span class="k">mod</span> <span class="n">tests</span> <span class="p">{</span>
    <span class="k">use</span> <span class="k">super</span><span class="p">::</span><span class="o">*</span><span class="p">;</span>

    <span class="nd">#[test]</span>
    <span class="cd">/// This is a repetition of the doctest for the [`parse_input`] function.</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">test_parse_input</span><span class="p">()</span> <span class="p">{</span>
        <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">FERRIS</span><span class="p">,</span> <span class="nf">parse_input</span><span class="p">());</span>
    <span class="p">}</span>

    <span class="nd">#[test]</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">test_star_1</span><span class="p">()</span> <span class="p">{</span>
        <span class="c1">// the function star_1 can be called with a String ...</span>
        <span class="nd">assert_eq!</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nf">star_1</span><span class="p">(</span><span class="s">"owned"</span><span class="nf">.to_string</span><span class="p">()));</span>
        <span class="c1">// ... or with a &amp;str argument</span>
        <span class="nd">assert_eq!</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nf">star_1</span><span class="p">(</span><span class="s">"reference"</span><span class="p">));</span>
    <span class="p">}</span>

    <span class="nd">#[should_panic]</span>
    <span class="nd">#[test]</span>
    <span class="cd">/// This is an arbitrary test which is expected to panic.</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">test_panic</span><span class="p">()</span> <span class="p">{</span>
        <span class="nd">panic!</span><span class="p">(</span><span class="s">"This will panic!"</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p><a href="#top">Top</a></p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="sol-haskell-1">Haskell | Day 1: Trebuchet?!</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The solution is run with <code>runhaskell solution.hs</code> (or alternatively compiled with <code>ghc solution.hs</code> which creates an binary <code>solution</code>).</p>
</div>
<div class="sect2">
<h3 id="_star_1">Star 1</h3>
<div class="paragraph">
<p>The solution consists in summing the scores for every line.</p>
</div>
<div class="paragraph">
<p>The scores for a line are calculated in the <code>score1</code> function</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="haskell"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
</pre></td><td class="code"><pre><span class="c1">-- solution for both stars, use score1 or score2 as first argument</span>
<span class="n">star</span> <span class="o">::</span> <span class="p">(</span><span class="kt">String</span> <span class="o">-&gt;</span> <span class="kt">Int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">String</span> <span class="o">-&gt;</span> <span class="kt">Int</span>
<span class="n">star</span> <span class="n">f</span> <span class="o">=</span> <span class="n">sum</span> <span class="o">.</span> <span class="n">map</span> <span class="n">f</span> <span class="o">.</span> <span class="n">lines</span>

<span class="c1">-- scoring function for star1</span>
<span class="n">score1</span> <span class="o">::</span> <span class="kt">String</span> <span class="o">-&gt;</span> <span class="kt">Int</span>
<span class="n">score1</span> <span class="n">xs</span> <span class="o">=</span> <span class="mi">10</span> <span class="o">*</span> <span class="n">score1'</span> <span class="n">xs</span> <span class="o">+</span> <span class="n">score1'</span> <span class="p">(</span><span class="n">reverse</span> <span class="n">xs</span><span class="p">)</span>
  <span class="kr">where</span>
    <span class="n">score1'</span> <span class="o">::</span> <span class="kt">String</span> <span class="o">-&gt;</span> <span class="kt">Int</span>
    <span class="n">score1'</span> <span class="p">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">xs</span><span class="p">)</span>
      <span class="o">|</span> <span class="n">isDigit</span> <span class="n">x</span> <span class="o">=</span> <span class="n">ord</span> <span class="n">x</span> <span class="o">-</span> <span class="n">ord</span> <span class="sc">'0'</span>
      <span class="o">|</span> <span class="n">otherwise</span> <span class="o">=</span> <span class="n">score1'</span> <span class="n">xs</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_star_2">Star 2</h3>
<div class="paragraph">
<p>The solution for the second star uses a <code>score2</code> function which looks for digits spelled out in addition to simple digits.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="haskell"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
</pre></td><td class="code"><pre><span class="c1">-- scoring function for star2</span>
<span class="n">score2</span> <span class="o">::</span> <span class="kt">String</span> <span class="o">-&gt;</span> <span class="kt">Int</span>
<span class="n">score2</span> <span class="n">xs</span> <span class="o">=</span> <span class="mi">10</span> <span class="o">*</span> <span class="n">score2'</span> <span class="n">id</span> <span class="n">xs</span> <span class="o">+</span> <span class="n">score2'</span> <span class="n">reverse</span> <span class="p">(</span><span class="n">reverse</span> <span class="n">xs</span><span class="p">)</span>
  <span class="kr">where</span>
    <span class="n">score2'</span> <span class="o">::</span> <span class="p">(</span><span class="kt">String</span> <span class="o">-&gt;</span> <span class="kt">String</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">String</span> <span class="o">-&gt;</span> <span class="kt">Int</span>
    <span class="n">score2'</span> <span class="n">f</span> <span class="p">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">xs</span><span class="p">)</span>
      <span class="o">|</span> <span class="n">isDigit</span> <span class="n">x</span> <span class="o">=</span> <span class="n">ord</span> <span class="n">x</span> <span class="o">-</span> <span class="n">ord</span> <span class="sc">'0'</span>
      <span class="o">|</span> <span class="n">otherwise</span> <span class="o">=</span> <span class="kr">case</span> <span class="n">findIndex</span> <span class="p">((`</span><span class="n">isPrefixOf</span><span class="p">`</span> <span class="p">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">xs</span><span class="p">))</span> <span class="o">.</span> <span class="n">f</span><span class="p">)</span> <span class="n">digits</span> <span class="kr">of</span>
          <span class="kt">Just</span> <span class="n">digit</span> <span class="o">-&gt;</span> <span class="n">digit</span>
          <span class="kt">Nothing</span> <span class="o">-&gt;</span> <span class="n">score2'</span> <span class="n">f</span> <span class="n">xs</span>
      <span class="kr">where</span>
        <span class="n">digits</span> <span class="o">=</span> <span class="p">[</span><span class="s">"zero"</span><span class="p">,</span> <span class="s">"one"</span><span class="p">,</span> <span class="s">"two"</span><span class="p">,</span> <span class="s">"three"</span><span class="p">,</span> <span class="s">"four"</span><span class="p">,</span> <span class="s">"five"</span><span class="p">,</span> <span class="s">"six"</span><span class="p">,</span> <span class="s">"seven"</span><span class="p">,</span> <span class="s">"eight"</span><span class="p">,</span> <span class="s">"nine"</span><span class="p">]</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p><a href="#top">Top</a></p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="sol-rust-1">Rust | Day 1: Trebuchet?!</h2>
<div class="sectionbody">
<div class="paragraph">
<p><a href="https://rust-lang.org">Rust</a> solution to <a href="https://adventofcode.com/2023/day/1">AoC|2023|1</a>.</p>
</div>
<div class="sect2">
<h3 id="_input">Input</h3>
<div class="paragraph">
<p>No separate input processing today. Just operate on the raw character data.</p>
</div>
</div>
<div class="sect2">
<h3 id="_star_1_2">Star 1</h3>
<div class="paragraph">
<p>The solution consists of two parts:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>A <code>map_1</code> function, that returns for any <code>&amp;str</code> the value of the digit at its head wrapped in an <code>Option</code> or <code>None</code> if there is no digit.</p>
</li>
<li>
<p>A <code>score</code> function which calculates the score for a line by finding the first and last digit. The <code>map_1</code> function is passed as an argument.</p>
</li>
<li>
<p>A <code>star</code> function which calculates the solution by summing over the scores for each line. This function takes as well <code>map_1</code> as an argument.</p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
</pre></td><td class="code"><pre><span class="k">pub</span> <span class="k">fn</span> <span class="nf">map_1</span><span class="p">(</span><span class="n">line</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">SolT</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">b</span> <span class="o">=</span> <span class="n">line</span><span class="nf">.as_bytes</span><span class="p">()[</span><span class="mi">0</span><span class="p">];</span>
    <span class="k">match</span> <span class="n">b</span> <span class="p">{</span>
        <span class="sc">b'0'</span><span class="o">..=</span><span class="sc">b'9'</span> <span class="k">=&gt;</span> <span class="nf">Some</span><span class="p">((</span><span class="n">b</span> <span class="o">-</span> <span class="sc">b'0'</span><span class="p">)</span> <span class="k">as</span> <span class="n">_</span><span class="p">),</span>
        <span class="n">_</span> <span class="k">=&gt;</span> <span class="nb">None</span><span class="p">,</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="n">score</span><span class="o">&lt;</span><span class="n">F</span><span class="p">:</span> <span class="nf">Fn</span><span class="p">(</span><span class="o">&amp;</span><span class="nb">str</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">SolT</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">l</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">,</span> <span class="n">f</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">F</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">SolT</span> <span class="p">{</span>
    <span class="p">(</span><span class="mi">0</span><span class="o">..</span><span class="n">l</span><span class="nf">.len</span><span class="p">())</span><span class="nf">.map</span><span class="p">(|</span><span class="n">k</span><span class="p">|</span> <span class="o">&amp;</span><span class="n">l</span><span class="p">[</span><span class="n">k</span><span class="o">..</span><span class="p">])</span><span class="nf">.find_map</span><span class="p">(</span><span class="n">f</span><span class="p">)</span><span class="nf">.unwrap</span><span class="p">()</span> <span class="o">*</span> <span class="mi">10</span>
        <span class="o">+</span> <span class="p">(</span><span class="mi">0</span><span class="o">..</span><span class="n">l</span><span class="nf">.len</span><span class="p">())</span><span class="nf">.rev</span><span class="p">()</span><span class="nf">.map</span><span class="p">(|</span><span class="n">k</span><span class="p">|</span> <span class="o">&amp;</span><span class="n">l</span><span class="p">[</span><span class="n">k</span><span class="o">..</span><span class="p">])</span><span class="nf">.find_map</span><span class="p">(</span><span class="n">f</span><span class="p">)</span><span class="nf">.unwrap</span><span class="p">()</span>
<span class="p">}</span>

<span class="k">pub</span> <span class="k">fn</span> <span class="n">star</span><span class="o">&lt;</span><span class="n">F</span><span class="p">:</span> <span class="nf">Fn</span><span class="p">(</span><span class="o">&amp;</span><span class="nb">str</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">SolT</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">,</span> <span class="n">map</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">F</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">SolT</span> <span class="p">{</span>
    <span class="n">data</span><span class="nf">.lines</span><span class="p">()</span><span class="nf">.map</span><span class="p">(|</span><span class="n">line</span><span class="p">|</span> <span class="nf">score</span><span class="p">(</span><span class="n">line</span><span class="p">,</span> <span class="n">map</span><span class="p">))</span><span class="nf">.sum</span><span class="p">()</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>Catches for the 1st star:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>There may be lines with only one digit. In that case, it is the first and the last digit.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_star_2_2">Star 2</h3>
<div class="paragraph">
<p>All that is needed for the second star is to extend <code>map_1</code> function to <code>map_2</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno">1
2
3
4
5
6
7
</pre></td><td class="code"><pre><span class="k">const</span> <span class="n">DIGITS</span><span class="p">:</span> <span class="o">&amp;</span><span class="p">[</span><span class="o">&amp;</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">[</span>
    <span class="s">"zero"</span><span class="p">,</span> <span class="s">"one"</span><span class="p">,</span> <span class="s">"two"</span><span class="p">,</span> <span class="s">"three"</span><span class="p">,</span> <span class="s">"four"</span><span class="p">,</span> <span class="s">"five"</span><span class="p">,</span> <span class="s">"six"</span><span class="p">,</span> <span class="s">"seven"</span><span class="p">,</span> <span class="s">"eight"</span><span class="p">,</span> <span class="s">"nine"</span><span class="p">,</span>
<span class="p">];</span>

<span class="k">pub</span> <span class="k">fn</span> <span class="nf">map_2</span><span class="p">(</span><span class="n">line</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">SolT</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="nf">map_1</span><span class="p">(</span><span class="n">line</span><span class="p">)</span><span class="nf">.or_else</span><span class="p">(||</span> <span class="p">(</span><span class="mi">0</span><span class="o">..</span><span class="n">DIGITS</span><span class="nf">.len</span><span class="p">())</span><span class="nf">.find</span><span class="p">(|</span><span class="o">&amp;</span><span class="n">digit</span><span class="p">|</span> <span class="n">line</span><span class="nf">.starts_with</span><span class="p">(</span><span class="n">DIGITS</span><span class="p">[</span><span class="n">digit</span><span class="p">])))</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>Catches for the 2nd star:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Textual representation of digits may overlap like in <strong>oneight</strong> (this is not an issue when searching from the end of the string, my initial solution just searched for all digits in a line and skipped characters belonging to one digit for the next step)</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_tests">Tests</h3>
<div class="paragraph">
<p>Just check the scores for the sample data.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
</pre></td><td class="code"><pre><span class="nd">#[cfg(test)]</span>
<span class="k">mod</span> <span class="n">tests</span> <span class="p">{</span>
    <span class="k">use</span> <span class="k">super</span><span class="p">::</span><span class="o">*</span><span class="p">;</span>

    <span class="k">const</span> <span class="n">CONTENT_1</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span> <span class="o">=</span> <span class="s">r#"1abc2
pqr3stu8vwx
a1b2c3d4e5f
treb7uchet
"#</span><span class="p">;</span>

    <span class="nd">#[test]</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">test_star_1</span><span class="p">()</span> <span class="p">{</span>
        <span class="nd">assert_eq!</span><span class="p">(</span><span class="mi">142</span><span class="p">,</span> <span class="nf">star</span><span class="p">(</span><span class="n">CONTENT_1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">map_1</span><span class="p">));</span>
    <span class="p">}</span>

    <span class="k">const</span> <span class="n">CONTENT_2</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span> <span class="o">=</span> <span class="s">r#"two1nine
eightwothree
abcone2threexyz
xtwone3four
4nineeightseven2
zoneight234
7pqrstsixteen
"#</span><span class="p">;</span>

    <span class="nd">#[test]</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">test_star_2</span><span class="p">()</span> <span class="p">{</span>
        <span class="nd">assert_eq!</span><span class="p">(</span><span class="mi">281</span><span class="p">,</span> <span class="nf">star</span><span class="p">(</span><span class="n">CONTENT_2</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">map_2</span><span class="p">));</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p><a href="#top">Top</a></p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="sol-haskell-2">Haskell | Day 2: Cube Conundrum</h2>
<div class="sectionbody">
<div class="paragraph">
<p>I struggled a bit parsing the input.</p>
</div>
<div class="paragraph">
<p>What eventually helped was to realize, that every pair of a count and a color can be considered independently. There is no need to group them to draws with cubes of different colors. In other words: the colors can be considered independently.</p>
</div>
<div class="sect2">
<h3 id="_star_1_3">Star 1</h3>
<div class="paragraph">
<p>I have two helper functions to separate the ID from the draws and to choose one argument out of three given a color string:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="haskell"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
</pre></td><td class="code"><pre><span class="c1">-- extract Game id: ...draws... into (id, ...draws...)</span>
<span class="n">splitId</span> <span class="o">::</span> <span class="kt">String</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="kt">Int</span><span class="p">,</span> <span class="kt">String</span><span class="p">)</span>
<span class="n">splitId</span> <span class="n">line</span><span class="o">@</span><span class="p">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">xs</span><span class="p">)</span>
  <span class="o">|</span> <span class="n">isDigit</span> <span class="n">x</span> <span class="o">=</span> <span class="n">splitId'</span> <span class="mi">0</span> <span class="n">line</span>
  <span class="o">|</span> <span class="n">otherwise</span> <span class="o">=</span> <span class="n">splitId</span> <span class="n">xs</span>
  <span class="kr">where</span>
    <span class="n">splitId'</span> <span class="o">::</span> <span class="kt">Int</span> <span class="o">-&gt;</span> <span class="kt">String</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="kt">Int</span><span class="p">,</span> <span class="kt">String</span><span class="p">)</span>
    <span class="n">splitId'</span> <span class="n">id</span> <span class="p">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">xs</span><span class="p">)</span>
      <span class="o">|</span> <span class="n">isDigit</span> <span class="n">x</span> <span class="o">=</span> <span class="n">splitId'</span> <span class="p">(</span><span class="mi">10</span> <span class="o">*</span> <span class="n">id</span> <span class="o">+</span> <span class="p">(</span><span class="n">ord</span> <span class="n">x</span> <span class="o">-</span> <span class="n">ord</span> <span class="sc">'0'</span><span class="p">))</span> <span class="n">xs</span>
    <span class="n">splitId'</span> <span class="n">id</span> <span class="p">(</span><span class="sc">':'</span> <span class="o">:</span> <span class="sc">' '</span> <span class="o">:</span> <span class="n">xs</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="n">id</span><span class="p">,</span> <span class="n">xs</span><span class="p">)</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>With this, the solution to star1 looks as follows (see explanation in the comments):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="haskell"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
</pre></td><td class="code"><pre><span class="c1">-- sum over ids of all lines which respect the limits</span>
<span class="n">star1</span> <span class="o">::</span> <span class="kt">String</span> <span class="o">-&gt;</span> <span class="kt">Int</span>
<span class="n">star1</span> <span class="o">=</span> <span class="n">sum</span> <span class="o">.</span> <span class="n">map</span> <span class="n">fst</span> <span class="o">.</span> <span class="n">filter</span> <span class="p">(</span><span class="n">allSmaller</span> <span class="mi">12</span> <span class="mi">13</span> <span class="mi">14</span> <span class="o">.</span> <span class="n">words</span> <span class="o">.</span> <span class="n">snd</span><span class="p">)</span> <span class="o">.</span> <span class="n">map</span> <span class="n">splitId</span> <span class="o">.</span> <span class="n">lines</span>
  <span class="kr">where</span>
    <span class="c1">-- essentially a foldl which consumes two elements (count and color) at once</span>
    <span class="n">allSmaller</span> <span class="o">::</span> <span class="kt">Int</span> <span class="o">-&gt;</span> <span class="kt">Int</span> <span class="o">-&gt;</span> <span class="kt">Int</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="kt">String</span><span class="p">]</span> <span class="o">-&gt;</span> <span class="kt">Bool</span>
    <span class="n">allSmaller</span> <span class="kr">_</span> <span class="kr">_</span> <span class="kr">_</span> <span class="kt">[]</span> <span class="o">=</span> <span class="kt">True</span>
    <span class="n">allSmaller</span> <span class="n">r</span> <span class="n">g</span> <span class="n">b</span> <span class="p">(</span><span class="n">n</span> <span class="o">:</span> <span class="p">(</span><span class="n">c</span> <span class="o">:</span> <span class="kr">_</span><span class="p">)</span> <span class="o">:</span> <span class="n">xs</span><span class="p">)</span>
      <span class="o">|</span> <span class="n">read</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="n">v</span> <span class="o">=</span> <span class="kt">False</span>
      <span class="o">|</span> <span class="n">otherwise</span> <span class="o">=</span> <span class="n">allSmaller</span> <span class="n">r</span> <span class="n">g</span> <span class="n">b</span> <span class="n">xs</span>
      <span class="kr">where</span>
        <span class="n">v</span> <span class="o">=</span> <span class="kr">case</span> <span class="n">c</span> <span class="kr">of</span>
          <span class="sc">'r'</span> <span class="o">-&gt;</span> <span class="n">r</span>
          <span class="sc">'g'</span> <span class="o">-&gt;</span> <span class="n">g</span>
          <span class="sc">'b'</span> <span class="o">-&gt;</span> <span class="n">b</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_star_2_3">Star 2</h3>
<div class="paragraph">
<p>Star 2 is quite similar besides there is just mapping, no filtering:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="haskell"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
</pre></td><td class="code"><pre><span class="c1">-- sum of product of maximum for every color for every line</span>
<span class="n">star2</span> <span class="o">::</span> <span class="kt">String</span> <span class="o">-&gt;</span> <span class="kt">Int</span>
<span class="n">star2</span> <span class="o">=</span> <span class="n">sum</span> <span class="o">.</span> <span class="n">map</span> <span class="p">(</span><span class="n">prod'</span> <span class="o">.</span> <span class="n">maxByColor</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">.</span> <span class="n">words</span> <span class="o">.</span> <span class="n">snd</span> <span class="o">.</span> <span class="n">splitId</span><span class="p">)</span> <span class="o">.</span> <span class="n">lines</span>
  <span class="kr">where</span>
    <span class="n">prod'</span> <span class="o">::</span> <span class="p">(</span><span class="kt">Int</span><span class="p">,</span> <span class="kt">Int</span><span class="p">,</span> <span class="kt">Int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Int</span>
    <span class="n">prod'</span> <span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="o">=</span> <span class="n">r</span> <span class="o">*</span> <span class="n">g</span> <span class="o">*</span> <span class="n">b</span>
    <span class="c1">-- essentially a foldl which consumes two elements (count and color) at once</span>
    <span class="n">maxByColor</span> <span class="o">::</span> <span class="p">(</span><span class="kt">Int</span><span class="p">,</span> <span class="kt">Int</span><span class="p">,</span> <span class="kt">Int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="kt">String</span><span class="p">]</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="kt">Int</span><span class="p">,</span> <span class="kt">Int</span><span class="p">,</span> <span class="kt">Int</span><span class="p">)</span>
    <span class="n">maxByColor</span> <span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="kt">[]</span> <span class="o">=</span> <span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
    <span class="n">maxByColor</span> <span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="p">(</span><span class="n">n'</span> <span class="o">:</span> <span class="p">(</span><span class="n">c</span> <span class="o">:</span> <span class="kr">_</span><span class="p">)</span> <span class="o">:</span> <span class="n">xs</span><span class="p">)</span>
      <span class="o">|</span> <span class="n">c</span> <span class="o">==</span> <span class="sc">'r'</span> <span class="o">=</span> <span class="n">maxByColor</span> <span class="p">(</span><span class="n">max</span> <span class="n">r</span> <span class="n">n</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="n">xs</span>
      <span class="o">|</span> <span class="n">c</span> <span class="o">==</span> <span class="sc">'g'</span> <span class="o">=</span> <span class="n">maxByColor</span> <span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">max</span> <span class="n">g</span> <span class="n">n</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="n">xs</span>
      <span class="o">|</span> <span class="n">c</span> <span class="o">==</span> <span class="sc">'b'</span> <span class="o">=</span> <span class="n">maxByColor</span> <span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">max</span> <span class="n">b</span> <span class="n">n</span><span class="p">)</span> <span class="n">xs</span>
      <span class="kr">where</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">read</span> <span class="n">n'</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p><a href="#top">Top</a></p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="sol-rust-2">Rust | Day 2: Cube Conundrum</h2>
<div class="sectionbody">
<div class="paragraph">
<p><a href="https://rust-lang.org">Rust</a> solution to <a href="https://adventofcode.com/2023/day/2">AoC|2023|2</a>.</p>
</div>
<div class="sect2">
<h3 id="_input_2">Input</h3>
<div class="paragraph">
<p>As it is the case quite often, parsing the input was the biggest part of today&#8217;s puzzle. Maybe I should stop separate parsing the input and solving the challenge and just do it in one pass?</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
</pre></td><td class="code"><pre><span class="k">pub</span> <span class="k">mod</span> <span class="n">input</span> <span class="p">{</span>
    <span class="k">use</span> <span class="k">crate</span><span class="p">::</span><span class="n">SolT</span><span class="p">;</span>

    <span class="nd">#[derive(Debug)]</span>
    <span class="k">pub</span> <span class="k">struct</span> <span class="nf">PuzzleData</span><span class="p">(</span><span class="k">pub</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="p">[</span><span class="n">SolT</span><span class="p">;</span> <span class="mi">3</span><span class="p">]</span><span class="o">&gt;&gt;</span><span class="p">);</span>

    <span class="k">fn</span> <span class="nf">parse_draw</span><span class="p">(</span><span class="n">line</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="p">[</span><span class="n">SolT</span><span class="p">;</span> <span class="mi">3</span><span class="p">]</span> <span class="p">{</span>
        <span class="n">line</span><span class="nf">.split</span><span class="p">(</span><span class="s">", "</span><span class="p">)</span><span class="nf">.fold</span><span class="p">([</span><span class="mi">0</span><span class="p">;</span> <span class="mi">3</span><span class="p">],</span> <span class="p">|[</span><span class="n">r</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">b</span><span class="p">],</span> <span class="n">color</span><span class="p">|</span> <span class="p">{</span>
            <span class="k">match</span> <span class="n">color</span>
                <span class="nf">.split_once</span><span class="p">(</span><span class="sc">' '</span><span class="p">)</span>
                <span class="nf">.map</span><span class="p">(|(</span><span class="n">n</span><span class="p">,</span> <span class="n">c</span><span class="p">)|</span> <span class="p">(</span><span class="n">n</span><span class="py">.parse</span><span class="p">::</span><span class="o">&lt;</span><span class="n">SolT</span><span class="o">&gt;</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">(),</span> <span class="n">c</span><span class="p">))</span>
            <span class="p">{</span>
                <span class="nf">Some</span><span class="p">((</span><span class="n">n</span><span class="p">,</span> <span class="s">"red"</span><span class="p">))</span> <span class="k">=&gt;</span> <span class="p">[</span><span class="n">r</span> <span class="o">+</span> <span class="n">n</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">b</span><span class="p">],</span>
                <span class="nf">Some</span><span class="p">((</span><span class="n">n</span><span class="p">,</span> <span class="s">"green"</span><span class="p">))</span> <span class="k">=&gt;</span> <span class="p">[</span><span class="n">r</span><span class="p">,</span> <span class="n">g</span> <span class="o">+</span> <span class="n">n</span><span class="p">,</span> <span class="n">b</span><span class="p">],</span>
                <span class="nf">Some</span><span class="p">((</span><span class="n">n</span><span class="p">,</span> <span class="s">"blue"</span><span class="p">))</span> <span class="k">=&gt;</span> <span class="p">[</span><span class="n">r</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">b</span> <span class="o">+</span> <span class="n">n</span><span class="p">],</span>
                <span class="n">_</span> <span class="k">=&gt;</span> <span class="nd">panic!</span><span class="p">(</span><span class="s">"Unexpected draw."</span><span class="p">),</span>
            <span class="p">}</span>
        <span class="p">})</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="nf">parse_game</span><span class="p">(</span><span class="n">line</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="p">[</span><span class="n">SolT</span><span class="p">;</span> <span class="mi">3</span><span class="p">]</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="n">line</span><span class="nf">.split_once</span><span class="p">(</span><span class="s">": "</span><span class="p">)</span>
            <span class="nf">.unwrap</span><span class="p">()</span>
            <span class="na">.1</span>
            <span class="nf">.split</span><span class="p">(</span><span class="s">"; "</span><span class="p">)</span>
            <span class="nf">.map</span><span class="p">(</span><span class="n">parse_draw</span><span class="p">)</span>
            <span class="nf">.collect</span><span class="p">()</span>
    <span class="p">}</span>

    <span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="p">:</span> <span class="nb">AsRef</span><span class="o">&lt;</span><span class="nb">str</span><span class="o">&gt;&gt;</span> <span class="nb">From</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="k">for</span> <span class="n">PuzzleData</span> <span class="p">{</span>
        <span class="k">fn</span> <span class="nf">from</span><span class="p">(</span><span class="n">s</span><span class="p">:</span> <span class="n">T</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
            <span class="nf">PuzzleData</span><span class="p">(</span><span class="n">s</span><span class="nf">.as_ref</span><span class="p">()</span><span class="nf">.lines</span><span class="p">()</span><span class="nf">.map</span><span class="p">(</span><span class="n">parse_game</span><span class="p">)</span><span class="nf">.collect</span><span class="p">())</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_star_1_4">Star 1</h3>
<div class="paragraph">
<p>iter (enumerated) &#8230;&#8203; filter &#8230;&#8203; map &#8230;&#8203; sum</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
</pre></td><td class="code"><pre><span class="k">pub</span> <span class="k">fn</span> <span class="nf">star_1</span><span class="p">(</span><span class="nf">PuzzleData</span><span class="p">(</span><span class="n">games</span><span class="p">):</span> <span class="o">&amp;</span><span class="n">PuzzleData</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">SolT</span> <span class="p">{</span>
    <span class="n">games</span>
        <span class="nf">.iter</span><span class="p">()</span>
        <span class="nf">.enumerate</span><span class="p">()</span>
        <span class="nf">.filter</span><span class="p">(|(</span><span class="n">_</span><span class="p">,</span> <span class="n">game</span><span class="p">)|</span> <span class="p">{</span>
            <span class="n">game</span><span class="nf">.iter</span><span class="p">()</span>
                <span class="nf">.all</span><span class="p">(|[</span><span class="n">r</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">b</span><span class="p">]|</span> <span class="o">*</span><span class="n">r</span> <span class="o">&lt;=</span> <span class="mi">12</span> <span class="o">&amp;&amp;</span> <span class="o">*</span><span class="n">g</span> <span class="o">&lt;=</span> <span class="mi">13</span> <span class="o">&amp;&amp;</span> <span class="o">*</span><span class="n">b</span> <span class="o">&lt;=</span> <span class="mi">14</span><span class="p">)</span>
        <span class="p">})</span>
        <span class="nf">.map</span><span class="p">(|(</span><span class="n">pos</span><span class="p">,</span> <span class="n">_</span><span class="p">)|</span> <span class="n">pos</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="nf">.sum</span><span class="p">()</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_star_2_4">Star 2</h3>
<div class="paragraph">
<p>iter &#8230;&#8203; map (nested iter &#8230;&#8203; fold) &#8230;&#8203; map &#8230;&#8203; sum</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
</pre></td><td class="code"><pre><span class="k">pub</span> <span class="k">fn</span> <span class="nf">star_2</span><span class="p">(</span><span class="nf">PuzzleData</span><span class="p">(</span><span class="n">games</span><span class="p">):</span> <span class="o">&amp;</span><span class="n">PuzzleData</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">SolT</span> <span class="p">{</span>
    <span class="n">games</span>
        <span class="nf">.iter</span><span class="p">()</span>
        <span class="nf">.map</span><span class="p">(|</span><span class="n">game</span><span class="p">|</span> <span class="p">{</span>
            <span class="n">game</span><span class="nf">.iter</span><span class="p">()</span>
                <span class="nf">.fold</span><span class="p">([</span><span class="mi">0</span><span class="p">;</span> <span class="mi">3</span><span class="p">],</span> <span class="p">|[</span><span class="n">r_max</span><span class="p">,</span> <span class="n">g_max</span><span class="p">,</span> <span class="n">b_max</span><span class="p">],</span> <span class="p">[</span><span class="n">r</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">b</span><span class="p">]|</span> <span class="p">{</span>
                    <span class="p">[</span><span class="n">r_max</span><span class="nf">.max</span><span class="p">(</span><span class="o">*</span><span class="n">r</span><span class="p">),</span> <span class="n">g_max</span><span class="nf">.max</span><span class="p">(</span><span class="o">*</span><span class="n">g</span><span class="p">),</span> <span class="n">b_max</span><span class="nf">.max</span><span class="p">(</span><span class="o">*</span><span class="n">b</span><span class="p">)]</span>
                <span class="p">})</span>
        <span class="p">})</span>
        <span class="nf">.map</span><span class="p">(|[</span><span class="n">r</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">b</span><span class="p">]|</span> <span class="n">r</span> <span class="o">*</span> <span class="n">g</span> <span class="o">*</span> <span class="n">b</span><span class="p">)</span>
        <span class="nf">.sum</span><span class="p">()</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_tests_2">Tests</h3>
<div class="paragraph">
<p>I proudly announce: all tests passed the first time I executed (normally, I never miss any occasion to do stupid mistakes)</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
</pre></td><td class="code"><pre><span class="nd">#[cfg(test)]</span>
<span class="k">mod</span> <span class="n">tests</span> <span class="p">{</span>
    <span class="k">use</span> <span class="k">super</span><span class="p">::</span><span class="o">*</span><span class="p">;</span>

    <span class="k">const</span> <span class="n">CONTENT</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span> <span class="o">=</span> <span class="s">r#"Game 1: 3 blue, 4 red; 1 red, 2 green, 6 blue; 2 green
Game 2: 1 blue, 2 green; 3 green, 4 blue, 1 red; 1 green, 1 blue
Game 3: 8 green, 6 blue, 20 red; 5 blue, 4 red, 13 green; 5 green, 1 red
Game 4: 1 green, 3 red, 6 blue; 3 green, 6 red; 3 green, 15 blue, 14 red
Game 5: 6 red, 1 blue, 3 green; 2 blue, 1 red, 2 green
"#</span><span class="p">;</span>

    <span class="nd">#[test]</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">test_from</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">expected</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="p">[</span><span class="n">SolT</span><span class="p">;</span> <span class="mi">3</span><span class="p">]</span><span class="o">&gt;&gt;</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[</span>
            <span class="nd">vec!</span><span class="p">[[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">]],</span>
            <span class="nd">vec!</span><span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]],</span>
            <span class="nd">vec!</span><span class="p">[[</span><span class="mi">20</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">13</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">0</span><span class="p">]],</span>
            <span class="nd">vec!</span><span class="p">[[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span> <span class="p">[</span><span class="mi">6</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">14</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">15</span><span class="p">]],</span>
            <span class="nd">vec!</span><span class="p">[[</span><span class="mi">6</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]],</span>
        <span class="p">];</span>
        <span class="k">let</span> <span class="nf">PuzzleData</span><span class="p">(</span><span class="n">games</span><span class="p">)</span> <span class="o">=</span> <span class="nn">PuzzleData</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="n">CONTENT</span><span class="p">);</span>
        <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">expected</span><span class="p">,</span> <span class="n">games</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="nd">#[test]</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">test_star_1</span><span class="p">()</span> <span class="p">{</span>
        <span class="nd">assert_eq!</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="nf">star_1</span><span class="p">(</span><span class="o">&amp;</span><span class="n">CONTENT</span><span class="nf">.into</span><span class="p">()));</span>
    <span class="p">}</span>

    <span class="nd">#[test]</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">test_star_2</span><span class="p">()</span> <span class="p">{</span>
        <span class="nd">assert_eq!</span><span class="p">(</span><span class="mi">2286</span><span class="p">,</span> <span class="nf">star_2</span><span class="p">(</span><span class="o">&amp;</span><span class="n">CONTENT</span><span class="nf">.into</span><span class="p">()));</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p><a href="#top">Top</a></p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="sol-rust-3">Rust | Day 3: Gear Ratios</h2>
<div class="sectionbody">
<div class="paragraph">
<p><a href="https://rust-lang.org">Rust</a> solution to <a href="https://adventofcode.com/2023/day/3">AoC|2023|3</a>.</p>
</div>
<div class="sect2">
<h3 id="_input_3">Input</h3>
<div class="paragraph">
<p>I just read the input into a grid. To simplify handling at the boundary, a layer of empty space (<code>'.'</code>) is added around the original data.</p>
</div>
</div>
<div class="sect2">
<h3 id="_star_1_5">Star 1</h3>
<div class="paragraph">
<p>I created a helper function <code>numbers</code> that returns an iterator over all numbers in the input data with the help of the <code>next_number</code> function. Actually, the iterator returns a tuple with the number&#8217;s value, its position in the grid, and its length (number of digits).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
</pre></td><td class="code"><pre><span class="k">pub</span> <span class="k">fn</span> <span class="nf">numbers</span><span class="p">(</span><span class="n">grid</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Grid</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">impl</span> <span class="nb">Iterator</span><span class="o">&lt;</span><span class="n">Item</span> <span class="o">=</span> <span class="p">(</span><span class="n">SolT</span><span class="p">,</span> <span class="nb">usize</span><span class="p">,</span> <span class="nb">usize</span><span class="p">)</span><span class="o">&gt;</span> <span class="o">+</span> <span class="nv">'_</span> <span class="p">{</span>
    <span class="nf">successors</span><span class="p">(</span><span class="nf">next_number</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">|(</span><span class="n">_</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">len</span><span class="p">)|</span> <span class="p">{</span>
        <span class="nf">next_number</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">pos</span> <span class="o">+</span> <span class="n">len</span><span class="p">)</span>
    <span class="p">})</span>
<span class="p">}</span>

<span class="k">pub</span> <span class="k">fn</span> <span class="nf">next_number</span><span class="p">(</span><span class="n">grid</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Grid</span><span class="p">,</span> <span class="n">offset</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="p">(</span><span class="n">SolT</span><span class="p">,</span> <span class="nb">usize</span><span class="p">,</span> <span class="nb">usize</span><span class="p">)</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="n">grid</span><span class="nf">.data</span><span class="p">()[</span><span class="n">offset</span><span class="o">..</span><span class="p">]</span>
        <span class="nf">.iter</span><span class="p">()</span>
        <span class="nf">.position</span><span class="p">(|</span><span class="n">b</span><span class="p">|</span> <span class="p">(</span><span class="sc">b'0'</span><span class="o">..=</span><span class="sc">b'9'</span><span class="p">)</span><span class="nf">.contains</span><span class="p">(</span><span class="n">b</span><span class="p">))</span>
        <span class="nf">.map</span><span class="p">(|</span><span class="n">pos</span><span class="p">|</span> <span class="p">{</span>
            <span class="n">grid</span><span class="nf">.data</span><span class="p">()[</span><span class="n">offset</span> <span class="o">+</span> <span class="n">pos</span><span class="o">..</span><span class="p">]</span>
                <span class="nf">.iter</span><span class="p">()</span>
                <span class="nf">.take_while</span><span class="p">(|</span><span class="n">b</span><span class="p">|</span> <span class="p">(</span><span class="sc">b'0'</span><span class="o">..=</span><span class="sc">b'9'</span><span class="p">)</span><span class="nf">.contains</span><span class="p">(</span><span class="n">b</span><span class="p">))</span>
                <span class="nf">.fold</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="n">offset</span> <span class="o">+</span> <span class="n">pos</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">|(</span><span class="n">val</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">len</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">|</span> <span class="p">{</span>
                    <span class="p">(</span><span class="mi">10</span> <span class="o">*</span> <span class="n">val</span> <span class="o">+</span> <span class="p">(</span><span class="n">b</span> <span class="o">-</span> <span class="sc">b'0'</span><span class="p">)</span> <span class="k">as</span> <span class="n">SolT</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">len</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
                <span class="p">})</span>
        <span class="p">})</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>For every number, we need to check all adjacent positions in the input data, so I created another helper function <code>run_around</code>, which iterates over all adjacent positions (by chaining iterators looking above, to the right, below, and to the left):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
</pre></td><td class="code"><pre><span class="k">pub</span> <span class="k">fn</span> <span class="nf">run_around</span><span class="p">((</span><span class="n">col</span><span class="p">,</span> <span class="n">row</span><span class="p">):</span> <span class="p">(</span><span class="nb">usize</span><span class="p">,</span> <span class="nb">usize</span><span class="p">),</span> <span class="n">len</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">impl</span> <span class="nb">Iterator</span><span class="o">&lt;</span><span class="n">Item</span> <span class="o">=</span> <span class="p">(</span><span class="nb">usize</span><span class="p">,</span> <span class="nb">usize</span><span class="p">)</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="p">(</span><span class="n">col</span> <span class="o">-</span> <span class="mi">1</span><span class="o">..</span><span class="n">col</span> <span class="o">+</span> <span class="n">len</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="nf">.map</span><span class="p">(</span><span class="k">move</span> <span class="p">|</span><span class="n">col</span><span class="p">|</span> <span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="n">row</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
        <span class="nf">.chain</span><span class="p">(</span><span class="nf">once</span><span class="p">((</span><span class="n">col</span> <span class="o">+</span> <span class="n">len</span><span class="p">,</span> <span class="n">row</span><span class="p">)))</span>
        <span class="nf">.chain</span><span class="p">(</span>
            <span class="p">(</span><span class="n">col</span> <span class="o">-</span> <span class="mi">1</span><span class="o">..</span><span class="n">col</span> <span class="o">+</span> <span class="n">len</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
                <span class="nf">.rev</span><span class="p">()</span>
                <span class="nf">.map</span><span class="p">(</span><span class="k">move</span> <span class="p">|</span><span class="n">col</span><span class="p">|</span> <span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="n">row</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)),</span>
        <span class="p">)</span>
        <span class="nf">.chain</span><span class="p">(</span><span class="nf">once</span><span class="p">((</span><span class="n">col</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">row</span><span class="p">)))</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>With those helpers in place, the solution for the first star is obtained by filtering out all numbers that are not adjacent to a symbol and summing their values:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
</pre></td><td class="code"><pre><span class="k">pub</span> <span class="k">fn</span> <span class="nf">star_1</span><span class="p">(</span><span class="nf">PuzzleData</span><span class="p">(</span><span class="n">grid</span><span class="p">):</span> <span class="o">&amp;</span><span class="n">PuzzleData</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">SolT</span> <span class="p">{</span>
    <span class="nf">numbers</span><span class="p">(</span><span class="n">grid</span><span class="p">)</span>
        <span class="nf">.filter</span><span class="p">(|(</span><span class="n">_</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">len</span><span class="p">)|</span> <span class="p">{</span>
            <span class="nf">run_around</span><span class="p">(</span><span class="n">grid</span><span class="nf">.to_col_row</span><span class="p">(</span><span class="o">*</span><span class="n">pos</span><span class="p">),</span> <span class="o">*</span><span class="n">len</span><span class="p">)</span>
                <span class="nf">.map</span><span class="p">(|</span><span class="n">pos</span><span class="p">|</span> <span class="n">grid</span><span class="p">[</span><span class="n">pos</span><span class="p">])</span>
                <span class="nf">.any</span><span class="p">(|</span><span class="n">b</span><span class="p">:</span> <span class="nb">u8</span><span class="p">|</span> <span class="n">b</span> <span class="o">!=</span> <span class="sc">b'.'</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="sc">b'0'</span><span class="o">..=</span><span class="sc">b'9'</span><span class="p">)</span><span class="nf">.contains</span><span class="p">(</span><span class="o">&amp;</span><span class="n">b</span><span class="p">))</span>
        <span class="p">})</span>
        <span class="nf">.map</span><span class="p">(|(</span><span class="n">value</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">)|</span> <span class="n">value</span><span class="p">)</span>
        <span class="nf">.sum</span><span class="p">()</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_star_2_5">Star 2</h3>
<div class="paragraph">
<p>The second star makes use of the same helper functions as the first star. I first iterate through all the numbers to create a map of the positions of the gear ratio symbols '*' to lists of adjacent numbers. Then I iterate through this map, filter out all entries that do not have exactly two numbers in the list, map to the product of those two numbers, and take the sum.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
</pre></td><td class="code"><pre><span class="k">pub</span> <span class="k">fn</span> <span class="nf">star_2</span><span class="p">(</span><span class="nf">PuzzleData</span><span class="p">(</span><span class="n">grid</span><span class="p">):</span> <span class="o">&amp;</span><span class="n">PuzzleData</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">SolT</span> <span class="p">{</span>
    <span class="nf">numbers</span><span class="p">(</span><span class="n">grid</span><span class="p">)</span>
        <span class="nf">.fold</span><span class="p">(</span><span class="nn">HashMap</span><span class="p">::</span><span class="nf">new</span><span class="p">(),</span> <span class="p">|</span><span class="n">map</span><span class="p">,</span> <span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">len</span><span class="p">)|</span> <span class="p">{</span>
            <span class="nf">run_around</span><span class="p">(</span><span class="n">grid</span><span class="nf">.to_col_row</span><span class="p">(</span><span class="n">pos</span><span class="p">),</span> <span class="n">len</span><span class="p">)</span>
                <span class="nf">.filter</span><span class="p">(|</span><span class="o">&amp;</span><span class="n">pos</span><span class="p">|</span> <span class="n">grid</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span> <span class="o">==</span> <span class="sc">b'*'</span><span class="p">)</span>
                <span class="nf">.fold</span><span class="p">(</span><span class="n">map</span><span class="p">,</span> <span class="p">|</span><span class="k">mut</span> <span class="n">map</span><span class="p">,</span> <span class="n">pos</span><span class="p">|</span> <span class="p">{</span>
                    <span class="n">map</span><span class="nf">.entry</span><span class="p">(</span><span class="n">pos</span><span class="p">)</span><span class="nf">.or_insert</span><span class="p">(</span><span class="nn">Vec</span><span class="p">::</span><span class="nf">new</span><span class="p">())</span><span class="nf">.push</span><span class="p">(</span><span class="n">value</span><span class="p">);</span>
                    <span class="n">map</span>
                <span class="p">})</span>
        <span class="p">})</span>
        <span class="nf">.values</span><span class="p">()</span>
        <span class="nf">.filter</span><span class="p">(|</span><span class="n">values</span><span class="p">|</span> <span class="n">values</span><span class="nf">.len</span><span class="p">()</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span>
        <span class="nf">.map</span><span class="p">(|</span><span class="n">values</span><span class="p">|</span> <span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">values</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="nf">.sum</span><span class="p">()</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_tests_3">Tests</h3>
<div class="paragraph">
<p>As usual.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
</pre></td><td class="code"><pre><span class="nd">#[cfg(test)]</span>
<span class="k">mod</span> <span class="n">tests</span> <span class="p">{</span>
    <span class="k">use</span> <span class="k">super</span><span class="p">::</span><span class="o">*</span><span class="p">;</span>

    <span class="k">const</span> <span class="n">CONTENT</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span> <span class="o">=</span> <span class="s">r#"467..114..
...*......
..35..633.
......#...
617*......
.....+.58.
..592.....
......755.
...$.*....
.664.598..
"#</span><span class="p">;</span>

    <span class="k">const</span> <span class="n">WIDTH_0</span><span class="p">:</span> <span class="nb">usize</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
    <span class="k">const</span> <span class="n">HEIGHT_0</span><span class="p">:</span> <span class="nb">usize</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
    <span class="k">const</span> <span class="n">WIDTH_EXT</span><span class="p">:</span> <span class="nb">usize</span> <span class="o">=</span> <span class="n">WIDTH_0</span> <span class="o">+</span> <span class="mi">2</span><span class="p">;</span>
    <span class="k">const</span> <span class="n">HEIGHT_EXT</span><span class="p">:</span> <span class="nb">usize</span> <span class="o">=</span> <span class="n">HEIGHT_0</span> <span class="o">+</span> <span class="mi">2</span><span class="p">;</span>

    <span class="nd">#[test]</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">test_from</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">let</span> <span class="nf">PuzzleData</span><span class="p">(</span><span class="n">grid</span><span class="p">)</span> <span class="o">=</span> <span class="nn">PuzzleData</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="n">CONTENT</span><span class="p">);</span>
        <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">WIDTH_EXT</span><span class="p">,</span> <span class="n">grid</span><span class="nf">.width</span><span class="p">());</span>
        <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">HEIGHT_EXT</span><span class="p">,</span> <span class="n">grid</span><span class="nf">.height</span><span class="p">());</span>
    <span class="p">}</span>

    <span class="nd">#[test]</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">test_next_number</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">let</span> <span class="nf">PuzzleData</span><span class="p">(</span><span class="n">grid</span><span class="p">)</span> <span class="o">=</span> <span class="nn">PuzzleData</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="n">CONTENT</span><span class="p">);</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"{:?}"</span><span class="p">,</span> <span class="n">grid</span><span class="p">);</span>
        <span class="nd">assert_eq!</span><span class="p">(</span><span class="nf">Some</span><span class="p">((</span><span class="mi">467</span><span class="p">,</span> <span class="n">WIDTH_EXT</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)),</span> <span class="nf">next_number</span><span class="p">(</span><span class="o">&amp;</span><span class="n">grid</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>
        <span class="nd">assert_eq!</span><span class="p">(</span>
            <span class="nf">Some</span><span class="p">((</span><span class="mi">35</span><span class="p">,</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">WIDTH_EXT</span> <span class="o">+</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">)),</span>
            <span class="nf">next_number</span><span class="p">(</span><span class="o">&amp;</span><span class="n">grid</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">WIDTH_EXT</span><span class="p">)</span>
        <span class="p">);</span>
    <span class="p">}</span>

    <span class="nd">#[test]</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">test_star_1</span><span class="p">()</span> <span class="p">{</span>
        <span class="nd">assert_eq!</span><span class="p">(</span><span class="mi">4_361</span><span class="p">,</span> <span class="nf">star_1</span><span class="p">(</span><span class="o">&amp;</span><span class="n">CONTENT</span><span class="nf">.into</span><span class="p">()));</span>
    <span class="p">}</span>

    <span class="nd">#[test]</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">test_star_2</span><span class="p">()</span> <span class="p">{</span>
        <span class="nd">assert_eq!</span><span class="p">(</span><span class="mi">467_835</span><span class="p">,</span> <span class="nf">star_2</span><span class="p">(</span><span class="o">&amp;</span><span class="n">CONTENT</span><span class="nf">.into</span><span class="p">()));</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p><a href="#top">Top</a></p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="sol-rust-4">Rust | Day 4: Scratchcards</h2>
<div class="sectionbody">
<div class="paragraph">
<p><a href="https://rust-lang.org">Rust</a> solution to <a href="https://adventofcode.com/2023/day/4">AoC|2023|4</a>.</p>
</div>
<div class="sect2">
<h3 id="_input_4">Input</h3>
<div class="paragraph">
<p>Today, I directly operate on the input as <code>&amp;str</code>, no pre-processing.</p>
</div>
</div>
<div class="sect2">
<h3 id="_star_1_6">Star 1</h3>
<div class="paragraph">
<p>I build an iterator which yields for every line the number of items that appear in both lists on the scratch card using a hash set. Then I apply the scoring function to those numbers and take the sum:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre></td><td class="code"><pre><span class="k">pub</span> <span class="k">fn</span> <span class="nf">count_winners</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">impl</span> <span class="nb">Iterator</span><span class="o">&lt;</span><span class="n">Item</span> <span class="o">=</span> <span class="n">SolT</span><span class="o">&gt;</span> <span class="o">+</span> <span class="nv">'_</span> <span class="p">{</span>
    <span class="n">data</span><span class="nf">.lines</span><span class="p">()</span>
        <span class="nf">.map</span><span class="p">(|</span><span class="n">line</span><span class="p">|</span> <span class="p">{</span>
            <span class="n">line</span><span class="nf">.split_once</span><span class="p">(</span><span class="sc">':'</span><span class="p">)</span>
                <span class="nf">.and_then</span><span class="p">(|(</span><span class="n">_</span><span class="p">,</span> <span class="n">tail</span><span class="p">)|</span> <span class="n">tail</span><span class="nf">.split_once</span><span class="p">(</span><span class="sc">'|'</span><span class="p">))</span>
                <span class="nf">.unwrap</span><span class="p">()</span>
        <span class="p">})</span>
        <span class="nf">.map</span><span class="p">(|(</span><span class="n">lhs</span><span class="p">,</span> <span class="n">rhs</span><span class="p">)|</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">lhs</span> <span class="o">=</span> <span class="n">lhs</span><span class="nf">.split_ascii_whitespace</span><span class="p">()</span><span class="py">.collect</span><span class="p">::</span><span class="o">&lt;</span><span class="n">HashSet</span><span class="o">&lt;</span><span class="n">_</span><span class="o">&gt;&gt;</span><span class="p">();</span>
            <span class="n">rhs</span><span class="nf">.split_ascii_whitespace</span><span class="p">()</span>
                <span class="nf">.filter</span><span class="p">(|</span><span class="n">value</span><span class="p">|</span> <span class="n">lhs</span><span class="nf">.contains</span><span class="p">(</span><span class="n">value</span><span class="p">))</span>
                <span class="nf">.count</span><span class="p">()</span>
        <span class="p">})</span>
<span class="p">}</span>

<span class="k">pub</span> <span class="k">fn</span> <span class="nf">star_1</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">SolT</span> <span class="p">{</span>
    <span class="nf">count_winners</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="nf">.map</span><span class="p">(|</span><span class="n">c</span><span class="p">|</span> <span class="k">match</span> <span class="n">c</span> <span class="p">{</span>
            <span class="mi">0</span> <span class="k">=&gt;</span> <span class="mi">0</span><span class="p">,</span>
            <span class="n">n</span> <span class="k">=&gt;</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">),</span>
        <span class="p">})</span>
        <span class="nf">.sum</span><span class="p">()</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_star_2_6">Star 2</h3>
<div class="paragraph">
<p>I pass through all cards once to update the number of subsequent cards (in a nested fold). Since the outer fold does not know the total number of cards, I need to initialize enough counters with <code>1</code> (initially, every card is available once).</p>
</div>
<div class="paragraph">
<p>A key statement from the puzzle description for the algorithm to work is "Cards will never make you copy a card past the end of the table."</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
</pre></td><td class="code"><pre><span class="k">pub</span> <span class="k">fn</span> <span class="nf">star_2</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">SolT</span> <span class="p">{</span>
    <span class="nf">count_winners</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="nf">.enumerate</span><span class="p">()</span>
        <span class="nf">.fold</span><span class="p">(</span><span class="nd">vec!</span><span class="p">[],</span> <span class="p">|</span><span class="k">mut</span> <span class="n">counts</span><span class="p">,</span> <span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="n">wins</span><span class="p">)|</span> <span class="p">{</span>
            <span class="n">counts</span><span class="nf">.resize</span><span class="p">(</span><span class="n">counts</span><span class="nf">.len</span><span class="p">()</span><span class="nf">.max</span><span class="p">(</span><span class="n">pos</span> <span class="o">+</span> <span class="n">wins</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="mi">1</span><span class="p">);</span>
            <span class="p">(</span><span class="n">pos</span> <span class="o">+</span> <span class="mi">1</span><span class="o">..=</span><span class="n">pos</span> <span class="o">+</span> <span class="n">wins</span><span class="p">)</span><span class="nf">.fold</span><span class="p">(</span><span class="n">counts</span><span class="p">,</span> <span class="p">|</span><span class="k">mut</span> <span class="n">counts</span><span class="p">,</span> <span class="n">pos_upd</span><span class="p">|</span> <span class="p">{</span>
                <span class="n">counts</span><span class="p">[</span><span class="n">pos_upd</span><span class="p">]</span> <span class="o">+=</span> <span class="n">counts</span><span class="p">[</span><span class="n">pos</span><span class="p">];</span>
                <span class="n">counts</span>
            <span class="p">})</span>
        <span class="p">})</span>
        <span class="nf">.iter</span><span class="p">()</span>
        <span class="nf">.sum</span><span class="p">()</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_tests_4">Tests</h3>
<div class="paragraph">
<p>Nothing special here.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
</pre></td><td class="code"><pre><span class="nd">#[cfg(test)]</span>
<span class="k">mod</span> <span class="n">tests</span> <span class="p">{</span>
    <span class="k">use</span> <span class="k">super</span><span class="p">::</span><span class="o">*</span><span class="p">;</span>

    <span class="k">const</span> <span class="n">CONTENT</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span> <span class="o">=</span> <span class="s">r#"Card 1: 41 48 83 86 17 | 83 86  6 31 17  9 48 53
Card 2: 13 32 20 16 61 | 61 30 68 82 17 32 24 19
Card 3:  1 21 53 59 44 | 69 82 63 72 16 21 14  1
Card 4: 41 92 73 84 69 | 59 84 76 51 58  5 54 83
Card 5: 87 83 26 28 32 | 88 30 70 12 93 22 82 36
Card 6: 31 18 13 56 72 | 74 77 10 23 35 67 36 11
"#</span><span class="p">;</span>

    <span class="nd">#[test]</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">test_count_winners</span><span class="p">()</span> <span class="p">{</span>
        <span class="nd">assert_eq!</span><span class="p">(</span>
            <span class="nd">vec!</span><span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
            <span class="nf">count_winners</span><span class="p">(</span><span class="n">CONTENT</span><span class="p">)</span><span class="py">.collect</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="n">_</span><span class="o">&gt;&gt;</span><span class="p">()</span>
        <span class="p">);</span>
    <span class="p">}</span>

    <span class="nd">#[test]</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">test_star_1</span><span class="p">()</span> <span class="p">{</span>
        <span class="nd">assert_eq!</span><span class="p">(</span><span class="mi">13</span><span class="p">,</span> <span class="nf">star_1</span><span class="p">(</span><span class="n">CONTENT</span><span class="p">));</span>
    <span class="p">}</span>

    <span class="nd">#[test]</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">test_star_2</span><span class="p">()</span> <span class="p">{</span>
        <span class="nd">assert_eq!</span><span class="p">(</span><span class="mi">30</span><span class="p">,</span> <span class="nf">star_2</span><span class="p">(</span><span class="n">CONTENT</span><span class="p">));</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p><a href="#top">Top</a></p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="sol-rust-5">Rust | Day 5: If You Give A Seed A Fertilizer</h2>
<div class="sectionbody">
<div class="paragraph">
<p><a href="https://rust-lang.org">Rust</a> solution to <a href="https://adventofcode.com/2023/day/5">AoC|2023|5</a>.</p>
</div>
<div class="sect2">
<h3 id="_input_5">Input</h3>
<div class="paragraph">
<p>Again a day of quite complicated input parsing that might not be strictly necessary.</p>
</div>
<div class="paragraph">
<p>The parsed input is a struct with a field <code>seeds</code> representing the seeds to be planted and a field 'maps'. The latter is a hash map that maps a source item type (seed, soil, &#8230;&#8203;) to a target item type and the mapping that explains which type of target item type to use with each source item type.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
</pre></td><td class="code"><pre><span class="k">type</span> <span class="n">Map</span> <span class="o">=</span> <span class="p">(</span><span class="n">SolT</span><span class="p">,</span> <span class="n">SolT</span><span class="p">,</span> <span class="n">SolT</span><span class="p">);</span>

<span class="k">pub</span> <span class="k">mod</span> <span class="n">input</span> <span class="p">{</span>
    <span class="k">use</span> <span class="k">crate</span><span class="p">::</span><span class="o">*</span><span class="p">;</span>
    <span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">collections</span><span class="p">::</span><span class="n">HashMap</span><span class="p">;</span>

    <span class="nd">#[derive(Debug)]</span>
    <span class="k">pub</span> <span class="k">struct</span> <span class="n">PuzzleData</span> <span class="p">{</span>
        <span class="k">pub</span> <span class="n">seeds</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">SolT</span><span class="o">&gt;</span><span class="p">,</span>
        <span class="k">pub</span> <span class="n">maps</span><span class="p">:</span> <span class="n">HashMap</span><span class="o">&lt;</span><span class="nb">String</span><span class="p">,</span> <span class="p">(</span><span class="nb">String</span><span class="p">,</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">Map</span><span class="o">&gt;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="nf">parse_ranges</span><span class="p">(</span><span class="n">ranges</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Map</span> <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">numbers</span> <span class="o">=</span> <span class="n">ranges</span><span class="nf">.split_ascii_whitespace</span><span class="p">()</span><span class="nf">.map</span><span class="p">(|</span><span class="n">r</span><span class="p">|</span> <span class="n">r</span><span class="nf">.parse</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">());</span>
        <span class="p">(</span>
            <span class="n">numbers</span><span class="nf">.next</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">(),</span>
            <span class="n">numbers</span><span class="nf">.next</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">(),</span>
            <span class="n">numbers</span><span class="nf">.next</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">(),</span>
        <span class="p">)</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="nf">parse_group</span><span class="p">(</span><span class="n">group</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="p">(</span><span class="nb">String</span><span class="p">,</span> <span class="p">(</span><span class="nb">String</span><span class="p">,</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">Map</span><span class="o">&gt;</span><span class="p">))</span> <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">lines</span> <span class="o">=</span> <span class="n">group</span><span class="nf">.lines</span><span class="p">();</span>

        <span class="k">let</span> <span class="k">mut</span> <span class="n">header</span> <span class="o">=</span> <span class="n">lines</span><span class="nf">.next</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">()</span><span class="nf">.split</span><span class="p">(</span><span class="o">&amp;</span><span class="p">[</span><span class="sc">'-'</span><span class="p">,</span> <span class="sc">' '</span><span class="p">]);</span>
        <span class="k">let</span> <span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">destination</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">header</span><span class="nf">.next</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">()</span><span class="nf">.to_string</span><span class="p">(),</span>
            <span class="n">header</span><span class="nf">.nth</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="nf">.unwrap</span><span class="p">()</span><span class="nf">.to_string</span><span class="p">(),</span>
        <span class="p">);</span>

        <span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="p">(</span><span class="n">destination</span><span class="p">,</span> <span class="n">lines</span><span class="nf">.map</span><span class="p">(</span><span class="n">parse_ranges</span><span class="p">)</span><span class="nf">.collect</span><span class="p">()))</span>
    <span class="p">}</span>

    <span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="p">:</span> <span class="nb">AsRef</span><span class="o">&lt;</span><span class="nb">str</span><span class="o">&gt;&gt;</span> <span class="nb">From</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="k">for</span> <span class="n">PuzzleData</span> <span class="p">{</span>
        <span class="k">fn</span> <span class="nf">from</span><span class="p">(</span><span class="n">s</span><span class="p">:</span> <span class="n">T</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
            <span class="k">let</span> <span class="k">mut</span> <span class="n">groups</span> <span class="o">=</span> <span class="n">s</span><span class="nf">.as_ref</span><span class="p">()</span><span class="nf">.split</span><span class="p">(</span><span class="s">"</span><span class="se">\n\n</span><span class="s">"</span><span class="p">);</span>
            <span class="k">Self</span> <span class="p">{</span>
                <span class="n">seeds</span><span class="p">:</span> <span class="n">groups</span>
                    <span class="nf">.next</span><span class="p">()</span>
                    <span class="nf">.and_then</span><span class="p">(|</span><span class="n">group</span><span class="p">|</span> <span class="n">group</span><span class="nf">.strip_prefix</span><span class="p">(</span><span class="s">"seeds: "</span><span class="p">))</span>
                    <span class="nf">.and_then</span><span class="p">(|</span><span class="n">seeds</span><span class="p">|</span> <span class="p">{</span>
                        <span class="n">seeds</span>
                            <span class="nf">.split_ascii_whitespace</span><span class="p">()</span>
                            <span class="nf">.map</span><span class="p">(|</span><span class="n">seed</span><span class="p">|</span> <span class="n">seed</span><span class="nf">.parse</span><span class="p">())</span>
                            <span class="py">.collect</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">Result</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="n">_</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">_</span><span class="o">&gt;&gt;</span><span class="p">()</span>
                            <span class="nf">.ok</span><span class="p">()</span>
                    <span class="p">})</span>
                    <span class="nf">.unwrap</span><span class="p">(),</span>
                <span class="n">maps</span><span class="p">:</span> <span class="n">groups</span><span class="nf">.map</span><span class="p">(</span><span class="n">parse_group</span><span class="p">)</span><span class="nf">.collect</span><span class="p">(),</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_star_1_7">Star 1</h3>
<div class="paragraph">
<p>What you see here is my solution for star 1 refactored to be re-usable for star 2.</p>
</div>
<div class="paragraph">
<p>It consists of a generic function <code>star</code> that iterates through all mappings until an item type is reached that cannot be further mapped. It then contains the last element produced by the iteration (should be <code>"location"</code>) and extracts the minimum.</p>
</div>
<div class="paragraph">
<p>The initial value, the function to produce the next value and the function to extract the minimum are specific for <code>star_1</code> and <code>star_2</code> and passed as parameters.</p>
</div>
<div class="paragraph">
<p>The step function for <code>star_1</code> simply checks for every item whether it is contained in any of the mapping ranges. If so, the mapping is applied, otherwise, the unmodified item is returned.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
</pre></td><td class="code"><pre><span class="k">fn</span> <span class="n">star</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">M</span><span class="o">&gt;</span><span class="p">(</span>
    <span class="n">maps</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">HashMap</span><span class="o">&lt;</span><span class="nb">String</span><span class="p">,</span> <span class="p">(</span><span class="nb">String</span><span class="p">,</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">Map</span><span class="o">&gt;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="n">seeds</span><span class="p">:</span> <span class="n">T</span><span class="p">,</span>
    <span class="k">mut</span> <span class="n">step</span><span class="p">:</span> <span class="n">S</span><span class="p">,</span>
    <span class="k">mut</span> <span class="n">minimize</span><span class="p">:</span> <span class="n">M</span><span class="p">,</span>
<span class="p">)</span> <span class="k">-&gt;</span> <span class="n">SolT</span>
<span class="k">where</span>
    <span class="n">R</span><span class="p">:</span> <span class="o">?</span><span class="nb">Sized</span><span class="p">,</span>
    <span class="n">T</span><span class="p">:</span> <span class="nb">AsRef</span><span class="o">&lt;</span><span class="n">R</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="n">S</span><span class="p">:</span> <span class="nf">FnMut</span><span class="p">(</span><span class="o">&amp;</span><span class="n">R</span><span class="p">,</span> <span class="o">&amp;</span><span class="p">[</span><span class="n">Map</span><span class="p">])</span> <span class="k">-&gt;</span> <span class="n">T</span><span class="p">,</span>
    <span class="n">M</span><span class="p">:</span> <span class="nf">FnMut</span><span class="p">(</span><span class="n">T</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">SolT</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">{</span>
    <span class="nf">successors</span><span class="p">(</span><span class="nf">Some</span><span class="p">((</span><span class="s">"seed"</span><span class="p">,</span> <span class="n">seeds</span><span class="p">)),</span> <span class="p">|(</span><span class="n">src</span><span class="p">,</span> <span class="n">items</span><span class="p">)|</span> <span class="p">{</span>
        <span class="n">maps</span><span class="nf">.get</span><span class="p">(</span><span class="o">*</span><span class="n">src</span><span class="p">)</span>
            <span class="nf">.map</span><span class="p">(|(</span><span class="n">dst</span><span class="p">,</span> <span class="n">map</span><span class="p">)|</span> <span class="p">(</span><span class="n">dst</span><span class="nf">.as_str</span><span class="p">(),</span> <span class="nf">step</span><span class="p">(</span><span class="n">items</span><span class="nf">.as_ref</span><span class="p">(),</span> <span class="n">map</span><span class="p">)))</span>
    <span class="p">})</span>
    <span class="nf">.last</span><span class="p">()</span>
    <span class="nf">.and_then</span><span class="p">(|(</span><span class="n">_</span><span class="p">,</span> <span class="n">locations</span><span class="p">)|</span> <span class="nf">minimize</span><span class="p">(</span><span class="n">locations</span><span class="p">))</span>
    <span class="nf">.unwrap</span><span class="p">()</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">step_1</span><span class="p">(</span><span class="n">items</span><span class="p">:</span> <span class="o">&amp;</span><span class="p">[</span><span class="n">SolT</span><span class="p">],</span> <span class="n">map</span><span class="p">:</span> <span class="o">&amp;</span><span class="p">[</span><span class="n">Map</span><span class="p">])</span> <span class="k">-&gt;</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">i64</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="n">items</span>
        <span class="nf">.iter</span><span class="p">()</span>
        <span class="nf">.map</span><span class="p">(|</span><span class="o">&amp;</span><span class="n">item</span><span class="p">|</span> <span class="p">{</span>
            <span class="n">map</span><span class="nf">.iter</span><span class="p">()</span>
                <span class="nf">.find</span><span class="p">(|(</span><span class="n">_</span><span class="p">,</span> <span class="n">src_0</span><span class="p">,</span> <span class="n">len</span><span class="p">)|</span> <span class="p">(</span><span class="o">*</span><span class="n">src_0</span><span class="o">..*</span><span class="n">src_0</span> <span class="o">+</span> <span class="n">len</span><span class="p">)</span><span class="nf">.contains</span><span class="p">(</span><span class="o">&amp;</span><span class="n">item</span><span class="p">))</span>
                <span class="nf">.map</span><span class="p">(|(</span><span class="n">dst_0</span><span class="p">,</span> <span class="n">src_0</span><span class="p">,</span> <span class="n">_</span><span class="p">)|</span> <span class="n">item</span> <span class="o">+</span> <span class="n">dst_0</span> <span class="o">-</span> <span class="n">src_0</span><span class="p">)</span>
                <span class="nf">.unwrap_or</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
        <span class="p">})</span>
        <span class="nf">.collect</span><span class="p">()</span>
<span class="p">}</span>

<span class="k">pub</span> <span class="k">fn</span> <span class="nf">star_1</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">PuzzleData</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">SolT</span> <span class="p">{</span>
    <span class="nf">star</span><span class="p">(</span><span class="o">&amp;</span><span class="n">data</span><span class="py">.maps</span><span class="p">,</span> <span class="n">data</span><span class="py">.seeds</span><span class="nf">.clone</span><span class="p">(),</span> <span class="n">step_1</span><span class="p">,</span> <span class="p">|</span><span class="n">items</span><span class="p">|</span> <span class="p">{</span>
        <span class="n">items</span><span class="nf">.into_iter</span><span class="p">()</span><span class="nf">.min</span><span class="p">()</span>
    <span class="p">})</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_star_2_7">Star 2</h3>
<div class="paragraph">
<p>The general structure of the solution for <code>star_2</code> is the same as the structure for <code>star_1</code>.</p>
</div>
<div class="paragraph">
<p>The initial value is now ranges, i.e., we need to interpret two consecutive seed values as range start and range length.</p>
</div>
<div class="paragraph">
<p>The step function finds for every range an overlapping mapping. If there is one, we distinguish the cases when</p>
</div>
<div class="ulist">
<ul>
<li>
<p>the range is contained in the mapping; then the full range is transformed and added to the result</p>
</li>
<li>
<p>the range is not fully contained in the mapping but overlaps; then the part contained in the mapping is transformed and added to the result, the part not contained in the mapping is processed as additional range</p>
</li>
<li>
<p>the range is not overlapping with any mapping; then it is added to the result as is.</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
</pre></td><td class="code"><pre><span class="k">fn</span> <span class="nf">step_2</span><span class="p">(</span><span class="n">ranges</span><span class="p">:</span> <span class="o">&amp;</span><span class="p">[(</span><span class="n">SolT</span><span class="p">,</span> <span class="n">SolT</span><span class="p">)],</span> <span class="n">map</span><span class="p">:</span> <span class="o">&amp;</span><span class="p">[</span><span class="n">Map</span><span class="p">])</span> <span class="k">-&gt;</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="p">(</span><span class="n">SolT</span><span class="p">,</span> <span class="n">SolT</span><span class="p">)</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="n">ranges</span><span class="nf">.iter</span><span class="p">()</span><span class="nf">.fold</span><span class="p">(</span><span class="nn">Vec</span><span class="p">::</span><span class="nf">new</span><span class="p">(),</span> <span class="p">|</span><span class="k">mut</span> <span class="n">result</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rng</span><span class="p">|</span> <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">rng</span> <span class="o">=</span> <span class="nf">Some</span><span class="p">(</span><span class="n">rng</span><span class="p">);</span>
        <span class="k">while</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">((</span><span class="n">rng_0</span><span class="p">,</span> <span class="n">rng_n</span><span class="p">))</span> <span class="o">=</span> <span class="n">rng</span> <span class="p">{</span>
            <span class="c1">// find a map range that overlaps the current range</span>
            <span class="c1">// return the transformed contained part and optionally</span>
            <span class="c1">// a residual untransformed range</span>
            <span class="k">let</span> <span class="p">(</span><span class="n">transformed</span><span class="p">,</span> <span class="n">residual</span><span class="p">)</span> <span class="o">=</span> <span class="n">map</span>
                <span class="nf">.iter</span><span class="p">()</span>
                <span class="nf">.map</span><span class="p">(|</span><span class="o">&amp;</span><span class="p">(</span><span class="n">dst_0</span><span class="p">,</span> <span class="n">src_0</span><span class="p">,</span> <span class="n">len</span><span class="p">)|</span> <span class="p">(</span><span class="n">dst_0</span> <span class="o">-</span> <span class="n">src_0</span><span class="p">,</span> <span class="n">src_0</span><span class="p">,</span> <span class="n">src_0</span> <span class="o">+</span> <span class="n">len</span><span class="p">))</span>
                <span class="nf">.find</span><span class="p">(|</span><span class="o">&amp;</span><span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="n">src_0</span><span class="p">,</span> <span class="n">src_n</span><span class="p">)|</span> <span class="p">{</span>
                    <span class="p">(</span><span class="n">src_0</span><span class="o">..</span><span class="n">src_n</span><span class="p">)</span><span class="nf">.contains</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rng_0</span><span class="p">)</span> <span class="p">||</span> <span class="p">(</span><span class="n">src_0</span><span class="o">..</span><span class="n">src_n</span><span class="p">)</span><span class="nf">.contains</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">rng_n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
                <span class="p">})</span>
                <span class="nf">.map</span><span class="p">(|(</span><span class="n">dlt</span><span class="p">,</span> <span class="n">src_0</span><span class="p">,</span> <span class="n">src_n</span><span class="p">)|</span> <span class="p">{</span>
                    <span class="k">match</span> <span class="p">(</span>
                        <span class="p">(</span><span class="n">src_0</span><span class="o">..</span><span class="n">src_n</span><span class="p">)</span><span class="nf">.contains</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rng_0</span><span class="p">),</span>
                        <span class="p">(</span><span class="n">src_0</span><span class="o">..</span><span class="n">src_n</span><span class="p">)</span><span class="nf">.contains</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">rng_n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)),</span>
                    <span class="p">)</span> <span class="p">{</span>
                        <span class="p">(</span><span class="k">true</span><span class="p">,</span> <span class="k">false</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">((</span><span class="n">rng_0</span> <span class="o">+</span> <span class="n">dlt</span><span class="p">,</span> <span class="n">src_n</span> <span class="o">+</span> <span class="n">dlt</span><span class="p">),</span> <span class="nf">Some</span><span class="p">((</span><span class="n">src_n</span><span class="p">,</span> <span class="n">rng_n</span><span class="p">))),</span>
                        <span class="p">(</span><span class="k">false</span><span class="p">,</span> <span class="k">true</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">((</span><span class="n">src_0</span> <span class="o">+</span> <span class="n">dlt</span><span class="p">,</span> <span class="n">rng_n</span> <span class="o">+</span> <span class="n">dlt</span><span class="p">),</span> <span class="nf">Some</span><span class="p">((</span><span class="n">rng_0</span><span class="p">,</span> <span class="n">src_0</span><span class="p">))),</span>
                        <span class="n">_</span> <span class="k">=&gt;</span> <span class="p">((</span><span class="n">rng_0</span> <span class="o">+</span> <span class="n">dlt</span><span class="p">,</span> <span class="n">rng_n</span> <span class="o">+</span> <span class="n">dlt</span><span class="p">),</span> <span class="nb">None</span><span class="p">),</span>
                    <span class="p">}</span>
                <span class="p">})</span>
                <span class="nf">.unwrap_or</span><span class="p">(((</span><span class="n">rng_0</span><span class="p">,</span> <span class="n">rng_n</span><span class="p">),</span> <span class="nb">None</span><span class="p">));</span>

            <span class="n">result</span><span class="nf">.push</span><span class="p">(</span><span class="n">transformed</span><span class="p">);</span>
            <span class="n">rng</span> <span class="o">=</span> <span class="n">residual</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">result</span>
    <span class="p">})</span>
<span class="p">}</span>

<span class="k">pub</span> <span class="k">fn</span> <span class="nf">star_2</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">PuzzleData</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">SolT</span> <span class="p">{</span>
    <span class="nf">star</span><span class="p">(</span>
        <span class="o">&amp;</span><span class="n">data</span><span class="py">.maps</span><span class="p">,</span>
        <span class="n">data</span><span class="py">.seeds</span>
            <span class="nf">.iter</span><span class="p">()</span>
            <span class="nf">.step_by</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
            <span class="nf">.zip</span><span class="p">(</span><span class="n">data</span><span class="py">.seeds</span><span class="nf">.iter</span><span class="p">()</span><span class="nf">.skip</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="nf">.step_by</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
            <span class="nf">.map</span><span class="p">(|(</span><span class="o">&amp;</span><span class="n">from</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">len</span><span class="p">)|</span> <span class="p">(</span><span class="n">from</span><span class="p">,</span> <span class="n">from</span> <span class="o">+</span> <span class="n">len</span><span class="p">))</span>
            <span class="py">.collect</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="n">_</span><span class="o">&gt;&gt;</span><span class="p">(),</span>
        <span class="n">step_2</span><span class="p">,</span>
        <span class="p">|</span><span class="n">rng</span><span class="p">|</span> <span class="n">rng</span><span class="nf">.into_iter</span><span class="p">()</span><span class="nf">.map</span><span class="p">(|(</span><span class="n">start</span><span class="p">,</span> <span class="n">_</span><span class="p">)|</span> <span class="n">start</span><span class="p">)</span><span class="nf">.min</span><span class="p">(),</span>
    <span class="p">)</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_tests_5">Tests</h3>
<div class="paragraph">
<p>Tests are as usual.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
</pre></td><td class="code"><pre><span class="nd">#[cfg(test)]</span>
<span class="k">mod</span> <span class="n">tests</span> <span class="p">{</span>
    <span class="k">use</span> <span class="k">super</span><span class="p">::</span><span class="o">*</span><span class="p">;</span>

    <span class="k">const</span> <span class="n">CONTENT</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span> <span class="o">=</span> <span class="s">r#"seeds: 79 14 55 13

seed-to-soil map:
50 98 2
52 50 48

soil-to-fertilizer map:
0 15 37
37 52 2
39 0 15

fertilizer-to-water map:
49 53 8
0 11 42
42 0 7
57 7 4

water-to-light map:
88 18 7
18 25 70

light-to-temperature map:
45 77 23
81 45 19
68 64 13

temperature-to-humidity map:
0 69 1
1 0 69

humidity-to-location map:
60 56 37
56 93 4
"#</span><span class="p">;</span>

    <span class="nd">#[test]</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">test_from</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">data</span> <span class="o">=</span> <span class="nn">PuzzleData</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="n">CONTENT</span><span class="p">);</span>

        <span class="nd">println!</span><span class="p">(</span><span class="s">"{data:?}"</span><span class="p">);</span>

        <span class="c1">// check seeds</span>
        <span class="nd">assert_eq!</span><span class="p">(</span><span class="nd">vec!</span><span class="p">[</span><span class="mi">79</span><span class="p">,</span> <span class="mi">14</span><span class="p">,</span> <span class="mi">55</span><span class="p">,</span> <span class="mi">13</span><span class="p">],</span> <span class="n">data</span><span class="py">.seeds</span><span class="p">);</span>

        <span class="c1">// check that map finds way from seed to location</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">current</span> <span class="o">=</span> <span class="s">"seed"</span><span class="p">;</span>
        <span class="k">while</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">((</span><span class="n">next</span><span class="p">,</span> <span class="n">_</span><span class="p">))</span> <span class="o">=</span> <span class="n">data</span><span class="py">.maps</span><span class="nf">.get</span><span class="p">(</span><span class="n">current</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">current</span> <span class="o">=</span> <span class="n">next</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="nd">assert_eq!</span><span class="p">(</span><span class="s">"location"</span><span class="p">,</span> <span class="n">current</span><span class="p">);</span>

        <span class="c1">// check one map entry</span>
        <span class="nd">assert_eq!</span><span class="p">(</span>
            <span class="nf">Some</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="s">"light"</span><span class="nf">.to_string</span><span class="p">(),</span> <span class="nd">vec!</span><span class="p">[(</span><span class="mi">88</span><span class="p">,</span> <span class="mi">18</span><span class="p">,</span> <span class="mi">7</span><span class="p">),</span> <span class="p">(</span><span class="mi">18</span><span class="p">,</span> <span class="mi">25</span><span class="p">,</span> <span class="mi">70</span><span class="p">)])),</span>
            <span class="n">data</span><span class="py">.maps</span><span class="nf">.get</span><span class="p">(</span><span class="s">"water"</span><span class="p">)</span>
        <span class="p">);</span>
    <span class="p">}</span>

    <span class="nd">#[test]</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">test_star_1</span><span class="p">()</span> <span class="p">{</span>
        <span class="nd">assert_eq!</span><span class="p">(</span><span class="mi">35</span><span class="p">,</span> <span class="nf">star_1</span><span class="p">(</span><span class="o">&amp;</span><span class="n">CONTENT</span><span class="nf">.into</span><span class="p">()));</span>
    <span class="p">}</span>

    <span class="nd">#[test]</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">test_star_2</span><span class="p">()</span> <span class="p">{</span>
        <span class="nd">assert_eq!</span><span class="p">(</span><span class="mi">46</span><span class="p">,</span> <span class="nf">star_2</span><span class="p">(</span><span class="o">&amp;</span><span class="n">CONTENT</span><span class="nf">.into</span><span class="p">()));</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p><a href="#top">Top</a></p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="sol-rust-6">Rust | Day 6: Wait For It</h2>
<div class="sectionbody">
<div class="paragraph">
<p><a href="https://rust-lang.org">Rust</a> solution to <a href="https://adventofcode.com/2023/day/6">AoC|2023|6</a>.</p>
</div>
<div class="sect2">
<h3 id="_star_1_8">Star 1</h3>
<div class="paragraph">
<p>I went the obvious way and did a linear search for the first star.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
</pre></td><td class="code"><pre><span class="k">pub</span> <span class="k">fn</span> <span class="nf">play_naive</span><span class="p">((</span><span class="n">time</span><span class="p">,</span> <span class="n">dist</span><span class="p">):</span> <span class="p">(</span><span class="n">SolT</span><span class="p">,</span> <span class="n">SolT</span><span class="p">))</span> <span class="k">-&gt;</span> <span class="n">SolT</span> <span class="p">{</span>
    <span class="c1">// distance: (time - b) * b</span>
    <span class="p">(</span><span class="mi">0</span><span class="o">..=</span><span class="n">time</span><span class="p">)</span><span class="nf">.filter</span><span class="p">(|</span><span class="o">&amp;</span><span class="n">b</span><span class="p">|</span> <span class="p">(</span><span class="n">time</span> <span class="o">-</span> <span class="n">b</span><span class="p">)</span> <span class="o">*</span> <span class="n">b</span> <span class="o">&gt;</span> <span class="n">dist</span><span class="p">)</span><span class="nf">.count</span><span class="p">()</span> <span class="k">as</span> <span class="n">_</span>
<span class="p">}</span>

<span class="k">pub</span> <span class="k">fn</span> <span class="nf">star_1</span><span class="p">(</span><span class="n">s</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">SolT</span> <span class="p">{</span>
    <span class="nd">#[cfg(feature</span> <span class="nd">=</span> <span class="s">"play_math"</span><span class="nd">)]</span>
    <span class="k">const</span> <span class="n">PLAY</span><span class="p">:</span> <span class="k">fn</span><span class="p">((</span><span class="n">SolT</span><span class="p">,</span> <span class="n">SolT</span><span class="p">))</span> <span class="k">-&gt;</span> <span class="n">SolT</span> <span class="o">=</span> <span class="n">play_math</span><span class="p">;</span>
    <span class="nd">#[cfg(all(not(feature</span> <span class="nd">=</span> <span class="s">"play_math"</span><span class="nd">),</span> <span class="nd">not(feature</span> <span class="nd">=</span> <span class="s">"play_1_smart"</span><span class="nd">)))]</span>
    <span class="k">const</span> <span class="n">PLAY</span><span class="p">:</span> <span class="k">fn</span><span class="p">((</span><span class="n">SolT</span><span class="p">,</span> <span class="n">SolT</span><span class="p">))</span> <span class="k">-&gt;</span> <span class="n">SolT</span> <span class="o">=</span> <span class="n">play_naive</span><span class="p">;</span>
    <span class="nd">#[cfg(all(not(feature</span> <span class="nd">=</span> <span class="s">"play_math"</span><span class="nd">),</span> <span class="nd">feature</span> <span class="nd">=</span> <span class="s">"play_1_smart"</span><span class="nd">))]</span>
    <span class="k">const</span> <span class="n">PLAY</span><span class="p">:</span> <span class="k">fn</span><span class="p">((</span><span class="n">SolT</span><span class="p">,</span> <span class="n">SolT</span><span class="p">))</span> <span class="k">-&gt;</span> <span class="n">SolT</span> <span class="o">=</span> <span class="n">play_smart</span><span class="p">;</span>

    <span class="k">let</span> <span class="k">mut</span> <span class="n">lines</span> <span class="o">=</span> <span class="n">s</span><span class="nf">.lines</span><span class="p">()</span><span class="nf">.map</span><span class="p">(|</span><span class="n">line</span><span class="p">|</span> <span class="p">{</span>
        <span class="n">line</span><span class="nf">.split_ascii_whitespace</span><span class="p">()</span>
            <span class="nf">.skip</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
            <span class="nf">.map</span><span class="p">(|</span><span class="n">value</span><span class="p">|</span> <span class="n">value</span><span class="py">.parse</span><span class="p">::</span><span class="o">&lt;</span><span class="n">SolT</span><span class="o">&gt;</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">())</span>
    <span class="p">});</span>
    <span class="n">lines</span>
        <span class="nf">.next</span><span class="p">()</span>
        <span class="nf">.unwrap</span><span class="p">()</span>
        <span class="nf">.zip</span><span class="p">(</span><span class="n">lines</span><span class="nf">.next</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">())</span>
        <span class="nf">.map</span><span class="p">(</span><span class="n">PLAY</span><span class="p">)</span>
        <span class="nf">.product</span><span class="p">()</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_star_2_8">Star 2</h3>
<div class="paragraph">
<p>A smarter solution to the same problem: bisection (using the fact that the optimal button press time is known), of course solved with an iterator (who wants to see <code>while</code> loops)</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
</pre></td><td class="code"><pre><span class="k">fn</span> <span class="n">bisect</span><span class="o">&lt;</span><span class="n">F</span><span class="p">:</span> <span class="nf">Fn</span><span class="p">(</span><span class="n">SolT</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">bool</span><span class="o">&gt;</span><span class="p">(</span><span class="n">bs</span><span class="p">:</span> <span class="p">(</span><span class="n">SolT</span><span class="p">,</span> <span class="n">SolT</span><span class="p">),</span> <span class="n">test</span><span class="p">:</span> <span class="n">F</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="p">(</span><span class="n">SolT</span><span class="p">,</span> <span class="n">SolT</span><span class="p">)</span> <span class="p">{</span>
    <span class="nf">successors</span><span class="p">(</span><span class="nf">Some</span><span class="p">(</span><span class="n">bs</span><span class="p">),</span> <span class="p">|</span><span class="o">&amp;</span><span class="p">(</span><span class="n">b_l</span><span class="p">,</span> <span class="n">b_r</span><span class="p">)|</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">b</span> <span class="o">=</span> <span class="p">(</span><span class="n">b_l</span> <span class="o">+</span> <span class="n">b_r</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">;</span>
        <span class="k">if</span> <span class="nf">test</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="p">{</span>
            <span class="nf">Some</span><span class="p">((</span><span class="n">b_l</span><span class="p">,</span> <span class="n">b</span><span class="p">))</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="nf">Some</span><span class="p">((</span><span class="n">b</span><span class="p">,</span> <span class="n">b_r</span><span class="p">))</span>
        <span class="p">}</span>
    <span class="p">})</span>
    <span class="nf">.find</span><span class="p">(|(</span><span class="n">b_l</span><span class="p">,</span> <span class="n">b_r</span><span class="p">)|</span> <span class="n">b_r</span> <span class="o">-</span> <span class="n">b_l</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">)</span>
    <span class="nf">.unwrap</span><span class="p">()</span>
<span class="p">}</span>

<span class="k">pub</span> <span class="k">fn</span> <span class="nf">play_smart</span><span class="p">((</span><span class="n">time</span><span class="p">,</span> <span class="n">dist</span><span class="p">):</span> <span class="p">(</span><span class="n">SolT</span><span class="p">,</span> <span class="n">SolT</span><span class="p">))</span> <span class="k">-&gt;</span> <span class="n">SolT</span> <span class="p">{</span>
    <span class="c1">// distance: (time - b) * b</span>
    <span class="c1">// optimum: time - 2 b = 0 =&gt; (time - time &gt;&gt; 1) * (time &gt;&gt; 1)</span>
    <span class="k">let</span> <span class="n">b_opt</span> <span class="o">=</span> <span class="n">time</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">let</span> <span class="p">(</span><span class="n">b_l</span><span class="p">,</span> <span class="n">_</span><span class="p">)</span> <span class="o">=</span> <span class="nf">bisect</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="n">b_opt</span><span class="p">),</span> <span class="p">|</span><span class="n">b</span><span class="p">|</span> <span class="p">(</span><span class="n">time</span> <span class="o">-</span> <span class="n">b</span><span class="p">)</span> <span class="o">*</span> <span class="n">b</span> <span class="o">&gt;</span> <span class="n">dist</span><span class="p">);</span>
    <span class="k">let</span> <span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="n">b_r</span><span class="p">)</span> <span class="o">=</span> <span class="nf">bisect</span><span class="p">((</span><span class="n">b_opt</span><span class="p">,</span> <span class="n">time</span><span class="p">),</span> <span class="p">|</span><span class="n">b</span><span class="p">|</span> <span class="p">(</span><span class="n">time</span> <span class="o">-</span> <span class="n">b</span><span class="p">)</span> <span class="o">*</span> <span class="n">b</span> <span class="o">&lt;=</span> <span class="n">dist</span><span class="p">);</span>
    <span class="n">b_r</span> <span class="o">-</span> <span class="n">b_l</span> <span class="o">-</span> <span class="mi">1</span>
<span class="p">}</span>

<span class="k">pub</span> <span class="k">fn</span> <span class="nf">play_math</span><span class="p">((</span><span class="n">time</span><span class="p">,</span> <span class="n">dist</span><span class="p">):</span> <span class="p">(</span><span class="n">SolT</span><span class="p">,</span> <span class="n">SolT</span><span class="p">))</span> <span class="k">-&gt;</span> <span class="n">SolT</span> <span class="p">{</span>
    <span class="c1">// distance: (time - b) * b &gt; dist</span>
    <span class="c1">// b^2 - time * b + dist = 0</span>
    <span class="c1">// b = (time +/- sqrt(time^2 - 4 dist)) / 2</span>

    <span class="k">let</span> <span class="n">sqrt_d</span> <span class="o">=</span> <span class="p">((</span><span class="n">time</span> <span class="o">*</span> <span class="n">time</span> <span class="o">-</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">dist</span><span class="p">)</span> <span class="k">as</span> <span class="nb">f64</span><span class="p">)</span><span class="nf">.sqrt</span><span class="p">();</span>
    <span class="k">let</span> <span class="n">b1</span> <span class="o">=</span> <span class="p">(((</span><span class="n">time</span> <span class="k">as</span> <span class="nb">f64</span><span class="p">)</span> <span class="o">-</span> <span class="n">sqrt_d</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span><span class="p">)</span><span class="nf">.floor</span><span class="p">()</span> <span class="k">as</span> <span class="n">SolT</span><span class="p">;</span>
    <span class="k">let</span> <span class="n">b2</span> <span class="o">=</span> <span class="p">(((</span><span class="n">time</span> <span class="k">as</span> <span class="nb">f64</span><span class="p">)</span> <span class="o">+</span> <span class="n">sqrt_d</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span><span class="p">)</span><span class="nf">.ceil</span><span class="p">()</span> <span class="k">as</span> <span class="n">SolT</span><span class="p">;</span>

    <span class="n">b2</span> <span class="o">-</span> <span class="n">b1</span> <span class="o">-</span> <span class="mi">1</span>
<span class="p">}</span>

<span class="k">pub</span> <span class="k">fn</span> <span class="nf">star_2</span><span class="p">(</span><span class="n">s</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">SolT</span> <span class="p">{</span>
    <span class="nd">#[cfg(feature</span> <span class="nd">=</span> <span class="s">"play_math"</span><span class="nd">)]</span>
    <span class="k">const</span> <span class="n">PLAY</span><span class="p">:</span> <span class="k">fn</span><span class="p">((</span><span class="n">SolT</span><span class="p">,</span> <span class="n">SolT</span><span class="p">))</span> <span class="k">-&gt;</span> <span class="n">SolT</span> <span class="o">=</span> <span class="n">play_math</span><span class="p">;</span>
    <span class="nd">#[cfg(all(not(feature</span> <span class="nd">=</span> <span class="s">"play_math"</span><span class="nd">),</span> <span class="nd">feature</span> <span class="nd">=</span> <span class="s">"play_2_naive"</span><span class="nd">))]</span>
    <span class="k">const</span> <span class="n">PLAY</span><span class="p">:</span> <span class="k">fn</span><span class="p">((</span><span class="n">SolT</span><span class="p">,</span> <span class="n">SolT</span><span class="p">))</span> <span class="k">-&gt;</span> <span class="n">SolT</span> <span class="o">=</span> <span class="n">play_naive</span><span class="p">;</span>
    <span class="nd">#[cfg(all(not(feature</span> <span class="nd">=</span> <span class="s">"play_math"</span><span class="nd">),</span> <span class="nd">not(feature</span> <span class="nd">=</span> <span class="s">"play_2_naive"</span><span class="nd">)))]</span>
    <span class="k">const</span> <span class="n">PLAY</span><span class="p">:</span> <span class="k">fn</span><span class="p">((</span><span class="n">SolT</span><span class="p">,</span> <span class="n">SolT</span><span class="p">))</span> <span class="k">-&gt;</span> <span class="n">SolT</span> <span class="o">=</span> <span class="n">play_smart</span><span class="p">;</span>

    <span class="k">let</span> <span class="k">mut</span> <span class="n">values</span> <span class="o">=</span> <span class="n">s</span><span class="nf">.lines</span><span class="p">()</span><span class="nf">.map</span><span class="p">(|</span><span class="n">line</span><span class="p">|</span> <span class="p">{</span>
        <span class="n">line</span><span class="nf">.bytes</span><span class="p">()</span>
            <span class="nf">.filter</span><span class="p">(</span><span class="nn">u8</span><span class="p">::</span><span class="n">is_ascii_digit</span><span class="p">)</span>
            <span class="nf">.fold</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="p">|</span><span class="n">val</span><span class="p">,</span> <span class="n">b</span><span class="p">|</span> <span class="mi">10</span> <span class="o">*</span> <span class="n">val</span> <span class="o">+</span> <span class="p">(</span><span class="n">b</span> <span class="o">-</span> <span class="sc">b'0'</span><span class="p">)</span> <span class="k">as</span> <span class="n">SolT</span><span class="p">)</span>
    <span class="p">});</span>
    <span class="nf">PLAY</span><span class="p">((</span><span class="n">values</span><span class="nf">.next</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">(),</span> <span class="n">values</span><span class="nf">.next</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">()))</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>Later on, I realized that the second part is much more tractable than what I believed and the solution for part 1 is actually good enough. I created features to enable the following variants:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>cargo run --release --features play_1_smart</code> uses the solution for the second part also for the first part (and uses about the same time)</p>
</li>
<li>
<p><code>cargo run --release --features play_2_naive</code> uses the solution for the first part also for the second part (and still finishes in a couple of milliseconds)</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_benchmarks">Benchmarks</h3>
<div class="paragraph">
<p>And because I was curious on how the code really performs, I also created a <code>Criterion.rs</code> bench for the first time:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
</pre></td><td class="code"><pre><span class="k">use</span> <span class="nn">criterion</span><span class="p">::{</span><span class="n">black_box</span><span class="p">,</span> <span class="n">criterion_group</span><span class="p">,</span> <span class="n">criterion_main</span><span class="p">,</span> <span class="n">Criterion</span><span class="p">};</span>
<span class="k">use</span> <span class="nn">mr_kaffee_2023_06</span><span class="p">::</span><span class="o">*</span><span class="p">;</span>

<span class="k">pub</span> <span class="k">fn</span> <span class="nf">criterion_benchmark</span><span class="p">(</span><span class="n">c</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">Criterion</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">data</span> <span class="o">=</span> <span class="nf">parse_input</span><span class="p">();</span>
    <span class="n">c</span><span class="nf">.bench_function</span><span class="p">(</span><span class="s">"star_1"</span><span class="p">,</span> <span class="p">|</span><span class="n">b</span><span class="p">|</span> <span class="n">b</span><span class="nf">.iter</span><span class="p">(||</span> <span class="nf">star_1</span><span class="p">(</span><span class="nf">black_box</span><span class="p">(</span><span class="o">&amp;</span><span class="n">data</span><span class="p">))));</span>
    <span class="n">c</span><span class="nf">.bench_function</span><span class="p">(</span><span class="s">"star_2"</span><span class="p">,</span> <span class="p">|</span><span class="n">b</span><span class="p">|</span> <span class="n">b</span><span class="nf">.iter</span><span class="p">(||</span> <span class="nf">star_2</span><span class="p">(</span><span class="nf">black_box</span><span class="p">(</span><span class="o">&amp;</span><span class="n">data</span><span class="p">))));</span>
<span class="p">}</span>

<span class="nd">criterion_group!</span><span class="p">(</span><span class="n">benches</span><span class="p">,</span> <span class="n">criterion_benchmark</span><span class="p">);</span>
<span class="nd">criterion_main!</span><span class="p">(</span><span class="n">benches</span><span class="p">);</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_tests_6">Tests</h3>
<div class="paragraph">
<p>Not worth mentioning</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
</pre></td><td class="code"><pre><span class="nd">#[cfg(test)]</span>
<span class="k">mod</span> <span class="n">tests</span> <span class="p">{</span>
    <span class="k">use</span> <span class="k">super</span><span class="p">::</span><span class="o">*</span><span class="p">;</span>

    <span class="k">const</span> <span class="n">CONTENT</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span> <span class="o">=</span> <span class="s">r#"Time:      7  15   30
Distance:  9  40  200
"#</span><span class="p">;</span>

    <span class="nd">#[test]</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">test_star_1</span><span class="p">()</span> <span class="p">{</span>
        <span class="nd">assert_eq!</span><span class="p">(</span><span class="mi">288</span><span class="p">,</span> <span class="nf">star_1</span><span class="p">(</span><span class="o">&amp;</span><span class="n">CONTENT</span><span class="p">));</span>
    <span class="p">}</span>

    <span class="nd">#[test]</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">test_star_2</span><span class="p">()</span> <span class="p">{</span>
        <span class="nd">assert_eq!</span><span class="p">(</span><span class="mi">71_503</span><span class="p">,</span> <span class="nf">star_2</span><span class="p">(</span><span class="o">&amp;</span><span class="n">CONTENT</span><span class="p">));</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p><a href="#top">Top</a></p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="sol-rust-7">Rust | Day 7: Camel Cards</h2>
<div class="sectionbody">
<div class="paragraph">
<p><a href="https://rust-lang.org">Rust</a> solution to <a href="https://adventofcode.com/2023/day/7">AoC|2023|7</a>.</p>
</div>
<div class="paragraph">
<p>I still prefer <a href="https://adventofcode.com/2019/day/22">Space Cards</a> over Camel Cards ;)</p>
</div>
<div class="sect2">
<h3 id="_input_6">Input</h3>
<div class="paragraph">
<p>The input is a vector of pairs of cards (as byte array) and bids.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
</pre></td><td class="code"><pre><span class="k">mod</span> <span class="n">input</span> <span class="p">{</span>
    <span class="k">use</span> <span class="k">crate</span><span class="p">::</span><span class="n">SolT</span><span class="p">;</span>

    <span class="nd">#[derive(Debug,</span> <span class="nd">PartialEq,</span> <span class="nd">Eq)]</span>
    <span class="k">pub</span> <span class="k">struct</span> <span class="nf">PuzzleData</span><span class="p">(</span><span class="k">pub</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="p">([</span><span class="nb">u8</span><span class="p">;</span> <span class="mi">5</span><span class="p">],</span> <span class="n">SolT</span><span class="p">)</span><span class="o">&gt;</span><span class="p">);</span>

    <span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="p">:</span> <span class="nb">AsRef</span><span class="o">&lt;</span><span class="nb">str</span><span class="o">&gt;&gt;</span> <span class="nb">From</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="k">for</span> <span class="n">PuzzleData</span> <span class="p">{</span>
        <span class="k">fn</span> <span class="nf">from</span><span class="p">(</span><span class="n">value</span><span class="p">:</span> <span class="n">T</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
            <span class="k">Self</span><span class="p">(</span>
                <span class="n">value</span>
                    <span class="nf">.as_ref</span><span class="p">()</span>
                    <span class="nf">.lines</span><span class="p">()</span>
                    <span class="nf">.filter_map</span><span class="p">(|</span><span class="n">line</span><span class="p">|</span> <span class="n">line</span><span class="nf">.split_once</span><span class="p">(</span><span class="sc">' '</span><span class="p">))</span>
                    <span class="nf">.map</span><span class="p">(|(</span><span class="n">cards</span><span class="p">,</span> <span class="n">bid</span><span class="p">)|</span> <span class="p">{</span>
                        <span class="p">(</span>
                            <span class="n">cards</span><span class="nf">.bytes</span><span class="p">()</span><span class="nf">.take</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span><span class="nf">.enumerate</span><span class="p">()</span><span class="nf">.fold</span><span class="p">(</span>
                                <span class="p">[</span><span class="mi">0</span><span class="p">;</span> <span class="mi">5</span><span class="p">],</span>
                                <span class="p">|</span><span class="k">mut</span> <span class="n">cards</span><span class="p">,</span> <span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="n">card</span><span class="p">)|</span> <span class="p">{</span>
                                    <span class="n">cards</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span> <span class="o">=</span> <span class="n">card</span><span class="p">;</span>
                                    <span class="n">cards</span>
                                <span class="p">},</span>
                            <span class="p">),</span>
                            <span class="n">bid</span><span class="nf">.parse</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">(),</span>
                        <span class="p">)</span>
                    <span class="p">})</span>
                    <span class="nf">.collect</span><span class="p">(),</span>
            <span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_star_1_9">Star 1</h3>
<div class="paragraph">
<p>I refactored my solution a bit to be usable for both parts. The <code>joker</code> parameter that appears as argument in some of the functions is set to false for the first part.</p>
</div>
<div class="paragraph">
<p>The idea is to put the hands in a format so that we can sort a vector of hands to get them sorted by rank. This is achieved by representing hands as a pair of a hand type and a cards array.</p>
</div>
<div class="paragraph">
<p>In the cards array, I cannot use the raw bytes, since that would result in a wrong lexicographically ordering. So I map the raw bytes to an ordinal value using <code>map_cards</code>.</p>
</div>
<div class="paragraph">
<p>The most tricky part is to determine the type of the hand. The algorithm (implemented in <code>HandType::from(&amp;[u8; 5])</code>) is as follows: count the number of occurrences for every card type in a hand (into an array), extract the two biggest numbers (neglecting the card type) and choose the hand based on those (for part 1, the number of jokers is always 0).</p>
</div>
<div class="paragraph">
<p>With this, we can sort the hands by rank and calculate the score with a <code>fold</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
</pre></td><td class="code"><pre><span class="k">pub</span> <span class="k">fn</span> <span class="nf">map_cards</span><span class="p">(</span><span class="n">cards</span><span class="p">:</span> <span class="o">&amp;</span><span class="p">[</span><span class="nb">u8</span><span class="p">;</span> <span class="mi">5</span><span class="p">],</span> <span class="n">joker</span><span class="p">:</span> <span class="nb">bool</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="p">[</span><span class="nb">u8</span><span class="p">;</span> <span class="mi">5</span><span class="p">]</span> <span class="p">{</span>
    <span class="n">cards</span><span class="nf">.map</span><span class="p">(|</span><span class="n">b</span><span class="p">|</span> <span class="k">match</span> <span class="n">b</span> <span class="p">{</span>
        <span class="sc">b'A'</span> <span class="k">=&gt;</span> <span class="mi">14</span><span class="p">,</span>
        <span class="sc">b'K'</span> <span class="k">=&gt;</span> <span class="mi">13</span><span class="p">,</span>
        <span class="sc">b'Q'</span> <span class="k">=&gt;</span> <span class="mi">12</span><span class="p">,</span>
        <span class="sc">b'J'</span> <span class="k">if</span> <span class="n">joker</span> <span class="k">=&gt;</span> <span class="mi">0</span><span class="p">,</span>
        <span class="sc">b'J'</span> <span class="k">=&gt;</span> <span class="mi">11</span><span class="p">,</span>
        <span class="sc">b'T'</span> <span class="k">=&gt;</span> <span class="mi">10</span><span class="p">,</span>
        <span class="n">b</span> <span class="k">=&gt;</span> <span class="n">b</span> <span class="o">-</span> <span class="sc">b'0'</span><span class="p">,</span>
    <span class="p">})</span>
<span class="p">}</span>

<span class="nd">#[derive(Debug,</span> <span class="nd">PartialEq,</span> <span class="nd">Eq,</span> <span class="nd">PartialOrd,</span> <span class="nd">Ord,</span> <span class="nd">Clone,</span> <span class="nd">Copy)]</span>
<span class="k">pub</span> <span class="k">enum</span> <span class="n">HandType</span> <span class="p">{</span>
    <span class="n">HighCard</span><span class="p">,</span>
    <span class="n">OnePair</span><span class="p">,</span>
    <span class="n">TwoPair</span><span class="p">,</span>
    <span class="n">ThreeOfAKind</span><span class="p">,</span>
    <span class="n">FullHouse</span><span class="p">,</span>
    <span class="n">FourOfAKind</span><span class="p">,</span>
    <span class="n">FiveOfAKind</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="nb">From</span><span class="o">&lt;&amp;</span><span class="p">[</span><span class="nb">u8</span><span class="p">;</span> <span class="mi">5</span><span class="p">]</span><span class="o">&gt;</span> <span class="k">for</span> <span class="n">HandType</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">from</span><span class="p">(</span><span class="n">cards</span><span class="p">:</span> <span class="o">&amp;</span><span class="p">[</span><span class="nb">u8</span><span class="p">;</span> <span class="mi">5</span><span class="p">])</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">map</span> <span class="o">=</span> <span class="n">cards</span><span class="nf">.iter</span><span class="p">()</span><span class="nf">.fold</span><span class="p">([</span><span class="mi">0</span><span class="p">;</span> <span class="mi">15</span><span class="p">],</span> <span class="p">|</span><span class="k">mut</span> <span class="n">map</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">card</span><span class="p">|</span> <span class="p">{</span>
            <span class="n">map</span><span class="p">[</span><span class="n">card</span> <span class="k">as</span> <span class="nb">usize</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
            <span class="n">map</span>
        <span class="p">});</span>

        <span class="k">let</span> <span class="n">jokers</span> <span class="o">=</span> <span class="n">map</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
        <span class="k">let</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="o">=</span> <span class="n">map</span><span class="p">[</span><span class="mi">2</span><span class="o">..</span><span class="p">]</span>
            <span class="nf">.iter</span><span class="p">()</span>
            <span class="nf">.fold</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">|(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">v</span><span class="p">|</span> <span class="k">match</span> <span class="p">(</span><span class="n">v</span> <span class="o">&gt;</span> <span class="n">a</span><span class="p">,</span> <span class="n">v</span> <span class="o">&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
                <span class="p">(</span><span class="k">true</span><span class="p">,</span> <span class="n">_</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">a</span><span class="p">),</span>
                <span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="k">true</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">v</span><span class="p">),</span>
                <span class="n">_</span> <span class="k">=&gt;</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">),</span>
            <span class="p">});</span>

        <span class="k">match</span> <span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="n">jokers</span><span class="p">,</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span> <span class="o">+</span> <span class="n">jokers</span><span class="p">)</span> <span class="p">{</span>
            <span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="n">_</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="k">Self</span><span class="p">::</span><span class="n">FiveOfAKind</span><span class="p">,</span>
            <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">_</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="k">Self</span><span class="p">::</span><span class="n">FourOfAKind</span><span class="p">,</span>
            <span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="k">Self</span><span class="p">::</span><span class="n">FullHouse</span><span class="p">,</span>
            <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">_</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="k">Self</span><span class="p">::</span><span class="n">ThreeOfAKind</span><span class="p">,</span>
            <span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="k">Self</span><span class="p">::</span><span class="n">TwoPair</span><span class="p">,</span>
            <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">_</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="k">Self</span><span class="p">::</span><span class="n">OnePair</span><span class="p">,</span>
            <span class="n">_</span> <span class="k">=&gt;</span> <span class="k">Self</span><span class="p">::</span><span class="n">HighCard</span><span class="p">,</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">pub</span> <span class="k">fn</span> <span class="nf">star</span><span class="p">(</span><span class="nf">PuzzleData</span><span class="p">(</span><span class="n">input</span><span class="p">):</span> <span class="o">&amp;</span><span class="n">PuzzleData</span><span class="p">,</span> <span class="n">joker</span><span class="p">:</span> <span class="nb">bool</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">SolT</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">hands</span> <span class="o">=</span> <span class="n">input</span>
        <span class="nf">.iter</span><span class="p">()</span>
        <span class="nf">.map</span><span class="p">(|(</span><span class="n">cards</span><span class="p">,</span> <span class="n">bid</span><span class="p">)|</span> <span class="p">(</span><span class="nf">map_cards</span><span class="p">(</span><span class="n">cards</span><span class="p">,</span> <span class="n">joker</span><span class="p">),</span> <span class="o">*</span><span class="n">bid</span><span class="p">))</span>
        <span class="nf">.map</span><span class="p">(|(</span><span class="n">cards</span><span class="p">,</span> <span class="n">bid</span><span class="p">)|</span> <span class="p">((</span><span class="nn">HandType</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cards</span><span class="p">),</span> <span class="n">cards</span><span class="p">),</span> <span class="n">bid</span><span class="p">))</span>
        <span class="py">.collect</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="n">_</span><span class="o">&gt;&gt;</span><span class="p">();</span>

    <span class="n">hands</span><span class="nf">.sort_unstable</span><span class="p">();</span>

    <span class="n">hands</span>
        <span class="nf">.iter</span><span class="p">()</span>
        <span class="nf">.enumerate</span><span class="p">()</span>
        <span class="nf">.map</span><span class="p">(|(</span><span class="n">pos</span><span class="p">,</span> <span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="n">bid</span><span class="p">))|</span> <span class="p">(</span><span class="n">pos</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">bid</span><span class="p">)</span>
        <span class="nf">.sum</span><span class="p">()</span>
<span class="p">}</span>

<span class="k">pub</span> <span class="k">fn</span> <span class="nf">star_1</span><span class="p">(</span><span class="n">input</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">PuzzleData</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">SolT</span> <span class="p">{</span>
    <span class="nf">star</span><span class="p">(</span><span class="n">input</span><span class="p">,</span> <span class="k">false</span><span class="p">)</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_star_2_9">Star 2</h3>
<div class="paragraph">
<p>In the second part, the symbol <code>J</code> no longer signifies a Jack but a Joker that can stand in for any card but has a lower ordinal number than any other card. This is implemented in <code>map_cards</code> in the line <code>b&#8217;J' if joker &#8658; 0</code> and with the guard conditions in the <code>match</code> statement in <code>HandType::from(&amp;[u8; 5])</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno">1
2
3
</pre></td><td class="code"><pre><span class="k">pub</span> <span class="k">fn</span> <span class="nf">star_2</span><span class="p">(</span><span class="n">input</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">PuzzleData</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">SolT</span> <span class="p">{</span>
    <span class="nf">star</span><span class="p">(</span><span class="n">input</span><span class="p">,</span> <span class="k">true</span><span class="p">)</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_tests_7">Tests</h3>
<div class="paragraph">
<p>One special test today verifies that a hand does not get worse with jokers (on the actual input data)</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
</pre></td><td class="code"><pre><span class="nd">#[cfg(test)]</span>
<span class="k">mod</span> <span class="n">tests</span> <span class="p">{</span>
    <span class="k">use</span> <span class="k">super</span><span class="p">::</span><span class="o">*</span><span class="p">;</span>

    <span class="k">const</span> <span class="n">CONTENT</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span> <span class="o">=</span> <span class="s">r#"32T3K 765
T55J5 684
KK677 28
KTJJT 220
QQQJA 483
"#</span><span class="p">;</span>

    <span class="nd">#[test]</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">test_input_from</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">data</span> <span class="o">=</span> <span class="nn">PuzzleData</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="n">CONTENT</span><span class="p">);</span>
        <span class="nd">assert_eq!</span><span class="p">(</span>
            <span class="nf">PuzzleData</span><span class="p">(</span><span class="nd">vec!</span><span class="p">[</span>
                <span class="p">([</span><span class="sc">b'3'</span><span class="p">,</span> <span class="sc">b'2'</span><span class="p">,</span> <span class="sc">b'T'</span><span class="p">,</span> <span class="sc">b'3'</span><span class="p">,</span> <span class="sc">b'K'</span><span class="p">],</span> <span class="mi">765</span><span class="p">),</span>
                <span class="p">([</span><span class="sc">b'T'</span><span class="p">,</span> <span class="sc">b'5'</span><span class="p">,</span> <span class="sc">b'5'</span><span class="p">,</span> <span class="sc">b'J'</span><span class="p">,</span> <span class="sc">b'5'</span><span class="p">],</span> <span class="mi">684</span><span class="p">),</span>
                <span class="p">([</span><span class="sc">b'K'</span><span class="p">,</span> <span class="sc">b'K'</span><span class="p">,</span> <span class="sc">b'6'</span><span class="p">,</span> <span class="sc">b'7'</span><span class="p">,</span> <span class="sc">b'7'</span><span class="p">],</span> <span class="mi">28</span><span class="p">),</span>
                <span class="p">([</span><span class="sc">b'K'</span><span class="p">,</span> <span class="sc">b'T'</span><span class="p">,</span> <span class="sc">b'J'</span><span class="p">,</span> <span class="sc">b'J'</span><span class="p">,</span> <span class="sc">b'T'</span><span class="p">],</span> <span class="mi">220</span><span class="p">),</span>
                <span class="p">([</span><span class="sc">b'Q'</span><span class="p">,</span> <span class="sc">b'Q'</span><span class="p">,</span> <span class="sc">b'Q'</span><span class="p">,</span> <span class="sc">b'J'</span><span class="p">,</span> <span class="sc">b'A'</span><span class="p">],</span> <span class="mi">483</span><span class="p">)</span>
            <span class="p">]),</span>
            <span class="n">data</span>
        <span class="p">);</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"{data:?}"</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="nd">#[test]</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">test_star_1</span><span class="p">()</span> <span class="p">{</span>
        <span class="nd">assert_eq!</span><span class="p">(</span><span class="mi">6440</span><span class="p">,</span> <span class="nf">star_1</span><span class="p">(</span><span class="o">&amp;</span><span class="n">CONTENT</span><span class="nf">.into</span><span class="p">()));</span>
    <span class="p">}</span>

    <span class="nd">#[test]</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">test_star_2</span><span class="p">()</span> <span class="p">{</span>
        <span class="nd">assert_eq!</span><span class="p">(</span><span class="mi">5905</span><span class="p">,</span> <span class="nf">star_2</span><span class="p">(</span><span class="o">&amp;</span><span class="n">CONTENT</span><span class="nf">.into</span><span class="p">()));</span>
    <span class="p">}</span>

    <span class="nd">#[test]</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">test_joker</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">let</span> <span class="nf">PuzzleData</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">=</span> <span class="nf">parse_input</span><span class="p">();</span>

        <span class="k">for</span> <span class="p">(</span><span class="n">cards</span><span class="p">,</span> <span class="n">_</span><span class="p">)</span> <span class="k">in</span> <span class="n">data</span><span class="nf">.iter</span><span class="p">()</span> <span class="p">{</span>
            <span class="nd">assert!</span><span class="p">(</span>
                <span class="nn">HandType</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="o">&amp;</span><span class="nf">map_cards</span><span class="p">(</span><span class="n">cards</span><span class="p">,</span> <span class="kc">true</span><span class="p">))</span> <span class="o">&gt;=</span> <span class="nn">HandType</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="o">&amp;</span><span class="nf">map_cards</span><span class="p">(</span><span class="n">cards</span><span class="p">,</span> <span class="kc">false</span><span class="p">)),</span>
                <span class="s">"Hand got worse with jokers: {:?}"</span><span class="p">,</span>
                <span class="n">cards</span>
            <span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p><a href="#top">Top</a></p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="sol-rust-8">Rust | Day 8: Haunted Wasteland</h2>
<div class="sectionbody">
<div class="paragraph">
<p><a href="https://rust-lang.org">Rust</a> solution to <a href="https://adventofcode.com/2023/day/8">AoC|2023|8</a>.</p>
</div>
<div class="sect2">
<h3 id="_input_7">Input</h3>
<div class="paragraph">
<p>The input is parsed into a tuple of a byte array representing directions and a hash map representing the map.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
</pre></td><td class="code"><pre><span class="k">pub</span> <span class="k">mod</span> <span class="n">input</span> <span class="p">{</span>
    <span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">collections</span><span class="p">::</span><span class="n">HashMap</span><span class="p">;</span>

    <span class="nd">#[derive(Debug,</span> <span class="nd">PartialEq,</span> <span class="nd">Eq)]</span>
    <span class="k">pub</span> <span class="k">struct</span> <span class="n">PuzzleData</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span><span class="p">(</span><span class="k">pub</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="p">[</span><span class="nb">u8</span><span class="p">],</span> <span class="k">pub</span> <span class="n">HashMap</span><span class="o">&lt;&amp;</span><span class="nv">'a</span> <span class="nb">str</span><span class="p">,</span> <span class="p">(</span><span class="o">&amp;</span><span class="nv">'a</span> <span class="nb">str</span><span class="p">,</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="nb">str</span><span class="p">)</span><span class="o">&gt;</span><span class="p">);</span>

    <span class="k">impl</span><span class="o">&lt;</span><span class="nv">'a</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="nb">From</span><span class="o">&lt;&amp;</span><span class="nv">'a</span> <span class="n">T</span><span class="o">&gt;</span> <span class="k">for</span> <span class="n">PuzzleData</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span>
    <span class="k">where</span>
        <span class="n">T</span><span class="p">:</span> <span class="nb">AsRef</span><span class="o">&lt;</span><span class="nb">str</span><span class="o">&gt;</span> <span class="o">+</span> <span class="nv">'a</span> <span class="o">+</span> <span class="o">?</span><span class="nb">Sized</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="k">fn</span> <span class="nf">from</span><span class="p">(</span><span class="n">s</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="n">T</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
            <span class="k">let</span> <span class="k">mut</span> <span class="n">lines</span> <span class="o">=</span> <span class="n">s</span><span class="nf">.as_ref</span><span class="p">()</span><span class="nf">.lines</span><span class="p">();</span>

            <span class="k">let</span> <span class="n">dirs</span> <span class="o">=</span> <span class="n">lines</span><span class="nf">.next</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">()</span><span class="nf">.as_bytes</span><span class="p">();</span>
            <span class="k">let</span> <span class="n">map</span> <span class="o">=</span> <span class="n">lines</span>
                <span class="nf">.skip</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
                <span class="nf">.filter_map</span><span class="p">(|</span><span class="n">line</span><span class="p">|</span> <span class="n">line</span><span class="nf">.split_once</span><span class="p">(</span><span class="s">" = "</span><span class="p">))</span>
                <span class="nf">.map</span><span class="p">(|(</span><span class="n">key</span><span class="p">,</span> <span class="n">values</span><span class="p">)|</span> <span class="p">{</span>
                    <span class="p">(</span>
                        <span class="n">key</span><span class="p">,</span>
                        <span class="n">values</span>
                            <span class="nf">.strip_prefix</span><span class="p">(</span><span class="sc">'('</span><span class="p">)</span>
                            <span class="nf">.and_then</span><span class="p">(|</span><span class="n">values</span><span class="p">|</span> <span class="n">values</span><span class="nf">.strip_suffix</span><span class="p">(</span><span class="sc">')'</span><span class="p">))</span>
                            <span class="nf">.and_then</span><span class="p">(|</span><span class="n">values</span><span class="p">|</span> <span class="n">values</span><span class="nf">.split_once</span><span class="p">(</span><span class="s">", "</span><span class="p">))</span>
                            <span class="nf">.unwrap</span><span class="p">(),</span>
                    <span class="p">)</span>
                <span class="p">})</span>
                <span class="nf">.collect</span><span class="p">();</span>
            <span class="k">Self</span><span class="p">(</span><span class="n">dirs</span><span class="p">,</span> <span class="n">map</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_star_1_10">Star 1</h3>
<div class="paragraph">
<p>The iterator returned by <code>map_iter</code> navigates the map step by step. The solution just iterates until <code>ZZZ</code> is reached.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
</pre></td><td class="code"><pre><span class="k">pub</span> <span class="k">fn</span> <span class="n">map_iter</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span><span class="p">(</span>
    <span class="n">dirs</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="p">[</span><span class="nb">u8</span><span class="p">],</span>
    <span class="n">map</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="n">HashMap</span><span class="o">&lt;&amp;</span><span class="nv">'a</span> <span class="nb">str</span><span class="p">,</span> <span class="p">(</span><span class="o">&amp;</span><span class="nv">'a</span> <span class="nb">str</span><span class="p">,</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="nb">str</span><span class="p">)</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="n">node</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="nb">str</span><span class="p">,</span>
<span class="p">)</span> <span class="k">-&gt;</span> <span class="k">impl</span> <span class="nb">Iterator</span><span class="o">&lt;</span><span class="n">Item</span> <span class="o">=</span> <span class="p">(</span><span class="nb">usize</span><span class="p">,</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="nb">str</span><span class="p">)</span><span class="o">&gt;</span> <span class="o">+</span> <span class="nv">'a</span> <span class="p">{</span>
    <span class="nf">successors</span><span class="p">(</span><span class="nf">Some</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="n">node</span><span class="p">)),</span> <span class="p">|</span><span class="o">&amp;</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">node</span><span class="p">)|</span> <span class="p">{</span>
        <span class="n">map</span><span class="nf">.get</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
            <span class="nf">.map</span><span class="p">(|</span><span class="o">&amp;</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">)|</span> <span class="k">match</span> <span class="n">dirs</span><span class="p">[</span><span class="n">k</span> <span class="o">%</span> <span class="n">dirs</span><span class="nf">.len</span><span class="p">()]</span> <span class="p">{</span>
                <span class="sc">b'L'</span> <span class="k">=&gt;</span> <span class="p">(</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">left</span><span class="p">),</span>
                <span class="n">_</span> <span class="k">=&gt;</span> <span class="p">(</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">right</span><span class="p">),</span>
            <span class="p">})</span>
    <span class="p">})</span>
<span class="p">}</span>

<span class="k">pub</span> <span class="k">fn</span> <span class="nf">star_1</span><span class="p">(</span><span class="nf">PuzzleData</span><span class="p">(</span><span class="n">dirs</span><span class="p">,</span> <span class="n">map</span><span class="p">):</span> <span class="o">&amp;</span><span class="n">PuzzleData</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">SolT</span> <span class="p">{</span>
    <span class="nf">map_iter</span><span class="p">(</span><span class="n">dirs</span><span class="p">,</span> <span class="n">map</span><span class="p">,</span> <span class="s">"AAA"</span><span class="p">)</span>
        <span class="nf">.find</span><span class="p">(|</span><span class="o">&amp;</span><span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="n">node</span><span class="p">)|</span> <span class="n">node</span> <span class="o">==</span> <span class="s">"ZZZ"</span><span class="p">)</span>
        <span class="nf">.map</span><span class="p">(|(</span><span class="n">steps</span><span class="p">,</span> <span class="n">_</span><span class="p">)|</span> <span class="n">steps</span><span class="p">)</span>
        <span class="nf">.unwrap</span><span class="p">()</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_star_2_10">Star 2</h3>
<div class="paragraph">
<p>The solution is based on a periodicity assumption: Let <code>r</code> be the number of directions given in the puzzle input. Given any start node <code>A</code>, let <code>n_A</code> be the smallest number such that <code>n_A</code> is an integer multiple of <code>r</code> and a target node <code>Z</code> is reached after <code>n_A</code> steps. Then this situation will repeat exactly every <code>n_A</code> steps.</p>
</div>
<div class="paragraph">
<p>In that case, the solution is the least common multiple (LCM) of all <code>n_A</code> for any possible start node <code>A</code> (for my puzzle, it turned out that any <code>n_A</code> is a prime number multiplied by <code>r</code>, so the LCM calculation could be replaced by simpler multiplications).</p>
</div>
<div class="paragraph">
<p>The periodicity assumption is essentially a guess, it cannot be derived from the puzzle description. With the feature <code>check-periodicity</code> enabled, the code will verify it (at the cost of doubling the execution time for part 2).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
</pre></td><td class="code"><pre><span class="k">pub</span> <span class="k">fn</span> <span class="nf">star_2</span><span class="p">(</span><span class="nf">PuzzleData</span><span class="p">(</span><span class="n">dirs</span><span class="p">,</span> <span class="n">map</span><span class="p">):</span> <span class="o">&amp;</span><span class="n">PuzzleData</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">SolT</span> <span class="p">{</span>
    <span class="n">map</span><span class="nf">.keys</span><span class="p">()</span>
        <span class="nf">.filter</span><span class="p">(|</span><span class="n">key</span><span class="p">|</span> <span class="n">key</span><span class="nf">.ends_with</span><span class="p">(</span><span class="sc">'A'</span><span class="p">))</span>
        <span class="nf">.map</span><span class="p">(|</span><span class="o">&amp;</span><span class="n">node</span><span class="p">|</span> <span class="p">{</span>
            <span class="k">let</span> <span class="k">mut</span> <span class="n">it</span> <span class="o">=</span> <span class="nf">map_iter</span><span class="p">(</span><span class="n">dirs</span><span class="p">,</span> <span class="n">map</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span>
                <span class="nf">.step_by</span><span class="p">(</span><span class="n">dirs</span><span class="nf">.len</span><span class="p">())</span> <span class="c1">// only find result that used all dirs</span>
                <span class="nf">.filter</span><span class="p">(|(</span><span class="n">_</span><span class="p">,</span> <span class="n">node</span><span class="p">)|</span> <span class="n">node</span><span class="nf">.ends_with</span><span class="p">(</span><span class="sc">'Z'</span><span class="p">));</span>
            <span class="k">let</span> <span class="p">(</span><span class="n">steps_0</span><span class="p">,</span> <span class="n">node_0</span><span class="p">)</span> <span class="o">=</span> <span class="n">it</span><span class="nf">.next</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">();</span>
            <span class="k">if</span> <span class="nd">cfg!</span><span class="p">(</span><span class="n">feature</span> <span class="o">=</span> <span class="s">"check-periodicity"</span><span class="p">)</span> <span class="p">{</span>
                <span class="c1">// the solution assumes periodicity, so let's check it</span>
                <span class="k">let</span> <span class="p">(</span><span class="n">steps_1</span><span class="p">,</span> <span class="n">node_1</span><span class="p">)</span> <span class="o">=</span> <span class="n">it</span><span class="nf">.next</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">();</span>
                <span class="k">if</span> <span class="n">steps_1</span> <span class="o">!=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">steps_0</span> <span class="p">||</span> <span class="n">node_1</span> <span class="o">!=</span> <span class="n">node_0</span> <span class="p">{</span>
                    <span class="nd">panic!</span><span class="p">(</span><span class="s">"Periodicity assumption not satisfied!"</span><span class="p">);</span>
                <span class="p">}</span>
            <span class="p">}</span>
            <span class="n">steps_0</span>
        <span class="p">})</span>
        <span class="nf">.fold</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="p">|</span><span class="n">result</span><span class="p">,</span> <span class="n">steps</span><span class="p">|</span> <span class="n">result</span> <span class="o">*</span> <span class="n">steps</span> <span class="o">/</span> <span class="nf">gcd</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">steps</span><span class="p">))</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_tests_8">Tests</h3>
<div class="paragraph">
<p>The special "test" <code>test_understand</code> is used to get insight into to puzzle data and verify periodicity. It is supposed to run with the <code>--nocapture</code> option, because printing to <code>stdout</code> is really all it does.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
</pre></td><td class="code"><pre><span class="nd">#[cfg(test)]</span>
<span class="k">mod</span> <span class="n">tests</span> <span class="p">{</span>
    <span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">collections</span><span class="p">::</span><span class="n">HashMap</span><span class="p">;</span>

    <span class="k">use</span> <span class="k">super</span><span class="p">::</span><span class="o">*</span><span class="p">;</span>

    <span class="k">const</span> <span class="n">CONTENT</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span> <span class="o">=</span> <span class="s">r#"LLR

AAA = (BBB, BBB)
BBB = (AAA, ZZZ)
ZZZ = (ZZZ, ZZZ)
"#</span><span class="p">;</span>

    <span class="nd">#[test]</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">test_from</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">data</span> <span class="o">=</span> <span class="nn">PuzzleData</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="n">CONTENT</span><span class="p">);</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"{data:?}"</span><span class="p">);</span>
        <span class="nd">assert_eq!</span><span class="p">(</span>
            <span class="nf">PuzzleData</span><span class="p">(</span>
                <span class="s">"LLR"</span><span class="nf">.as_bytes</span><span class="p">(),</span>
                <span class="nn">HashMap</span><span class="p">::</span><span class="nf">from</span><span class="p">([</span>
                    <span class="p">(</span><span class="s">"AAA"</span><span class="p">,</span> <span class="p">(</span><span class="s">"BBB"</span><span class="p">,</span> <span class="s">"BBB"</span><span class="p">)),</span>
                    <span class="p">(</span><span class="s">"BBB"</span><span class="p">,</span> <span class="p">(</span><span class="s">"AAA"</span><span class="p">,</span> <span class="s">"ZZZ"</span><span class="p">)),</span>
                    <span class="p">(</span><span class="s">"ZZZ"</span><span class="p">,</span> <span class="p">(</span><span class="s">"ZZZ"</span><span class="p">,</span> <span class="s">"ZZZ"</span><span class="p">))</span>
                <span class="p">])</span>
            <span class="p">),</span>
            <span class="n">data</span>
        <span class="p">);</span>
    <span class="p">}</span>

    <span class="nd">#[test]</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">test_star_1</span><span class="p">()</span> <span class="p">{</span>
        <span class="nd">assert_eq!</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="nf">star_1</span><span class="p">(</span><span class="o">&amp;</span><span class="n">CONTENT</span><span class="nf">.into</span><span class="p">()));</span>
    <span class="p">}</span>

    <span class="k">const</span> <span class="n">CONTENT_2</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span> <span class="o">=</span> <span class="s">r#"LR

11A = (11B, XXX)
11B = (XXX, 11Z)
11Z = (11B, XXX)
22A = (22B, XXX)
22B = (22C, 22C)
22C = (22Z, 22Z)
22Z = (22B, 22B)
XXX = (XXX, XXX)
"#</span><span class="p">;</span>

    <span class="nd">#[test]</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">test_star_2</span><span class="p">()</span> <span class="p">{</span>
        <span class="nd">assert_eq!</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="nf">star_2</span><span class="p">(</span><span class="o">&amp;</span><span class="n">CONTENT_2</span><span class="nf">.into</span><span class="p">()));</span>
    <span class="p">}</span>

    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">do_understand</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">let</span> <span class="nf">PuzzleData</span><span class="p">(</span><span class="n">dirs</span><span class="p">,</span> <span class="n">map</span><span class="p">)</span> <span class="o">=</span> <span class="n">data</span><span class="nf">.into</span><span class="p">();</span>
        <span class="k">for</span> <span class="n">node</span> <span class="k">in</span> <span class="n">map</span>
            <span class="nf">.keys</span><span class="p">()</span>
            <span class="nf">.filter</span><span class="p">(|</span><span class="n">node</span><span class="p">|</span> <span class="n">node</span><span class="nf">.ends_with</span><span class="p">(</span><span class="sc">'A'</span><span class="p">))</span>
            <span class="nf">.map</span><span class="p">(|</span><span class="n">node</span><span class="p">|</span> <span class="o">*</span><span class="n">node</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="nd">println!</span><span class="p">(</span><span class="s">"Node {}"</span><span class="p">,</span> <span class="n">node</span><span class="p">);</span>
            <span class="k">let</span> <span class="k">mut</span> <span class="n">base</span> <span class="o">=</span> <span class="nb">None</span><span class="p">;</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span> <span class="k">in</span> <span class="nf">map_iter</span><span class="p">(</span><span class="n">dirs</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">map</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span>
                <span class="nf">.step_by</span><span class="p">(</span><span class="n">dirs</span><span class="nf">.len</span><span class="p">())</span>
                <span class="nf">.filter</span><span class="p">(|</span><span class="o">&amp;</span><span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="n">x</span><span class="p">)|</span> <span class="n">x</span><span class="nf">.ends_with</span><span class="p">(</span><span class="sc">'Z'</span><span class="p">))</span>
                <span class="nf">.take</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="k">let</span> <span class="n">base</span> <span class="o">=</span> <span class="o">*</span><span class="n">base</span><span class="nf">.get_or_insert</span><span class="p">(</span><span class="n">pos</span><span class="p">);</span>
                <span class="nd">println!</span><span class="p">(</span>
                    <span class="s">"    reached {} at step {} = {} * {} + {} = {} * {} + {}"</span><span class="p">,</span>
                    <span class="n">node</span><span class="p">,</span>
                    <span class="n">pos</span><span class="p">,</span>
                    <span class="n">pos</span> <span class="o">/</span> <span class="n">base</span><span class="p">,</span>
                    <span class="n">base</span><span class="p">,</span>
                    <span class="n">pos</span> <span class="o">%</span> <span class="n">base</span><span class="p">,</span>
                    <span class="n">pos</span> <span class="o">/</span> <span class="n">dirs</span><span class="nf">.len</span><span class="p">(),</span>
                    <span class="n">dirs</span><span class="nf">.len</span><span class="p">(),</span>
                    <span class="n">pos</span> <span class="o">%</span> <span class="n">dirs</span><span class="nf">.len</span><span class="p">()</span>
                <span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="nd">#[test]</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">test_understand</span><span class="p">()</span> <span class="p">{</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">Sample data 2"</span><span class="p">);</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"============="</span><span class="p">);</span>
        <span class="nf">do_understand</span><span class="p">(</span><span class="n">CONTENT_2</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>

        <span class="nd">println!</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">Puzzle input"</span><span class="p">);</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"============"</span><span class="p">);</span>
        <span class="nf">do_understand</span><span class="p">(</span><span class="o">&amp;</span><span class="nf">read_input</span><span class="p">(),</span> <span class="mi">2</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p><a href="#top">Top</a></p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="sol-rust-9">Rust | Day 9: Mirage Maintenance</h2>
<div class="sectionbody">
<div class="paragraph">
<p><a href="https://rust-lang.org">Rust</a> solution to <a href="https://adventofcode.com/2023/day/9">AoC|2023|9</a>.</p>
</div>
<div class="sect2">
<h3 id="_input_8">Input</h3>
<div class="paragraph">
<p>Lines of lists into <code>Vec&lt;Vec&lt;&#8230;&#8203;&gt;&gt;</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
</pre></td><td class="code"><pre><span class="k">pub</span> <span class="k">mod</span> <span class="n">input</span> <span class="p">{</span>
    <span class="k">use</span> <span class="k">crate</span><span class="p">::</span><span class="n">SolT</span><span class="p">;</span>

    <span class="nd">#[derive(Debug,</span> <span class="nd">PartialEq,</span> <span class="nd">Eq)]</span>
    <span class="k">pub</span> <span class="k">struct</span> <span class="nf">PuzzleData</span><span class="p">(</span><span class="k">pub</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="n">SolT</span><span class="o">&gt;&gt;</span><span class="p">);</span>

    <span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="nb">From</span><span class="o">&lt;&amp;</span><span class="n">T</span><span class="o">&gt;</span> <span class="k">for</span> <span class="n">PuzzleData</span>
    <span class="k">where</span>
        <span class="n">T</span><span class="p">:</span> <span class="nb">AsRef</span><span class="o">&lt;</span><span class="nb">str</span><span class="o">&gt;</span> <span class="o">+</span> <span class="o">?</span><span class="nb">Sized</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="k">fn</span> <span class="nf">from</span><span class="p">(</span><span class="n">s</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">T</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
            <span class="k">Self</span><span class="p">(</span>
                <span class="n">s</span><span class="nf">.as_ref</span><span class="p">()</span>
                    <span class="nf">.lines</span><span class="p">()</span>
                    <span class="nf">.map</span><span class="p">(|</span><span class="n">line</span><span class="p">|</span> <span class="p">{</span>
                        <span class="n">line</span><span class="nf">.split_ascii_whitespace</span><span class="p">()</span>
                            <span class="nf">.map</span><span class="p">(</span><span class="nn">str</span><span class="p">::</span><span class="n">parse</span><span class="p">)</span>
                            <span class="py">.collect</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">Result</span><span class="o">&lt;</span><span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="o">&gt;&gt;</span><span class="p">()</span>
                    <span class="p">})</span>
                    <span class="py">.collect</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">Result</span><span class="o">&lt;</span><span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="o">&gt;&gt;</span><span class="p">()</span>
                    <span class="nf">.unwrap</span><span class="p">(),</span>
            <span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_star_1_11">Star 1</h3>
<div class="paragraph">
<p>I wanted to avoid to allocate a new vector in every iteration step, so I do the processing in place. This results in a <code>successors</code> iterator with side effects on the mutable <code>values</code> vector. Maybe a while loop would be cleaner in that case, but I had to give in to my iterator fetish.</p>
</div>
<div class="paragraph">
<p>The tail values of all iterations equally contribute to the prediction in a simple sum.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
</pre></td><td class="code"><pre><span class="k">pub</span> <span class="k">fn</span> <span class="n">extrapolate_back</span><span class="o">&lt;</span><span class="n">T</span><span class="p">:</span> <span class="nb">AsRef</span><span class="o">&lt;</span><span class="p">[</span><span class="n">SolT</span><span class="p">]</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">values</span><span class="p">:</span> <span class="n">T</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">SolT</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">values</span> <span class="o">=</span> <span class="n">values</span><span class="nf">.as_ref</span><span class="p">()</span><span class="nf">.to_owned</span><span class="p">();</span>
    <span class="nf">successors</span><span class="p">(</span><span class="nf">Some</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="n">values</span><span class="nf">.len</span><span class="p">())),</span> <span class="p">|</span><span class="o">&amp;</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">len</span><span class="p">)|</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="mi">0</span><span class="o">..</span><span class="n">len</span><span class="p">)</span><span class="nf">.all</span><span class="p">(|</span><span class="n">k</span><span class="p">|</span> <span class="n">values</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="nb">None</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">tail</span> <span class="o">=</span> <span class="n">values</span><span class="p">[</span><span class="n">len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
            <span class="k">for</span> <span class="n">k</span> <span class="k">in</span> <span class="mi">0</span><span class="o">..</span><span class="n">len</span> <span class="o">-</span> <span class="mi">1</span> <span class="p">{</span>
                <span class="n">values</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">values</span><span class="p">[</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">values</span><span class="p">[</span><span class="n">k</span><span class="p">];</span>
            <span class="p">}</span>
            <span class="nf">Some</span><span class="p">((</span><span class="n">result</span> <span class="o">+</span> <span class="n">tail</span><span class="p">,</span> <span class="n">len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
        <span class="p">}</span>
    <span class="p">})</span>
    <span class="nf">.last</span><span class="p">()</span>
    <span class="nf">.map</span><span class="p">(|(</span><span class="n">result</span><span class="p">,</span> <span class="n">_</span><span class="p">)|</span> <span class="n">result</span><span class="p">)</span>
    <span class="nf">.unwrap_or</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">pub</span> <span class="k">fn</span> <span class="nf">star_1</span><span class="p">(</span><span class="nf">PuzzleData</span><span class="p">(</span><span class="n">values</span><span class="p">):</span> <span class="o">&amp;</span><span class="n">PuzzleData</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">SolT</span> <span class="p">{</span>
    <span class="n">values</span><span class="nf">.iter</span><span class="p">()</span><span class="nf">.map</span><span class="p">(</span><span class="n">extrapolate_back</span><span class="p">)</span><span class="nf">.sum</span><span class="p">()</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_star_2_11">Star 2</h3>
<div class="paragraph">
<p>I was expecting much more complicated. It took a short moment to get the signs right, but essentially, just a duplication of part 1.</p>
</div>
<div class="paragraph">
<p>The head values of all iterations contribute to the prediction through an alternating sum. The head of the original data contributes positively.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
</pre></td><td class="code"><pre><span class="k">pub</span> <span class="k">fn</span> <span class="n">extrapolate_front</span><span class="o">&lt;</span><span class="n">T</span><span class="p">:</span> <span class="nb">AsRef</span><span class="o">&lt;</span><span class="p">[</span><span class="n">SolT</span><span class="p">]</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">values</span><span class="p">:</span> <span class="n">T</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">SolT</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">values</span> <span class="o">=</span> <span class="n">values</span><span class="nf">.as_ref</span><span class="p">()</span><span class="nf">.to_owned</span><span class="p">();</span>
    <span class="nf">successors</span><span class="p">(</span><span class="nf">Some</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">values</span><span class="nf">.len</span><span class="p">())),</span> <span class="p">|</span><span class="o">&amp;</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">sign</span><span class="p">,</span> <span class="n">len</span><span class="p">)|</span> <span class="p">{</span>
        <span class="k">if</span> <span class="n">len</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">||</span> <span class="p">(</span><span class="mi">0</span><span class="o">..</span><span class="n">len</span><span class="p">)</span><span class="nf">.all</span><span class="p">(|</span><span class="n">k</span><span class="p">|</span> <span class="n">values</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="nb">None</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">head</span> <span class="o">=</span> <span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
            <span class="k">for</span> <span class="n">k</span> <span class="k">in</span> <span class="mi">0</span><span class="o">..</span><span class="n">len</span> <span class="o">-</span> <span class="mi">1</span> <span class="p">{</span>
                <span class="n">values</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">values</span><span class="p">[</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">values</span><span class="p">[</span><span class="n">k</span><span class="p">];</span>
            <span class="p">}</span>
            <span class="nf">Some</span><span class="p">((</span><span class="n">result</span> <span class="o">+</span> <span class="n">sign</span> <span class="o">*</span> <span class="n">head</span><span class="p">,</span> <span class="o">-</span><span class="n">sign</span><span class="p">,</span> <span class="n">len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
        <span class="p">}</span>
    <span class="p">})</span>
    <span class="nf">.last</span><span class="p">()</span>
    <span class="nf">.map</span><span class="p">(|(</span><span class="n">result</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">)|</span> <span class="n">result</span><span class="p">)</span>
    <span class="nf">.unwrap_or</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">pub</span> <span class="k">fn</span> <span class="nf">star_2</span><span class="p">(</span><span class="nf">PuzzleData</span><span class="p">(</span><span class="n">values</span><span class="p">):</span> <span class="o">&amp;</span><span class="n">PuzzleData</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">SolT</span> <span class="p">{</span>
    <span class="n">values</span><span class="nf">.iter</span><span class="p">()</span><span class="nf">.map</span><span class="p">(</span><span class="n">extrapolate_front</span><span class="p">)</span><span class="nf">.sum</span><span class="p">()</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_tests_9">Tests</h3>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
</pre></td><td class="code"><pre><span class="nd">#[cfg(test)]</span>
<span class="k">mod</span> <span class="n">tests</span> <span class="p">{</span>
    <span class="k">use</span> <span class="k">super</span><span class="p">::</span><span class="o">*</span><span class="p">;</span>

    <span class="k">const</span> <span class="n">CONTENT</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span> <span class="o">=</span> <span class="s">r#"0 3 6 9 12 15
1 3 6 10 15 21
10 13 16 21 30 45
"#</span><span class="p">;</span>

    <span class="nd">#[test]</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">test_from</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">data</span> <span class="o">=</span> <span class="nn">PuzzleData</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="n">CONTENT</span><span class="p">);</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"{data:?}"</span><span class="p">);</span>
        <span class="nd">assert_eq!</span><span class="p">(</span>
            <span class="nf">PuzzleData</span><span class="p">(</span><span class="nd">vec!</span><span class="p">[</span>
                <span class="nd">vec!</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">15</span><span class="p">],</span>
                <span class="nd">vec!</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">21</span><span class="p">],</span>
                <span class="nd">vec!</span><span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">13</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">21</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">45</span><span class="p">]</span>
            <span class="p">]),</span>
            <span class="n">data</span>
        <span class="p">);</span>
    <span class="p">}</span>

    <span class="nd">#[test]</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">test_star_1</span><span class="p">()</span> <span class="p">{</span>
        <span class="nd">assert_eq!</span><span class="p">(</span><span class="mi">114</span><span class="p">,</span> <span class="nf">star_1</span><span class="p">(</span><span class="o">&amp;</span><span class="n">CONTENT</span><span class="nf">.into</span><span class="p">()));</span>
    <span class="p">}</span>

    <span class="nd">#[test]</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">test_extrapolate_front</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">front</span> <span class="o">=</span> <span class="nf">extrapolate_front</span><span class="p">([</span><span class="mi">10</span><span class="p">,</span> <span class="mi">13</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">21</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">45</span><span class="p">]);</span>
        <span class="nd">assert_eq!</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="n">front</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="nd">#[test]</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">test_star_2</span><span class="p">()</span> <span class="p">{</span>
        <span class="nd">assert_eq!</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="nf">star_2</span><span class="p">(</span><span class="o">&amp;</span><span class="n">CONTENT</span><span class="nf">.into</span><span class="p">()));</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p><a href="#top">Top</a></p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="sol-rust-10">Rust | Day 10: Pipe Maze</h2>
<div class="sectionbody">
<div class="paragraph">
<p><a href="https://rust-lang.org">Rust</a> solution to <a href="https://adventofcode.com/2023/day/10">AoC|2023|10</a>.</p>
</div>
<div class="paragraph">
<p>I was a little bit scared when one of the first words I read in the description was "maze"&#8230;&#8203;</p>
</div>
<div class="sect2">
<h3 id="_input_9">Input</h3>
<div class="paragraph">
<p>I use my utility <code>Grid</code> implementation. A layer of '.' is added around the original grid to avoid special treatment of elements on the boundary.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
</pre></td><td class="code"><pre><span class="k">pub</span> <span class="k">mod</span> <span class="n">input</span> <span class="p">{</span>
    <span class="k">use</span> <span class="nn">mr_kaffee_utils</span><span class="p">::</span><span class="nn">grids</span><span class="p">::{</span><span class="n">Grid</span><span class="p">,</span> <span class="n">MakeGrid</span><span class="p">};</span>

    <span class="nd">#[derive(Debug)]</span>
    <span class="k">pub</span> <span class="k">struct</span> <span class="nf">PuzzleData</span><span class="p">(</span><span class="k">pub</span> <span class="n">Grid</span><span class="p">);</span>

    <span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="nb">From</span><span class="o">&lt;&amp;</span><span class="n">T</span><span class="o">&gt;</span> <span class="k">for</span> <span class="n">PuzzleData</span>
    <span class="k">where</span>
        <span class="n">T</span><span class="p">:</span> <span class="nb">AsRef</span><span class="o">&lt;</span><span class="p">[</span><span class="nb">u8</span><span class="p">]</span><span class="o">&gt;</span> <span class="o">+</span> <span class="o">?</span><span class="nb">Sized</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="k">fn</span> <span class="nf">from</span><span class="p">(</span><span class="n">s</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">T</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
            <span class="k">Self</span><span class="p">(</span><span class="n">s</span><span class="nf">.make_grid</span><span class="p">(</span><span class="nf">Some</span><span class="p">(</span><span class="sc">b'.'</span><span class="p">)))</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_star_1_12">Star 1</h3>
<div class="paragraph">
<p>Walk the loop (since we need to walk the entire loop, there is no advantage in doing a BFS), the max distance is half of the loop length (which is always even). The information which position belongs to the loop is stored in a vector of booleans.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
</pre></td><td class="code"><pre><span class="k">fn</span> <span class="nf">deduce_pipe</span><span class="p">(</span><span class="n">grid</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Grid</span><span class="p">,</span> <span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="n">row</span><span class="p">):</span> <span class="p">(</span><span class="nb">usize</span><span class="p">,</span> <span class="nb">usize</span><span class="p">))</span> <span class="k">-&gt;</span> <span class="nb">u8</span> <span class="p">{</span>
    <span class="k">const</span> <span class="n">TO_EAST</span><span class="p">:</span> <span class="p">[</span><span class="nb">u8</span><span class="p">;</span> <span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="sc">b'-'</span><span class="p">,</span> <span class="sc">b'J'</span><span class="p">,</span> <span class="sc">b'7'</span><span class="p">];</span>
    <span class="k">const</span> <span class="n">TO_NORTH</span><span class="p">:</span> <span class="p">[</span><span class="nb">u8</span><span class="p">;</span> <span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="sc">b'|'</span><span class="p">,</span> <span class="sc">b'F'</span><span class="p">,</span> <span class="sc">b'7'</span><span class="p">];</span>
    <span class="k">const</span> <span class="n">TO_WEST</span><span class="p">:</span> <span class="p">[</span><span class="nb">u8</span><span class="p">;</span> <span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="sc">b'-'</span><span class="p">,</span> <span class="sc">b'F'</span><span class="p">,</span> <span class="sc">b'L'</span><span class="p">];</span>
    <span class="k">const</span> <span class="n">TO_SOUTH</span><span class="p">:</span> <span class="p">[</span><span class="nb">u8</span><span class="p">;</span> <span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="sc">b'|'</span><span class="p">,</span> <span class="sc">b'L'</span><span class="p">,</span> <span class="sc">b'J'</span><span class="p">];</span>

    <span class="k">match</span> <span class="p">(</span>
        <span class="n">TO_EAST</span><span class="nf">.contains</span><span class="p">(</span><span class="o">&amp;</span><span class="n">grid</span><span class="p">[(</span><span class="n">col</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">row</span><span class="p">)]),</span>
        <span class="n">TO_NORTH</span><span class="nf">.contains</span><span class="p">(</span><span class="o">&amp;</span><span class="n">grid</span><span class="p">[(</span><span class="n">col</span><span class="p">,</span> <span class="n">row</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)]),</span>
        <span class="n">TO_WEST</span><span class="nf">.contains</span><span class="p">(</span><span class="o">&amp;</span><span class="n">grid</span><span class="p">[(</span><span class="n">col</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">row</span><span class="p">)]),</span>
        <span class="n">TO_SOUTH</span><span class="nf">.contains</span><span class="p">(</span><span class="o">&amp;</span><span class="n">grid</span><span class="p">[(</span><span class="n">col</span><span class="p">,</span> <span class="n">row</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]),</span>
    <span class="p">)</span> <span class="p">{</span>
        <span class="p">(</span><span class="k">true</span><span class="p">,</span> <span class="k">true</span><span class="p">,</span> <span class="k">false</span><span class="p">,</span> <span class="k">false</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="sc">b'L'</span><span class="p">,</span>
        <span class="p">(</span><span class="k">true</span><span class="p">,</span> <span class="k">false</span><span class="p">,</span> <span class="k">true</span><span class="p">,</span> <span class="k">false</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="sc">b'-'</span><span class="p">,</span>
        <span class="p">(</span><span class="k">true</span><span class="p">,</span> <span class="k">false</span><span class="p">,</span> <span class="k">false</span><span class="p">,</span> <span class="k">true</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="sc">b'F'</span><span class="p">,</span>
        <span class="p">(</span><span class="k">false</span><span class="p">,</span> <span class="k">true</span><span class="p">,</span> <span class="k">true</span><span class="p">,</span> <span class="k">false</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="sc">b'J'</span><span class="p">,</span>
        <span class="p">(</span><span class="k">false</span><span class="p">,</span> <span class="k">true</span><span class="p">,</span> <span class="k">false</span><span class="p">,</span> <span class="k">true</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="sc">b'|'</span><span class="p">,</span>
        <span class="p">(</span><span class="k">false</span><span class="p">,</span> <span class="k">false</span><span class="p">,</span> <span class="k">true</span><span class="p">,</span> <span class="k">true</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="sc">b'7'</span><span class="p">,</span>
        <span class="n">_</span> <span class="k">=&gt;</span> <span class="nd">panic!</span><span class="p">(),</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">pub</span> <span class="k">fn</span> <span class="nf">find_loop</span><span class="p">(</span><span class="n">grid</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Grid</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="p">(</span><span class="n">SolT</span><span class="p">,</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">bool</span><span class="o">&gt;</span><span class="p">,</span> <span class="nb">u8</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">start</span> <span class="o">=</span> <span class="n">grid</span><span class="nf">.data</span><span class="p">()</span><span class="nf">.iter</span><span class="p">()</span><span class="nf">.position</span><span class="p">(|</span><span class="o">&amp;</span><span class="n">b</span><span class="p">|</span> <span class="n">b</span> <span class="o">==</span> <span class="sc">b'S'</span><span class="p">)</span><span class="nf">.unwrap</span><span class="p">();</span>
    <span class="k">let</span> <span class="n">start_pipe</span> <span class="o">=</span> <span class="nf">deduce_pipe</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">grid</span><span class="nf">.to_col_row</span><span class="p">(</span><span class="n">start</span><span class="p">));</span>

    <span class="k">let</span> <span class="p">(</span><span class="n">len</span><span class="p">,</span> <span class="n">pipe_loop</span><span class="p">)</span> <span class="o">=</span> <span class="nf">successors</span><span class="p">(</span><span class="nf">Some</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="n">start</span><span class="p">)),</span> <span class="p">|</span><span class="o">&amp;</span><span class="p">(</span><span class="n">prev_idx</span><span class="p">,</span> <span class="n">cur_idx</span><span class="p">)|</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">cur</span> <span class="o">=</span> <span class="k">match</span> <span class="n">grid</span><span class="p">[</span><span class="n">cur_idx</span><span class="p">]</span> <span class="p">{</span>
            <span class="sc">b'S'</span> <span class="k">=&gt;</span> <span class="n">start_pipe</span><span class="p">,</span>
            <span class="n">b</span> <span class="k">=&gt;</span> <span class="n">b</span><span class="p">,</span>
        <span class="p">};</span>

        <span class="k">let</span> <span class="p">(</span><span class="n">idx_a</span><span class="p">,</span> <span class="n">idx_b</span><span class="p">)</span> <span class="o">=</span> <span class="k">match</span> <span class="n">cur</span> <span class="p">{</span>
            <span class="sc">b'-'</span> <span class="k">=&gt;</span> <span class="p">(</span><span class="n">cur_idx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">cur_idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span>
            <span class="sc">b'|'</span> <span class="k">=&gt;</span> <span class="p">(</span><span class="n">cur_idx</span> <span class="o">-</span> <span class="n">grid</span><span class="nf">.width</span><span class="p">(),</span> <span class="n">cur_idx</span> <span class="o">+</span> <span class="n">grid</span><span class="nf">.width</span><span class="p">()),</span>
            <span class="sc">b'J'</span> <span class="k">=&gt;</span> <span class="p">(</span><span class="n">cur_idx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">cur_idx</span> <span class="o">-</span> <span class="n">grid</span><span class="nf">.width</span><span class="p">()),</span>
            <span class="sc">b'7'</span> <span class="k">=&gt;</span> <span class="p">(</span><span class="n">cur_idx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">cur_idx</span> <span class="o">+</span> <span class="n">grid</span><span class="nf">.width</span><span class="p">()),</span>
            <span class="sc">b'F'</span> <span class="k">=&gt;</span> <span class="p">(</span><span class="n">cur_idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">cur_idx</span> <span class="o">+</span> <span class="n">grid</span><span class="nf">.width</span><span class="p">()),</span>
            <span class="sc">b'L'</span> <span class="k">=&gt;</span> <span class="p">(</span><span class="n">cur_idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">cur_idx</span> <span class="o">-</span> <span class="n">grid</span><span class="nf">.width</span><span class="p">()),</span>
            <span class="n">_</span> <span class="k">=&gt;</span> <span class="nd">panic!</span><span class="p">(),</span>
        <span class="p">};</span>

        <span class="k">if</span> <span class="n">prev_idx</span> <span class="o">!=</span> <span class="n">idx_a</span> <span class="o">&amp;&amp;</span> <span class="n">start</span> <span class="o">!=</span> <span class="n">idx_a</span> <span class="p">{</span>
            <span class="nf">Some</span><span class="p">((</span><span class="n">cur_idx</span><span class="p">,</span> <span class="n">idx_a</span><span class="p">))</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="n">prev_idx</span> <span class="o">!=</span> <span class="n">idx_b</span> <span class="o">&amp;&amp;</span> <span class="n">start</span> <span class="o">!=</span> <span class="n">idx_b</span> <span class="p">{</span>
            <span class="nf">Some</span><span class="p">((</span><span class="n">cur_idx</span><span class="p">,</span> <span class="n">idx_b</span><span class="p">))</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="nb">None</span>
        <span class="p">}</span>
    <span class="p">})</span>
    <span class="nf">.fold</span><span class="p">(</span>
        <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nd">vec!</span><span class="p">[</span><span class="kc">false</span><span class="p">;</span> <span class="n">grid</span><span class="nf">.len</span><span class="p">()]),</span>
        <span class="p">|(</span><span class="n">len</span><span class="p">,</span> <span class="k">mut</span> <span class="n">pipe_loop</span><span class="p">),</span> <span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="n">idx</span><span class="p">)|</span> <span class="p">{</span>
            <span class="n">pipe_loop</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="k">true</span><span class="p">;</span>
            <span class="p">(</span><span class="n">len</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">pipe_loop</span><span class="p">)</span>
        <span class="p">},</span>
    <span class="p">);</span>

    <span class="p">(</span><span class="n">len</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">,</span> <span class="n">pipe_loop</span><span class="p">,</span> <span class="n">start_pipe</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">pub</span> <span class="k">fn</span> <span class="nf">star_1</span><span class="p">(</span><span class="nf">PuzzleData</span><span class="p">(</span><span class="n">grid</span><span class="p">):</span> <span class="o">&amp;</span><span class="n">PuzzleData</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">SolT</span> <span class="p">{</span>
    <span class="k">let</span> <span class="p">(</span><span class="n">mx</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">)</span> <span class="o">=</span> <span class="nf">find_loop</span><span class="p">(</span><span class="n">grid</span><span class="p">);</span>
    <span class="n">mx</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_star_2_12">Star 2</h3>
<div class="paragraph">
<p>The easy part was to figure out that a point is inside the loop if going from that point outwards, we cross the loop an odd number of times.</p>
</div>
<div class="paragraph">
<p>The tricky part was how to figure out the number of crossings. I decided to always go east. To count the number of crossings, we are only interested in the points that are contained in the pipe, and we can ignore <code>-</code> elements to which we are strictly tangent. Doing so, we just need the current and the previous element to decide whether we crossed the loop. This is the case exactly if the current element is '|' or when the previous and current element are 'L', '7' or 'F', 'J'.</p>
</div>
<div class="paragraph">
<p>My initial solution checked point by point, adding quite a bit of overhead (the solution is still available by setting feature <code>point-by-point</code>). It is a quite easy modification to count the points inside the loop line by line.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
</pre></td><td class="code"><pre><span class="nd">#[cfg(feature</span> <span class="nd">=</span> <span class="s">"point-by-point"</span><span class="nd">)]</span>
<span class="k">pub</span> <span class="k">fn</span> <span class="nf">star_2</span><span class="p">(</span><span class="nf">PuzzleData</span><span class="p">(</span><span class="n">grid</span><span class="p">):</span> <span class="o">&amp;</span><span class="n">PuzzleData</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">SolT</span> <span class="p">{</span>
    <span class="k">let</span> <span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="n">pipe_loop</span><span class="p">,</span> <span class="n">start_pipe</span><span class="p">)</span> <span class="o">=</span> <span class="nf">find_loop</span><span class="p">(</span><span class="n">grid</span><span class="p">);</span>

    <span class="p">(</span><span class="mi">0</span><span class="o">..</span><span class="n">grid</span><span class="nf">.len</span><span class="p">())</span>
        <span class="nf">.map</span><span class="p">(|</span><span class="n">pos</span><span class="p">|</span> <span class="n">grid</span><span class="nf">.to_col_row</span><span class="p">(</span><span class="n">pos</span><span class="p">))</span>
        <span class="nf">.filter</span><span class="p">(|</span><span class="o">&amp;</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="n">row</span><span class="p">)|</span> <span class="o">!</span><span class="n">pipe_loop</span><span class="p">[</span><span class="n">col</span> <span class="o">+</span> <span class="n">grid</span><span class="nf">.width</span><span class="p">()</span> <span class="o">*</span> <span class="n">row</span><span class="p">])</span>
        <span class="nf">.filter</span><span class="p">(|</span><span class="o">&amp;</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="n">row</span><span class="p">)|</span> <span class="p">{</span>
            <span class="c1">// count crossings of pipe</span>
            <span class="k">let</span> <span class="p">(</span><span class="n">cnt</span><span class="p">,</span> <span class="n">_</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="n">col</span> <span class="o">+</span> <span class="mi">1</span><span class="o">..</span><span class="n">grid</span><span class="nf">.width</span><span class="p">())</span>
                <span class="c1">// skip elements not part of pipe</span>
                <span class="nf">.filter</span><span class="p">(|</span><span class="o">&amp;</span><span class="n">col</span><span class="p">|</span> <span class="n">pipe_loop</span><span class="p">[</span><span class="n">col</span> <span class="o">+</span> <span class="n">grid</span><span class="nf">.width</span><span class="p">()</span> <span class="o">*</span> <span class="n">row</span><span class="p">])</span>
                <span class="c1">// map to elements (substituting 'S')</span>
                <span class="nf">.map</span><span class="p">(|</span><span class="n">col</span><span class="p">|</span> <span class="k">match</span> <span class="n">grid</span><span class="p">[(</span><span class="n">col</span><span class="p">,</span> <span class="n">row</span><span class="p">)]</span> <span class="p">{</span>
                    <span class="sc">b'S'</span> <span class="k">=&gt;</span> <span class="n">start_pipe</span><span class="p">,</span>
                    <span class="n">b</span> <span class="k">=&gt;</span> <span class="n">b</span><span class="p">,</span>
                <span class="p">})</span>
                <span class="c1">// skip purely tangent elements</span>
                <span class="nf">.filter</span><span class="p">(|</span><span class="o">&amp;</span><span class="n">b</span><span class="p">|</span> <span class="n">b</span> <span class="o">!=</span> <span class="sc">b'-'</span><span class="p">)</span>
                <span class="c1">// count crossings</span>
                <span class="nf">.fold</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="sc">b'.'</span><span class="p">),</span> <span class="p">|(</span><span class="n">cnt</span><span class="p">,</span> <span class="n">prev</span><span class="p">),</span> <span class="n">cur</span><span class="p">|</span> <span class="k">match</span> <span class="p">(</span><span class="n">prev</span><span class="p">,</span> <span class="n">cur</span><span class="p">)</span> <span class="p">{</span>
                    <span class="c1">// "|", "L7", and "FJ" are crossings</span>
                    <span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="sc">b'|'</span><span class="p">)</span> <span class="p">|</span> <span class="p">(</span><span class="sc">b'L'</span><span class="p">,</span> <span class="sc">b'7'</span><span class="p">)</span> <span class="p">|</span> <span class="p">(</span><span class="sc">b'F'</span><span class="p">,</span> <span class="sc">b'J'</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">(</span><span class="n">cnt</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">cur</span><span class="p">),</span>
                    <span class="n">_</span> <span class="k">=&gt;</span> <span class="p">(</span><span class="n">cnt</span><span class="p">,</span> <span class="n">cur</span><span class="p">),</span> <span class="c1">// anything else ("LJ", "F7", ...) is not a crossing</span>
                <span class="p">});</span>
            <span class="c1">// odd crossing count is inside</span>
            <span class="n">cnt</span> <span class="o">&amp;</span> <span class="mi">1</span> <span class="o">==</span> <span class="mi">1</span>
        <span class="p">})</span>
        <span class="nf">.count</span><span class="p">()</span>
<span class="p">}</span>

<span class="nd">#[cfg(not(feature</span> <span class="nd">=</span> <span class="s">"point-by-point"</span><span class="nd">))]</span>
<span class="k">pub</span> <span class="k">fn</span> <span class="nf">star_2</span><span class="p">(</span><span class="nf">PuzzleData</span><span class="p">(</span><span class="n">grid</span><span class="p">):</span> <span class="o">&amp;</span><span class="n">PuzzleData</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">SolT</span> <span class="p">{</span>
    <span class="k">let</span> <span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="n">pipe_loop</span><span class="p">,</span> <span class="n">start_pipe</span><span class="p">)</span> <span class="o">=</span> <span class="nf">find_loop</span><span class="p">(</span><span class="n">grid</span><span class="p">);</span>

    <span class="p">(</span><span class="mi">0</span><span class="o">..</span><span class="n">grid</span><span class="nf">.height</span><span class="p">())</span>
        <span class="nf">.map</span><span class="p">(|</span><span class="n">row</span><span class="p">|</span> <span class="p">{</span>
            <span class="k">let</span> <span class="p">(</span><span class="n">cnt</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="o">..</span><span class="n">grid</span><span class="nf">.width</span><span class="p">())</span>
                <span class="nf">.map</span><span class="p">(</span>
                    <span class="p">|</span><span class="n">col</span><span class="p">|</span> <span class="k">match</span> <span class="p">(</span><span class="n">pipe_loop</span><span class="p">[</span><span class="n">col</span> <span class="o">+</span> <span class="n">grid</span><span class="nf">.width</span><span class="p">()</span> <span class="o">*</span> <span class="n">row</span><span class="p">],</span> <span class="n">grid</span><span class="p">[(</span><span class="n">col</span><span class="p">,</span> <span class="n">row</span><span class="p">)])</span> <span class="p">{</span>
                        <span class="p">(</span><span class="k">true</span><span class="p">,</span> <span class="sc">b'S'</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="n">start_pipe</span><span class="p">,</span>
                        <span class="p">(</span><span class="k">true</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="n">b</span><span class="p">,</span>
                        <span class="n">_</span> <span class="k">=&gt;</span> <span class="sc">b'.'</span><span class="p">,</span>
                    <span class="p">},</span>
                <span class="p">)</span>
                <span class="nf">.filter</span><span class="p">(|</span><span class="o">&amp;</span><span class="n">b</span><span class="p">|</span> <span class="n">b</span> <span class="o">!=</span> <span class="sc">b'-'</span><span class="p">)</span>
                <span class="nf">.fold</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="sc">b'.'</span><span class="p">,</span> <span class="k">false</span><span class="p">),</span> <span class="p">|(</span><span class="n">cnt</span><span class="p">,</span> <span class="n">prev</span><span class="p">,</span> <span class="n">inside</span><span class="p">),</span> <span class="n">cur</span><span class="p">|</span> <span class="p">{</span>
                    <span class="k">match</span> <span class="p">(</span><span class="n">inside</span><span class="p">,</span> <span class="n">prev</span><span class="p">,</span> <span class="n">cur</span><span class="p">)</span> <span class="p">{</span>
                        <span class="p">(</span><span class="k">true</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="sc">b'.'</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">(</span><span class="n">cnt</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">cur</span><span class="p">,</span> <span class="k">true</span><span class="p">),</span>
                        <span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="sc">b'|'</span><span class="p">)</span> <span class="p">|</span> <span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="sc">b'F'</span><span class="p">,</span> <span class="sc">b'J'</span><span class="p">)</span> <span class="p">|</span> <span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="sc">b'L'</span><span class="p">,</span> <span class="sc">b'7'</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">(</span><span class="n">cnt</span><span class="p">,</span> <span class="n">cur</span><span class="p">,</span> <span class="o">!</span><span class="n">inside</span><span class="p">),</span>
                        <span class="n">_</span> <span class="k">=&gt;</span> <span class="p">(</span><span class="n">cnt</span><span class="p">,</span> <span class="n">cur</span><span class="p">,</span> <span class="n">inside</span><span class="p">),</span>
                    <span class="p">}</span>
                <span class="p">});</span>
            <span class="n">cnt</span>
        <span class="p">})</span>
        <span class="nf">.sum</span><span class="p">()</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_tests_10">Tests</h3>
<div class="paragraph">
<p>I needed a few test inputs for the second part until I got all the edge cases right. The last missing step, which did actually not fail any of my tests, was to replace 'S' with the pipe type hidden below.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
</pre></td><td class="code"><pre><span class="nd">#[cfg(test)]</span>
<span class="k">mod</span> <span class="n">tests</span> <span class="p">{</span>
    <span class="k">use</span> <span class="k">super</span><span class="p">::</span><span class="o">*</span><span class="p">;</span>

    <span class="k">const</span> <span class="n">CONTENT</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span> <span class="o">=</span> <span class="s">r#"7-F7-
.FJ|7
SJLL7
|F--J
LJ.LJ
"#</span><span class="p">;</span>
    <span class="k">const</span> <span class="n">EXP_STAR_1</span><span class="p">:</span> <span class="n">SolT</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span>

    <span class="nd">#[test]</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">test_from</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">data</span> <span class="o">=</span> <span class="nn">PuzzleData</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="n">CONTENT</span><span class="p">);</span>
        <span class="nd">assert_eq!</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="n">data</span><span class="na">.0</span><span class="nf">.width</span><span class="p">());</span>
        <span class="nd">assert_eq!</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="n">data</span><span class="na">.0</span><span class="nf">.height</span><span class="p">());</span>
    <span class="p">}</span>

    <span class="nd">#[test]</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">test_star_1</span><span class="p">()</span> <span class="p">{</span>
        <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">EXP_STAR_1</span><span class="p">,</span> <span class="nf">star_1</span><span class="p">(</span><span class="o">&amp;</span><span class="n">CONTENT</span><span class="nf">.into</span><span class="p">()));</span>
    <span class="p">}</span>

    <span class="k">const</span> <span class="n">CONTENT_2</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span> <span class="o">=</span> <span class="s">r#"FF7FSF7F7F7F7F7F---7
L|LJ||||||||||||F--J
FL-7LJLJ||||||LJL-77
F--JF--7||LJLJ7F7FJ-
L---JF-JLJ.||-FJLJJ7
|F|F-JF---7F7-L7L|7|
|FFJF7L7F-JF7|JL---7
7-L-JL7||F7|L7F-7F7|
L.L7LFJ|||||FJL7||LJ
L7JLJL-JLJLJL--JLJ.L
"#</span><span class="p">;</span>
    <span class="k">const</span> <span class="n">EXP_2_STAR_2</span><span class="p">:</span> <span class="n">SolT</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>

    <span class="k">const</span> <span class="n">CONTENT_3</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span> <span class="o">=</span> <span class="s">r#"...........
.S-------7.
.|F-----7|.
.||.....||.
.||.....||.
.|L-7.F-J|.
.|..|.|..|.
.L--J.L--J.
...........
"#</span><span class="p">;</span>
    <span class="k">const</span> <span class="n">EXP_3_STAR_2</span><span class="p">:</span> <span class="n">SolT</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>

    <span class="k">const</span> <span class="n">CONTENT_4</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span> <span class="o">=</span> <span class="s">r#".F----7F7F7F7F-7....
.|F--7||||||||FJ....
.||.FJ||||||||L7....
FJL7L7LJLJ||LJ.L-7..
L--J.L7...LJS7F-7L7.
....F-J..F7FJ|L7L7L7
....L7.F7||L7|.L7L7|
.....|FJLJ|FJ|F7|.LJ
....FJL-7.||.||||...
....L---J.LJ.LJLJ...
"#</span><span class="p">;</span>
    <span class="k">const</span> <span class="n">EXP_4_STAR_2</span><span class="p">:</span> <span class="n">SolT</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span>

    <span class="nd">#[test]</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">test_star_2</span><span class="p">()</span> <span class="p">{</span>
        <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">EXP_2_STAR_2</span><span class="p">,</span> <span class="nf">star_2</span><span class="p">(</span><span class="o">&amp;</span><span class="n">CONTENT_2</span><span class="nf">.into</span><span class="p">()));</span>
        <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">EXP_3_STAR_2</span><span class="p">,</span> <span class="nf">star_2</span><span class="p">(</span><span class="o">&amp;</span><span class="n">CONTENT_3</span><span class="nf">.into</span><span class="p">()));</span>
        <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">EXP_4_STAR_2</span><span class="p">,</span> <span class="nf">star_2</span><span class="p">(</span><span class="o">&amp;</span><span class="n">CONTENT_4</span><span class="nf">.into</span><span class="p">()));</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p><a href="#top">Top</a></p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="sol-rust-11">Rust | Day 11: Cosmic Expansion</h2>
<div class="sectionbody">
<div class="paragraph">
<p><a href="https://rust-lang.org">Rust</a> solution to <a href="https://adventofcode.com/2023/day/11">AoC|2023|11</a>.</p>
</div>
<div class="sect2">
<h3 id="_input_10">Input</h3>
<div class="paragraph">
<p>I store the coordinates of each galaxy in a vector and create two more vectors with the galaxy counts in very column/row.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
</pre></td><td class="code"><pre><span class="k">pub</span> <span class="k">mod</span> <span class="n">input</span> <span class="p">{</span>
    <span class="nd">#[derive(Debug,</span> <span class="nd">PartialEq,</span> <span class="nd">Eq,</span> <span class="nd">Default)]</span>
    <span class="k">pub</span> <span class="k">struct</span> <span class="n">PuzzleData</span> <span class="p">{</span>
        <span class="k">pub</span> <span class="n">galaxies</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="p">(</span><span class="nb">usize</span><span class="p">,</span> <span class="nb">usize</span><span class="p">)</span><span class="o">&gt;</span><span class="p">,</span>
        <span class="k">pub</span> <span class="n">count_in_cols</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span><span class="p">,</span>
        <span class="k">pub</span> <span class="n">count_in_rows</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="p">}</span>

    <span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="nb">From</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="k">for</span> <span class="n">PuzzleData</span>
    <span class="k">where</span>
        <span class="n">T</span><span class="p">:</span> <span class="nb">AsRef</span><span class="o">&lt;</span><span class="nb">str</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="k">fn</span> <span class="nf">from</span><span class="p">(</span><span class="n">s</span><span class="p">:</span> <span class="n">T</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
            <span class="n">s</span><span class="nf">.as_ref</span><span class="p">()</span>
                <span class="nf">.lines</span><span class="p">()</span>
                <span class="nf">.enumerate</span><span class="p">()</span>
                <span class="nf">.fold</span><span class="p">(</span><span class="nn">PuzzleData</span><span class="p">::</span><span class="nf">default</span><span class="p">(),</span> <span class="p">|</span><span class="k">mut</span> <span class="n">data</span><span class="p">,</span> <span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">line</span><span class="p">)|</span> <span class="p">{</span>
                    <span class="n">data</span><span class="py">.count_in_rows</span><span class="nf">.push</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
                    <span class="n">line</span><span class="nf">.bytes</span><span class="p">()</span><span class="nf">.enumerate</span><span class="p">()</span><span class="nf">.filter</span><span class="p">(|(</span><span class="n">_</span><span class="p">,</span> <span class="n">b</span><span class="p">)|</span> <span class="n">b</span> <span class="o">==</span> <span class="o">&amp;</span><span class="sc">b'#'</span><span class="p">)</span><span class="nf">.fold</span><span class="p">(</span>
                        <span class="n">data</span><span class="p">,</span>
                        <span class="p">|</span><span class="k">mut</span> <span class="n">data</span><span class="p">,</span> <span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="n">_</span><span class="p">)|</span> <span class="p">{</span>
                            <span class="n">data</span><span class="py">.galaxies</span><span class="nf">.push</span><span class="p">((</span><span class="n">col</span><span class="p">,</span> <span class="n">row</span><span class="p">));</span>
                            <span class="n">data</span><span class="py">.count_in_cols</span>
                                <span class="nf">.resize</span><span class="p">(</span><span class="n">data</span><span class="py">.count_in_cols</span><span class="nf">.len</span><span class="p">()</span><span class="nf">.max</span><span class="p">(</span><span class="n">col</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
                            <span class="n">data</span><span class="py">.count_in_cols</span><span class="p">[</span><span class="n">col</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
                            <span class="n">data</span><span class="py">.count_in_rows</span><span class="p">[</span><span class="n">row</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
                            <span class="n">data</span>
                        <span class="p">},</span>
                    <span class="p">)</span>
                <span class="p">})</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_star_1_13">Star 1</h3>
<div class="paragraph">
<p>The basic approach was kind of straight forward. I experimented a bit with possibilities for optimization ending up with computing vectors with the offsets for each column and row that are indexed by the original positions of the galaxies (before expansion of the universe), to calculate the shortest distances in a single pass through all (unordered) pairs of galaxies.</p>
</div>
<div class="paragraph">
<p>I also experimented a bit with <code>flat_map</code> vs <code>map</code> for the nested iterators. In theory, <code>iter_a.flat_map(|a| iter_b.map(move |b| calc_val(a, b))).sum()</code> should create a bit of overhead compared to <code>iter_a.map(|a| iter_b.map(|b| calc_val(a, b)).sum()).sum()</code>. In practice, the differences were hardly in the range of fluctuations of the overall solution time.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
</pre></td><td class="code"><pre><span class="k">fn</span> <span class="nf">calc_offsets</span><span class="p">(</span><span class="n">counts</span><span class="p">:</span> <span class="o">&amp;</span><span class="p">[</span><span class="nb">usize</span><span class="p">],</span> <span class="n">expansion</span><span class="p">:</span> <span class="n">SolT</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">SolT</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="n">counts</span>
        <span class="nf">.iter</span><span class="p">()</span>
        <span class="nf">.scan</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="p">|</span><span class="n">cum_sum</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cnt</span><span class="p">|</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">val</span> <span class="o">=</span> <span class="nf">Some</span><span class="p">(</span><span class="o">*</span><span class="n">cum_sum</span><span class="p">);</span>
            <span class="o">*</span><span class="n">cum_sum</span> <span class="o">+=</span> <span class="k">if</span> <span class="n">cnt</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="p">{</span> <span class="mi">1</span> <span class="p">}</span> <span class="k">else</span> <span class="p">{</span> <span class="n">expansion</span> <span class="p">};</span>
            <span class="n">val</span>
        <span class="p">})</span>
        <span class="nf">.collect</span><span class="p">()</span>
<span class="p">}</span>

<span class="k">pub</span> <span class="k">fn</span> <span class="nf">sum_shortest_path</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">PuzzleData</span><span class="p">,</span> <span class="n">expansion</span><span class="p">:</span> <span class="n">SolT</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">SolT</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">col_offsets</span> <span class="o">=</span> <span class="nf">calc_offsets</span><span class="p">(</span><span class="o">&amp;</span><span class="n">data</span><span class="py">.count_in_cols</span><span class="p">,</span> <span class="n">expansion</span><span class="p">);</span>
    <span class="k">let</span> <span class="n">row_offsets</span> <span class="o">=</span> <span class="nf">calc_offsets</span><span class="p">(</span><span class="o">&amp;</span><span class="n">data</span><span class="py">.count_in_rows</span><span class="p">,</span> <span class="n">expansion</span><span class="p">);</span>
    <span class="n">data</span><span class="py">.galaxies</span>
        <span class="nf">.iter</span><span class="p">()</span>
        <span class="nf">.map</span><span class="p">(|</span><span class="o">&amp;</span><span class="p">(</span><span class="n">col_a</span><span class="p">,</span> <span class="n">row_a</span><span class="p">)|</span> <span class="p">(</span><span class="n">col_offsets</span><span class="p">[</span><span class="n">col_a</span><span class="p">],</span> <span class="n">row_offsets</span><span class="p">[</span><span class="n">row_a</span><span class="p">]))</span>
        <span class="nf">.enumerate</span><span class="p">()</span>
        <span class="nf">.map</span><span class="p">(|(</span><span class="n">pos</span><span class="p">,</span> <span class="p">(</span><span class="n">col_a</span><span class="p">,</span> <span class="n">row_a</span><span class="p">))|</span> <span class="p">{</span>
            <span class="n">data</span><span class="py">.galaxies</span><span class="p">[</span><span class="n">pos</span> <span class="o">+</span> <span class="mi">1</span><span class="o">..</span><span class="p">]</span>
                <span class="nf">.iter</span><span class="p">()</span>
                <span class="nf">.map</span><span class="p">(|</span><span class="o">&amp;</span><span class="p">(</span><span class="n">col_a</span><span class="p">,</span> <span class="n">row_a</span><span class="p">)|</span> <span class="p">(</span><span class="n">col_offsets</span><span class="p">[</span><span class="n">col_a</span><span class="p">],</span> <span class="n">row_offsets</span><span class="p">[</span><span class="n">row_a</span><span class="p">]))</span>
                <span class="nf">.map</span><span class="p">(|(</span><span class="n">col_b</span><span class="p">,</span> <span class="n">row_b</span><span class="p">)|</span> <span class="p">{</span>
                    <span class="n">col_b</span><span class="nf">.max</span><span class="p">(</span><span class="n">col_a</span><span class="p">)</span> <span class="o">-</span> <span class="n">col_b</span><span class="nf">.min</span><span class="p">(</span><span class="n">col_a</span><span class="p">)</span> <span class="o">+</span> <span class="n">row_b</span><span class="nf">.max</span><span class="p">(</span><span class="n">row_a</span><span class="p">)</span> <span class="o">-</span> <span class="n">row_b</span><span class="nf">.min</span><span class="p">(</span><span class="n">row_a</span><span class="p">)</span>
                <span class="p">})</span>
                <span class="py">.sum</span><span class="p">::</span><span class="o">&lt;</span><span class="n">SolT</span><span class="o">&gt;</span><span class="p">()</span>
        <span class="p">})</span>
        <span class="nf">.sum</span><span class="p">()</span>
<span class="p">}</span>

<span class="k">pub</span> <span class="k">fn</span> <span class="nf">star_1</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">PuzzleData</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">SolT</span> <span class="p">{</span>
    <span class="nf">sum_shortest_path</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_star_2_13">Star 2</h3>
<div class="paragraph">
<p>Even in my very first version, I did not alter the grid at all but just adjusted coordinates. So the second part was mostly for free (the only catch was to realize that I need to multiply by one million, not add one million).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno">1
2
3
</pre></td><td class="code"><pre><span class="k">pub</span> <span class="k">fn</span> <span class="nf">star_2</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">PuzzleData</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">SolT</span> <span class="p">{</span>
    <span class="nf">sum_shortest_path</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="mi">1_000_000</span><span class="p">)</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_tests_11">Tests</h3>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
</pre></td><td class="code"><pre><span class="nd">#[cfg(test)]</span>
<span class="k">mod</span> <span class="n">tests</span> <span class="p">{</span>
    <span class="k">use</span> <span class="k">super</span><span class="p">::</span><span class="o">*</span><span class="p">;</span>

    <span class="k">const</span> <span class="n">CONTENT</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span> <span class="o">=</span> <span class="s">r#"...#......
.......#..
#.........
..........
......#...
.#........
.........#
..........
.......#..
#...#.....
"#</span><span class="p">;</span>

    <span class="nd">#[test]</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">test_from</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">data</span> <span class="o">=</span> <span class="nn">PuzzleData</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="n">CONTENT</span><span class="p">);</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"{data:?}"</span><span class="p">);</span>
        <span class="nd">assert_eq!</span><span class="p">(</span>
            <span class="n">PuzzleData</span> <span class="p">{</span>
                <span class="n">galaxies</span><span class="p">:</span> <span class="nd">vec!</span><span class="p">[</span>
                    <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
                    <span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
                    <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span>
                    <span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span>
                    <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span>
                    <span class="p">(</span><span class="mi">9</span><span class="p">,</span> <span class="mi">6</span><span class="p">),</span>
                    <span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">),</span>
                    <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">9</span><span class="p">),</span>
                    <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">9</span><span class="p">)</span>
                <span class="p">],</span>
                <span class="n">count_in_cols</span><span class="p">:</span> <span class="nd">vec!</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
                <span class="n">count_in_rows</span><span class="p">:</span> <span class="nd">vec!</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span>
            <span class="p">},</span>
            <span class="n">data</span>
        <span class="p">);</span>
    <span class="p">}</span>

    <span class="nd">#[test]</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">test_star_1</span><span class="p">()</span> <span class="p">{</span>
        <span class="nd">assert_eq!</span><span class="p">(</span><span class="mi">374</span><span class="p">,</span> <span class="nf">star_1</span><span class="p">(</span><span class="o">&amp;</span><span class="n">CONTENT</span><span class="nf">.into</span><span class="p">()));</span>
    <span class="p">}</span>

    <span class="nd">#[test]</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">test_star_2</span><span class="p">()</span> <span class="p">{</span>
        <span class="nd">assert_eq!</span><span class="p">(</span><span class="mi">1_030</span><span class="p">,</span> <span class="nf">sum_shortest_path</span><span class="p">(</span><span class="o">&amp;</span><span class="n">CONTENT</span><span class="nf">.into</span><span class="p">(),</span> <span class="mi">10</span><span class="p">));</span>
        <span class="nd">assert_eq!</span><span class="p">(</span><span class="mi">8_410</span><span class="p">,</span> <span class="nf">sum_shortest_path</span><span class="p">(</span><span class="o">&amp;</span><span class="n">CONTENT</span><span class="nf">.into</span><span class="p">(),</span> <span class="mi">100</span><span class="p">));</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p><a href="#top">Top</a></p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="sol-rust-12">Rust | Day 12: Hot Springs</h2>
<div class="sectionbody">
<div class="paragraph">
<p><a href="https://rust-lang.org">Rust</a> solution to <a href="https://adventofcode.com/2023/day/12">AoC|2023|12</a>.</p>
</div>
<div class="sect2">
<h3 id="_star_1_14">Star 1</h3>
<div class="paragraph">
<p>I implemented a recursive solution in function <code>check_recursive</code>. Take the first group size and find all positions in the operational/damage patterns where it would match. The call <code>check_recursive</code> recursively with the matched part + one operational element stripped from the pattern and the remaining groups.</p>
</div>
<div class="paragraph">
<p>That&#8217;s essentially it for part 1.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
</pre></td><td class="code"><pre><span class="k">pub</span> <span class="k">fn</span> <span class="nf">parse_line</span><span class="p">(</span><span class="n">line</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="p">(</span><span class="o">&amp;</span><span class="p">[</span><span class="nb">u8</span><span class="p">],</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">SolT</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">line</span><span class="nf">.split_once</span><span class="p">(</span><span class="sc">' '</span><span class="p">)</span>
        <span class="nf">.map</span><span class="p">(|(</span><span class="n">data</span><span class="p">,</span> <span class="n">groups</span><span class="p">)|</span> <span class="p">{</span>
            <span class="p">(</span>
                <span class="n">data</span><span class="nf">.as_bytes</span><span class="p">(),</span>
                <span class="n">groups</span>
                    <span class="nf">.split</span><span class="p">(</span><span class="sc">','</span><span class="p">)</span>
                    <span class="nf">.map</span><span class="p">(</span><span class="nn">str</span><span class="p">::</span><span class="n">parse</span><span class="p">)</span>
                    <span class="py">.collect</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">Result</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="n">_</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">_</span><span class="o">&gt;&gt;</span><span class="p">()</span>
                    <span class="nf">.unwrap</span><span class="p">(),</span>
            <span class="p">)</span>
        <span class="p">})</span>
        <span class="nf">.unwrap</span><span class="p">()</span>
<span class="p">}</span>

<span class="k">type</span> <span class="n">Cache</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">HashMap</span><span class="o">&lt;</span><span class="p">(</span><span class="o">&amp;</span><span class="nv">'a</span> <span class="p">[</span><span class="nb">u8</span><span class="p">],</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="p">[</span><span class="n">SolT</span><span class="p">]),</span> <span class="n">SolT</span><span class="o">&gt;</span><span class="p">;</span>

<span class="k">fn</span> <span class="n">check</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="p">[</span><span class="nb">u8</span><span class="p">],</span> <span class="n">groups</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="p">[</span><span class="n">SolT</span><span class="p">],</span> <span class="n">cache</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">Cache</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">SolT</span> <span class="p">{</span>
    <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="o">&amp;</span><span class="n">result</span><span class="p">)</span> <span class="o">=</span> <span class="n">cache</span><span class="nf">.as_ref</span><span class="p">()</span><span class="nf">.and_then</span><span class="p">(|</span><span class="n">cache</span><span class="p">|</span> <span class="n">cache</span><span class="nf">.get</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">groups</span><span class="p">)))</span> <span class="p">{</span>
        <span class="c1">// return cached result</span>
        <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">let</span> <span class="n">result</span> <span class="o">=</span> <span class="k">if</span> <span class="n">groups</span><span class="nf">.is_empty</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">if</span> <span class="n">data</span><span class="nf">.iter</span><span class="p">()</span><span class="nf">.all</span><span class="p">(|</span><span class="o">&amp;</span><span class="n">d</span><span class="p">|</span> <span class="n">d</span> <span class="o">!=</span> <span class="sc">b'#'</span><span class="p">)</span> <span class="p">{</span>
            <span class="mi">1</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="mi">0</span>
        <span class="p">}</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="c1">// minimum elements still required</span>
        <span class="k">let</span> <span class="n">min_len</span> <span class="o">=</span> <span class="n">groups</span><span class="nf">.iter</span><span class="p">()</span><span class="py">.sum</span><span class="p">::</span><span class="o">&lt;</span><span class="n">SolT</span><span class="o">&gt;</span><span class="p">()</span> <span class="o">+</span> <span class="n">groups</span><span class="nf">.len</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

        <span class="c1">// current group (group &lt;= min_len guaranteed)</span>
        <span class="k">let</span> <span class="n">group</span> <span class="o">=</span> <span class="n">groups</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>

        <span class="c1">// result</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">for</span> <span class="n">pos</span> <span class="k">in</span> <span class="mi">0</span><span class="o">..</span><span class="p">(</span><span class="n">data</span><span class="nf">.len</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span><span class="nf">.saturating_sub</span><span class="p">(</span><span class="n">min_len</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="n">data</span><span class="p">[</span><span class="n">pos</span><span class="o">..</span><span class="n">pos</span> <span class="o">+</span> <span class="n">group</span><span class="p">]</span><span class="nf">.iter</span><span class="p">()</span><span class="nf">.all</span><span class="p">(|</span><span class="o">&amp;</span><span class="n">b</span><span class="p">|</span> <span class="n">b</span> <span class="o">!=</span> <span class="sc">b'.'</span><span class="p">)</span> <span class="p">{</span>
                <span class="c1">// next group elements can be damaged</span>
                <span class="k">if</span> <span class="n">data</span><span class="nf">.len</span><span class="p">()</span> <span class="o">==</span> <span class="n">pos</span> <span class="o">+</span> <span class="n">group</span> <span class="p">{</span>
                    <span class="c1">// no more elements</span>
                    <span class="k">if</span> <span class="n">groups</span><span class="nf">.len</span><span class="p">()</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">{</span>
                        <span class="c1">// no more groups</span>
                        <span class="n">result</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
                    <span class="p">}</span>
                <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="n">data</span><span class="p">[</span><span class="n">pos</span> <span class="o">+</span> <span class="n">group</span><span class="p">]</span> <span class="o">!=</span> <span class="sc">b'#'</span> <span class="p">{</span>
                    <span class="c1">// next element afterwards can be operational</span>
                    <span class="n">result</span> <span class="o">+=</span> <span class="nf">check</span><span class="p">(</span><span class="o">&amp;</span><span class="n">data</span><span class="p">[</span><span class="n">pos</span> <span class="o">+</span> <span class="n">group</span> <span class="o">+</span> <span class="mi">1</span><span class="o">..</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">groups</span><span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="p">],</span> <span class="n">cache</span><span class="p">);</span>
                <span class="p">}</span>
            <span class="p">}</span>

            <span class="k">if</span> <span class="n">data</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span> <span class="o">==</span> <span class="sc">b'#'</span> <span class="p">{</span>
                <span class="c1">// current element is damaged</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="n">result</span>
    <span class="p">};</span>

    <span class="c1">// cache and return result</span>
    <span class="n">cache</span>
        <span class="nf">.as_mut</span><span class="p">()</span>
        <span class="nf">.map</span><span class="p">(|</span><span class="n">cache</span><span class="p">|</span> <span class="n">cache</span><span class="nf">.insert</span><span class="p">((</span><span class="n">data</span><span class="p">,</span> <span class="n">groups</span><span class="p">),</span> <span class="n">result</span><span class="p">));</span>
    <span class="n">result</span>
<span class="p">}</span>

<span class="k">pub</span> <span class="k">fn</span> <span class="nf">star_1</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">SolT</span> <span class="p">{</span>
    <span class="n">data</span><span class="nf">.lines</span><span class="p">()</span>
        <span class="nf">.map</span><span class="p">(</span><span class="n">parse_line</span><span class="p">)</span>
        <span class="nf">.map</span><span class="p">(|(</span><span class="n">data</span><span class="p">,</span> <span class="n">groups</span><span class="p">)|</span> <span class="nf">check</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">groups</span><span class="p">,</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="nb">None</span><span class="p">))</span>
        <span class="nf">.sum</span><span class="p">()</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_star_2_14">Star 2</h3>
<div class="paragraph">
<p>The key to solve part 2 in a reasonable time was to add caching of partial results. So if <code>check_recursive</code> is called on something that had been calculated before, recursion is broken and the cached result is returned. I was surprised to see that using one shared cache (across all lines) does not improve performance over individual caches for each line. The initial capacity of the cache has however quite an impact on the performance.</p>
</div>
<div class="paragraph">
<p>(For part 1, caching is disabled, since caching results in worse runtime)</p>
</div>
<div class="paragraph">
<p>The solution does not feel very clever&#8230;&#8203;</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
</pre></td><td class="code"><pre><span class="k">const</span> <span class="n">UNFOLDS</span><span class="p">:</span> <span class="nb">usize</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>

<span class="nd">#[cfg(not(feature</span> <span class="nd">=</span> <span class="s">"shared-cache"</span><span class="nd">))]</span>
<span class="k">const</span> <span class="n">CACHE_CAPACITY</span><span class="p">:</span> <span class="nb">usize</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">10</span><span class="p">;</span>

<span class="nd">#[cfg(feature</span> <span class="nd">=</span> <span class="s">"shared-cache"</span><span class="nd">)]</span>
<span class="k">const</span> <span class="n">CACHE_CAPACITY</span><span class="p">:</span> <span class="nb">usize</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">;</span>

<span class="k">fn</span> <span class="n">make_cache</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">Cache</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;&gt;</span> <span class="p">{</span>
    <span class="nf">Some</span><span class="p">(</span><span class="nn">Cache</span><span class="p">::</span><span class="nf">with_capacity</span><span class="p">(</span><span class="n">CACHE_CAPACITY</span><span class="p">))</span>
<span class="p">}</span>

<span class="k">pub</span> <span class="k">fn</span> <span class="nf">data_iter</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">,</span> <span class="n">unfolds</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">impl</span> <span class="nb">Iterator</span><span class="o">&lt;</span><span class="n">Item</span> <span class="o">=</span> <span class="p">(</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">u8</span><span class="o">&gt;</span><span class="p">,</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">SolT</span><span class="o">&gt;</span><span class="p">)</span><span class="o">&gt;</span> <span class="o">+</span> <span class="nv">'_</span> <span class="p">{</span>
    <span class="n">data</span><span class="nf">.lines</span><span class="p">()</span><span class="nf">.map</span><span class="p">(</span><span class="n">parse_line</span><span class="p">)</span><span class="nf">.map</span><span class="p">(</span><span class="k">move</span> <span class="p">|(</span><span class="n">data</span><span class="p">,</span> <span class="n">groups</span><span class="p">)|</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">new_data_len</span> <span class="o">=</span> <span class="n">unfolds</span> <span class="o">*</span> <span class="p">(</span><span class="n">data</span><span class="nf">.len</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
        <span class="k">let</span> <span class="n">new_groups_len</span> <span class="o">=</span> <span class="n">unfolds</span> <span class="o">*</span> <span class="n">groups</span><span class="nf">.len</span><span class="p">();</span>
        <span class="p">(</span>
            <span class="n">data</span><span class="nf">.iter</span><span class="p">()</span>
                <span class="nf">.copied</span><span class="p">()</span>
                <span class="nf">.chain</span><span class="p">(</span><span class="nf">once</span><span class="p">(</span><span class="sc">b'?'</span><span class="p">))</span>
                <span class="nf">.cycle</span><span class="p">()</span>
                <span class="nf">.take</span><span class="p">(</span><span class="n">new_data_len</span><span class="p">)</span>
                <span class="py">.collect</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="n">_</span><span class="o">&gt;&gt;</span><span class="p">(),</span>
            <span class="n">groups</span>
                <span class="nf">.into_iter</span><span class="p">()</span>
                <span class="nf">.cycle</span><span class="p">()</span>
                <span class="nf">.take</span><span class="p">(</span><span class="n">new_groups_len</span><span class="p">)</span>
                <span class="py">.collect</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="n">_</span><span class="o">&gt;&gt;</span><span class="p">(),</span>
        <span class="p">)</span>
    <span class="p">})</span>
<span class="p">}</span>

<span class="nd">#[cfg(not(feature</span> <span class="nd">=</span> <span class="s">"shared-cache"</span><span class="nd">))]</span>
<span class="k">pub</span> <span class="k">fn</span> <span class="nf">star_2</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">SolT</span> <span class="p">{</span>
    <span class="nf">data_iter</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">UNFOLDS</span><span class="p">)</span>
        <span class="nf">.map</span><span class="p">(|(</span><span class="n">data</span><span class="p">,</span> <span class="n">groups</span><span class="p">)|</span> <span class="nf">check</span><span class="p">(</span><span class="o">&amp;</span><span class="n">data</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">groups</span><span class="p">,</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="nf">make_cache</span><span class="p">()))</span>
        <span class="nf">.sum</span><span class="p">()</span>
<span class="p">}</span>

<span class="nd">#[cfg(feature</span> <span class="nd">=</span> <span class="s">"shared-cache"</span><span class="nd">)]</span>
<span class="k">pub</span> <span class="k">fn</span> <span class="nf">star_2</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">SolT</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">cache</span> <span class="o">=</span> <span class="nf">make_cache</span><span class="p">();</span>
    <span class="k">let</span> <span class="n">data</span> <span class="o">=</span> <span class="nf">data_iter</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">UNFOLDS</span><span class="p">)</span><span class="py">.collect</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="n">_</span><span class="o">&gt;&gt;</span><span class="p">();</span>
    <span class="n">data</span><span class="nf">.iter</span><span class="p">()</span>
        <span class="nf">.map</span><span class="p">(|(</span><span class="n">data</span><span class="p">,</span> <span class="n">groups</span><span class="p">)|</span> <span class="nf">check</span><span class="p">(</span><span class="o">&amp;</span><span class="n">data</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">groups</span><span class="p">,</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">cache</span><span class="p">))</span>
        <span class="nf">.sum</span><span class="p">()</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_tests_12">Tests</h3>
<div class="paragraph">
<p>Some tests for individual lines proved useful today.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
</pre></td><td class="code"><pre><span class="nd">#[cfg(test)]</span>
<span class="k">mod</span> <span class="n">tests</span> <span class="p">{</span>
    <span class="k">use</span> <span class="k">super</span><span class="p">::</span><span class="o">*</span><span class="p">;</span>

    <span class="k">const</span> <span class="n">CONTENT</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span> <span class="o">=</span> <span class="s">r#"???.### 1,1,3
.??..??...?##. 1,1,3
?#?#?#?#?#?#?#? 1,3,1,6
????.#...#... 4,1,1
????.######..#####. 1,6,5
?###???????? 3,2,1
"#</span><span class="p">;</span>

    <span class="nd">#[test]</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">test_check</span><span class="p">()</span> <span class="p">{</span>
        <span class="nd">assert_eq!</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nf">check</span><span class="p">(</span><span class="s">".###.##.#..."</span><span class="nf">.as_bytes</span><span class="p">(),</span> <span class="o">&amp;</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="nb">None</span><span class="p">));</span>
        <span class="nd">assert_eq!</span><span class="p">(</span>
            <span class="mi">0</span><span class="p">,</span>
            <span class="nf">check</span><span class="p">(</span>
                <span class="s">".###.##.#..."</span><span class="nf">.as_bytes</span><span class="p">(),</span>
                <span class="o">&amp;</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span>
                <span class="o">&amp;</span><span class="k">mut</span> <span class="nf">Some</span><span class="p">(</span><span class="nn">Cache</span><span class="p">::</span><span class="nf">default</span><span class="p">())</span>
            <span class="p">)</span>
        <span class="p">);</span>
        <span class="nd">assert_eq!</span><span class="p">(</span>
            <span class="mi">0</span><span class="p">,</span>
            <span class="nf">check</span><span class="p">(</span><span class="s">".###.##.#..."</span><span class="nf">.as_bytes</span><span class="p">(),</span> <span class="o">&amp;</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="nb">None</span><span class="p">)</span>
        <span class="p">);</span>
        <span class="nd">assert_eq!</span><span class="p">(</span>
            <span class="mi">1</span><span class="p">,</span>
            <span class="nf">check</span><span class="p">(</span>
                <span class="s">".###.##....#"</span><span class="nf">.as_bytes</span><span class="p">(),</span>
                <span class="o">&amp;</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
                <span class="o">&amp;</span><span class="k">mut</span> <span class="nf">Some</span><span class="p">(</span><span class="nn">Cache</span><span class="p">::</span><span class="nf">default</span><span class="p">())</span>
            <span class="p">)</span>
        <span class="p">);</span>

        <span class="k">const</span> <span class="n">EXP</span><span class="p">:</span> <span class="o">&amp;</span><span class="p">[</span><span class="n">SolT</span><span class="p">]</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">10</span><span class="p">];</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="p">(</span><span class="n">line</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">exp</span><span class="p">))</span> <span class="k">in</span> <span class="n">CONTENT</span><span class="nf">.lines</span><span class="p">()</span><span class="nf">.zip</span><span class="p">(</span><span class="n">EXP</span><span class="nf">.iter</span><span class="p">())</span><span class="nf">.enumerate</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">let</span> <span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">groups</span><span class="p">)</span> <span class="o">=</span> <span class="nf">parse_line</span><span class="p">(</span><span class="n">line</span><span class="p">);</span>
            <span class="nd">assert_eq!</span><span class="p">(</span>
                <span class="n">exp</span><span class="p">,</span>
                <span class="nf">check</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">groups</span><span class="p">,</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="p">(</span><span class="n">k</span> <span class="o">&amp;</span> <span class="mi">1</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span><span class="nf">.then_some</span><span class="p">(</span><span class="nn">Cache</span><span class="p">::</span><span class="nf">default</span><span class="p">())),</span>
                <span class="s">"{}"</span><span class="p">,</span>
                <span class="n">line</span>
            <span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="nd">#[test]</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">test_star_1</span><span class="p">()</span> <span class="p">{</span>
        <span class="nd">assert_eq!</span><span class="p">(</span><span class="mi">21</span><span class="p">,</span> <span class="nf">star_1</span><span class="p">(</span><span class="n">CONTENT</span><span class="p">));</span>
    <span class="p">}</span>

    <span class="nd">#[test]</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">test_star_2</span><span class="p">()</span> <span class="p">{</span>
        <span class="nd">assert_eq!</span><span class="p">(</span><span class="mi">525_152</span><span class="p">,</span> <span class="nf">star_2</span><span class="p">(</span><span class="n">CONTENT</span><span class="p">));</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p><a href="#top">Top</a></p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="sol-rust-13">Rust | Day 13: Point of Incidence</h2>
<div class="sectionbody">
<div class="paragraph">
<p><a href="https://rust-lang.org">Rust</a> solution to <a href="https://adventofcode.com/2023/day/13">AoC|2023|13</a>.</p>
</div>
<div class="sect2">
<h3 id="_input_11">Input</h3>
<div class="paragraph">
<p>I parse the input by splitting it by consecutive line breaks. This caused quite a bit of headache, because it results in the chunks of input not ending with a line break. So the usual <code>height = len / (width + 1)</code> needs to be replaced by <code>height = (len + 1) / (width + 1)</code>. It took I long while for me to find that issue.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
</pre></td><td class="code"><pre><span class="k">pub</span> <span class="k">mod</span> <span class="n">input</span> <span class="p">{</span>
    <span class="k">use</span> <span class="k">crate</span><span class="p">::</span><span class="n">SolT</span><span class="p">;</span>

    <span class="nd">#[derive(Debug)]</span>
    <span class="k">pub</span> <span class="k">struct</span> <span class="n">PuzzleData</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span><span class="p">(</span><span class="k">pub</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="p">(</span><span class="o">&amp;</span><span class="nv">'a</span> <span class="p">[</span><span class="nb">u8</span><span class="p">],</span> <span class="n">SolT</span><span class="p">)</span><span class="o">&gt;</span><span class="p">);</span>

    <span class="k">impl</span><span class="o">&lt;</span><span class="nv">'a</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="nb">From</span><span class="o">&lt;&amp;</span><span class="nv">'a</span> <span class="n">T</span><span class="o">&gt;</span> <span class="k">for</span> <span class="n">PuzzleData</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span>
    <span class="k">where</span>
        <span class="n">T</span><span class="p">:</span> <span class="nb">AsRef</span><span class="o">&lt;</span><span class="nb">str</span><span class="o">&gt;</span> <span class="o">+</span> <span class="nv">'a</span> <span class="o">+</span> <span class="o">?</span><span class="nb">Sized</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="k">fn</span> <span class="nf">from</span><span class="p">(</span><span class="n">s</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="n">T</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
            <span class="k">Self</span><span class="p">(</span>
                <span class="n">s</span><span class="nf">.as_ref</span><span class="p">()</span>
                    <span class="nf">.split</span><span class="p">(</span><span class="s">"</span><span class="se">\n\n</span><span class="s">"</span><span class="p">)</span>
                    <span class="nf">.map</span><span class="p">(|</span><span class="n">pattern</span><span class="p">|</span> <span class="p">{</span>
                        <span class="p">(</span>
                            <span class="n">pattern</span><span class="nf">.as_bytes</span><span class="p">(),</span>
                            <span class="n">pattern</span>
                                <span class="nf">.bytes</span><span class="p">()</span>
                                <span class="nf">.position</span><span class="p">(|</span><span class="n">b</span><span class="p">|</span> <span class="n">b</span> <span class="o">==</span> <span class="sc">b'\n'</span><span class="p">)</span>
                                <span class="nf">.unwrap_or</span><span class="p">(</span><span class="n">pattern</span><span class="nf">.len</span><span class="p">()),</span>
                        <span class="p">)</span>
                    <span class="p">})</span>
                    <span class="nf">.collect</span><span class="p">(),</span>
            <span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_star_1_15">Star 1</h3>
<div class="paragraph">
<p>The solution might look a bit over-structured. That is kind of the price for avoiding code duplication (which will become more clear in the second part).</p>
</div>
<div class="paragraph">
<p>For the first part, we need to solve the same problem essentially twice. Once in the horizontal direction, once in the vertical direction. The <code>find_line</code> method does both. To do so, it takes the argument <code>idx</code> of enum type <code>ToIdx</code>, which converts either <code>(col, row)</code> or <code>(row, col)</code> to a flat index into the array. I did not manage to do this with a closure called from a closure.</p>
</div>
<div class="paragraph">
<p>The actual algorithm to find the line of symmetry is simple.</p>
</div>
<div class="paragraph">
<p>The function <code>star</code> accepts the algorithm as an argument <code>f</code> to be re-usable for the second part.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
</pre></td><td class="code"><pre><span class="k">pub</span> <span class="k">enum</span> <span class="n">ToIdx</span> <span class="p">{</span>
    <span class="nf">ColRow</span><span class="p">(</span><span class="n">SolT</span><span class="p">),</span>
    <span class="nf">RowCol</span><span class="p">(</span><span class="n">SolT</span><span class="p">),</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">ToIdx</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">idx</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">SolT</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">SolT</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">SolT</span> <span class="p">{</span>
        <span class="k">match</span> <span class="k">self</span> <span class="p">{</span>
            <span class="k">Self</span><span class="p">::</span><span class="nf">ColRow</span><span class="p">(</span><span class="n">w</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="o">*</span> <span class="p">(</span><span class="n">w</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span>
            <span class="k">Self</span><span class="p">::</span><span class="nf">RowCol</span><span class="p">(</span><span class="n">w</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="n">y</span> <span class="o">+</span> <span class="n">x</span> <span class="o">*</span> <span class="p">(</span><span class="n">w</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">pub</span> <span class="k">fn</span> <span class="nf">find_line</span><span class="p">(</span><span class="n">pattern</span><span class="p">:</span> <span class="o">&amp;</span><span class="p">[</span><span class="nb">u8</span><span class="p">],</span> <span class="n">d1</span><span class="p">:</span> <span class="n">SolT</span><span class="p">,</span> <span class="n">d2</span><span class="p">:</span> <span class="n">SolT</span><span class="p">,</span> <span class="n">idx</span><span class="p">:</span> <span class="n">ToIdx</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">SolT</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="p">(</span><span class="mi">0</span><span class="o">..</span><span class="n">d1</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span><span class="nf">.find</span><span class="p">(</span><span class="k">move</span> <span class="p">|</span><span class="o">&amp;</span><span class="n">line</span><span class="p">|</span> <span class="p">{</span>
        <span class="p">(</span><span class="mi">0</span><span class="o">..</span><span class="n">d2</span><span class="p">)</span><span class="nf">.all</span><span class="p">(|</span><span class="n">y</span><span class="p">|</span> <span class="p">{</span>
            <span class="p">(</span><span class="mi">0</span><span class="o">..=</span><span class="n">line</span><span class="p">)</span>
                <span class="nf">.rev</span><span class="p">()</span>
                <span class="nf">.zip</span><span class="p">(</span><span class="n">line</span> <span class="o">+</span> <span class="mi">1</span><span class="o">..</span><span class="n">d1</span><span class="p">)</span>
                <span class="nf">.all</span><span class="p">(|(</span><span class="n">x_a</span><span class="p">,</span> <span class="n">x_b</span><span class="p">)|</span> <span class="n">pattern</span><span class="p">[</span><span class="n">idx</span><span class="nf">.idx</span><span class="p">(</span><span class="n">x_a</span><span class="p">,</span> <span class="n">y</span><span class="p">)]</span> <span class="o">==</span> <span class="n">pattern</span><span class="p">[</span><span class="n">idx</span><span class="nf">.idx</span><span class="p">(</span><span class="n">x_b</span><span class="p">,</span> <span class="n">y</span><span class="p">)])</span>
        <span class="p">})</span>
    <span class="p">})</span>
<span class="p">}</span>

<span class="k">pub</span> <span class="k">fn</span> <span class="n">star</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="o">&amp;</span><span class="p">[(</span><span class="o">&amp;</span><span class="p">[</span><span class="nb">u8</span><span class="p">],</span> <span class="n">SolT</span><span class="p">)],</span> <span class="n">f</span><span class="p">:</span> <span class="n">F</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">SolT</span>
<span class="k">where</span>
    <span class="n">F</span><span class="p">:</span> <span class="nf">Fn</span><span class="p">(</span><span class="o">&amp;</span><span class="p">[</span><span class="nb">u8</span><span class="p">],</span> <span class="n">SolT</span><span class="p">,</span> <span class="n">SolT</span><span class="p">,</span> <span class="n">ToIdx</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">SolT</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">{</span>
    <span class="n">data</span><span class="nf">.iter</span><span class="p">()</span>
        <span class="nf">.filter_map</span><span class="p">(|</span><span class="o">&amp;</span><span class="p">(</span><span class="n">pattern</span><span class="p">,</span> <span class="n">w</span><span class="p">)|</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">h</span> <span class="o">=</span> <span class="p">(</span><span class="n">pattern</span><span class="nf">.len</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">w</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
            <span class="nf">f</span><span class="p">(</span><span class="n">pattern</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="nn">ToIdx</span><span class="p">::</span><span class="nf">ColRow</span><span class="p">(</span><span class="n">w</span><span class="p">))</span>
                <span class="nf">.map</span><span class="p">(|</span><span class="n">line</span><span class="p">|</span> <span class="n">line</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
                <span class="nf">.or_else</span><span class="p">(||</span> <span class="nf">f</span><span class="p">(</span><span class="n">pattern</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="nn">ToIdx</span><span class="p">::</span><span class="nf">RowCol</span><span class="p">(</span><span class="n">w</span><span class="p">))</span><span class="nf">.map</span><span class="p">(|</span><span class="n">line</span><span class="p">|</span> <span class="p">(</span><span class="n">line</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mi">100</span><span class="p">))</span>
        <span class="p">})</span>
        <span class="nf">.sum</span><span class="p">()</span>
<span class="p">}</span>

<span class="k">pub</span> <span class="k">fn</span> <span class="nf">star_1</span><span class="p">(</span><span class="nf">PuzzleData</span><span class="p">(</span><span class="n">data</span><span class="p">):</span> <span class="o">&amp;</span><span class="n">PuzzleData</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">SolT</span> <span class="p">{</span>
    <span class="nf">star</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">find_line</span><span class="p">)</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_star_2_15">Star 2</h3>
<div class="paragraph">
<p>The second part is solved by adapting the algorithm to not find lines where all elements match, but where there is exactly one that does not match. Against my nature, I implemented this with for loops instead of iterators. The reason is that I can break from the for loop easily as soon as I know that the sum will be larger than one.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
</pre></td><td class="code"><pre><span class="k">pub</span> <span class="k">fn</span> <span class="nf">find_line_with_smudge</span><span class="p">(</span><span class="n">pattern</span><span class="p">:</span> <span class="o">&amp;</span><span class="p">[</span><span class="nb">u8</span><span class="p">],</span> <span class="n">d1</span><span class="p">:</span> <span class="n">SolT</span><span class="p">,</span> <span class="n">d2</span><span class="p">:</span> <span class="n">SolT</span><span class="p">,</span> <span class="n">idx</span><span class="p">:</span> <span class="n">ToIdx</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">SolT</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="p">(</span><span class="mi">0</span><span class="o">..</span><span class="n">d1</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span><span class="nf">.find</span><span class="p">(</span><span class="k">move</span> <span class="p">|</span><span class="o">&amp;</span><span class="n">line</span><span class="p">|</span> <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">for</span> <span class="n">v</span> <span class="k">in</span> <span class="p">(</span><span class="mi">0</span><span class="o">..</span><span class="n">d2</span><span class="p">)</span><span class="nf">.map</span><span class="p">(|</span><span class="n">y</span><span class="p">|</span> <span class="p">{</span>
            <span class="k">let</span> <span class="k">mut</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="k">for</span> <span class="n">v</span> <span class="k">in</span> <span class="p">(</span><span class="mi">0</span><span class="o">..=</span><span class="n">line</span><span class="p">)</span>
                <span class="nf">.rev</span><span class="p">()</span>
                <span class="nf">.zip</span><span class="p">(</span><span class="n">line</span> <span class="o">+</span> <span class="mi">1</span><span class="o">..</span><span class="n">d1</span><span class="p">)</span>
                <span class="nf">.map</span><span class="p">(|(</span><span class="n">x_a</span><span class="p">,</span> <span class="n">x_b</span><span class="p">)|</span> <span class="n">pattern</span><span class="p">[</span><span class="n">idx</span><span class="nf">.idx</span><span class="p">(</span><span class="n">x_a</span><span class="p">,</span> <span class="n">y</span><span class="p">)]</span> <span class="o">==</span> <span class="n">pattern</span><span class="p">[</span><span class="n">idx</span><span class="nf">.idx</span><span class="p">(</span><span class="n">x_b</span><span class="p">,</span> <span class="n">y</span><span class="p">)])</span>
            <span class="p">{</span>
                <span class="n">sum</span> <span class="o">+=</span> <span class="k">if</span> <span class="n">v</span> <span class="p">{</span> <span class="mi">0</span> <span class="p">}</span> <span class="k">else</span> <span class="p">{</span> <span class="mi">1</span> <span class="p">};</span>
                <span class="k">if</span> <span class="n">sum</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="p">{</span>
                    <span class="k">break</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">}</span>
            <span class="n">sum</span>
        <span class="p">})</span> <span class="p">{</span>
            <span class="n">sum</span> <span class="o">+=</span> <span class="n">v</span><span class="p">;</span>
            <span class="k">if</span> <span class="n">sum</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="p">{</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="n">sum</span> <span class="o">==</span> <span class="mi">1</span>
    <span class="p">})</span>
<span class="p">}</span>

<span class="k">pub</span> <span class="k">fn</span> <span class="nf">star_2</span><span class="p">(</span><span class="nf">PuzzleData</span><span class="p">(</span><span class="n">data</span><span class="p">):</span> <span class="o">&amp;</span><span class="n">PuzzleData</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">SolT</span> <span class="p">{</span>
    <span class="nf">star</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">find_line_with_smudge</span><span class="p">)</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_tests_13">Tests</h3>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
</pre></td><td class="code"><pre><span class="nd">#[cfg(test)]</span>
<span class="k">mod</span> <span class="n">tests</span> <span class="p">{</span>
    <span class="k">use</span> <span class="k">super</span><span class="p">::</span><span class="o">*</span><span class="p">;</span>

    <span class="k">const</span> <span class="n">CONTENT</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span> <span class="o">=</span> <span class="s">r#"#.##..##.
..#.##.#.
##......#
##......#
..#.##.#.
..##..##.
#.#.##.#.

#...##..#
#....#..#
..##..###
#####.##.
#####.##.
..##..###
#....#..#
"#</span><span class="p">;</span>

    <span class="nd">#[test]</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">test_from</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">let</span> <span class="nf">PuzzleData</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">=</span> <span class="nn">PuzzleData</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="n">CONTENT</span><span class="p">);</span>
        <span class="nd">assert_eq!</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">data</span><span class="nf">.len</span><span class="p">());</span>
        <span class="nd">assert_eq!</span><span class="p">(</span><span class="mi">9</span><span class="p">,</span> <span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="na">.1</span><span class="p">);</span>
        <span class="nd">assert_eq!</span><span class="p">(</span><span class="mi">9</span><span class="p">,</span> <span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="na">.1</span><span class="p">);</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"{data:?}"</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="nd">#[test]</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">test_find_line_vertical</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">let</span> <span class="nf">PuzzleData</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">=</span> <span class="nn">PuzzleData</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="n">CONTENT</span><span class="p">);</span>
        <span class="nd">assert_eq!</span><span class="p">(</span>
            <span class="nd">vec!</span><span class="p">[</span><span class="nf">Some</span><span class="p">(</span><span class="mi">4</span><span class="p">),</span> <span class="nb">None</span><span class="p">],</span>
            <span class="n">data</span><span class="nf">.iter</span><span class="p">()</span>
                <span class="nf">.map</span><span class="p">(|</span><span class="o">&amp;</span><span class="p">(</span><span class="n">pattern</span><span class="p">,</span> <span class="n">w</span><span class="p">)|</span> <span class="nf">find_line</span><span class="p">(</span>
                    <span class="n">pattern</span><span class="p">,</span>
                    <span class="n">w</span><span class="p">,</span>
                    <span class="p">(</span><span class="n">pattern</span><span class="nf">.len</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">w</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span>
                    <span class="nn">ToIdx</span><span class="p">::</span><span class="nf">ColRow</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
                <span class="p">))</span>
                <span class="py">.collect</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="n">_</span><span class="o">&gt;&gt;</span><span class="p">()</span>
        <span class="p">)</span>
    <span class="p">}</span>

    <span class="nd">#[test]</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">test_find_line_horizontal</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">let</span> <span class="nf">PuzzleData</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">=</span> <span class="nn">PuzzleData</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="n">CONTENT</span><span class="p">);</span>
        <span class="nd">assert_eq!</span><span class="p">(</span>
            <span class="nd">vec!</span><span class="p">[</span><span class="nb">None</span><span class="p">,</span> <span class="nf">Some</span><span class="p">(</span><span class="mi">3</span><span class="p">)],</span>
            <span class="n">data</span><span class="nf">.iter</span><span class="p">()</span>
                <span class="nf">.map</span><span class="p">(|</span><span class="o">&amp;</span><span class="p">(</span><span class="n">pattern</span><span class="p">,</span> <span class="n">w</span><span class="p">)|</span> <span class="nf">find_line</span><span class="p">(</span>
                    <span class="n">pattern</span><span class="p">,</span>
                    <span class="p">(</span><span class="n">pattern</span><span class="nf">.len</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">w</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span>
                    <span class="n">w</span><span class="p">,</span>
                    <span class="nn">ToIdx</span><span class="p">::</span><span class="nf">RowCol</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
                <span class="p">))</span>
                <span class="py">.collect</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="n">_</span><span class="o">&gt;&gt;</span><span class="p">()</span>
        <span class="p">);</span>
    <span class="p">}</span>

    <span class="nd">#[test]</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">test_star_1</span><span class="p">()</span> <span class="p">{</span>
        <span class="nd">assert_eq!</span><span class="p">(</span><span class="mi">405</span><span class="p">,</span> <span class="nf">star_1</span><span class="p">(</span><span class="o">&amp;</span><span class="n">CONTENT</span><span class="nf">.into</span><span class="p">()));</span>
    <span class="p">}</span>

    <span class="nd">#[test]</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">test_star_2</span><span class="p">()</span> <span class="p">{</span>
        <span class="nd">assert_eq!</span><span class="p">(</span><span class="mi">400</span><span class="p">,</span> <span class="nf">star_2</span><span class="p">(</span><span class="o">&amp;</span><span class="n">CONTENT</span><span class="nf">.into</span><span class="p">()));</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p><a href="#top">Top</a></p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="sol-rust-14">Rust | Day 14: Parabolic Reflector Dish</h2>
<div class="sectionbody">
<div class="paragraph">
<p><a href="https://rust-lang.org">Rust</a> solution to <a href="https://adventofcode.com/2023/day/14">AoC|2023|14</a>.</p>
</div>
<div class="sect2">
<h3 id="_input_12">Input</h3>
<div class="paragraph">
<p>Just the plain input plus width and height.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
</pre></td><td class="code"><pre><span class="k">pub</span> <span class="k">mod</span> <span class="n">input</span> <span class="p">{</span>
    <span class="nd">#[derive(Debug)]</span>
    <span class="k">pub</span> <span class="k">struct</span> <span class="n">PuzzleData</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span><span class="p">(</span><span class="k">pub</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="p">[</span><span class="nb">u8</span><span class="p">],</span> <span class="k">pub</span> <span class="nb">usize</span><span class="p">,</span> <span class="k">pub</span> <span class="nb">usize</span><span class="p">);</span>

    <span class="k">impl</span><span class="o">&lt;</span><span class="nv">'a</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="nb">From</span><span class="o">&lt;&amp;</span><span class="nv">'a</span> <span class="n">T</span><span class="o">&gt;</span> <span class="k">for</span> <span class="n">PuzzleData</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span>
    <span class="k">where</span>
        <span class="n">T</span><span class="p">:</span> <span class="nb">AsRef</span><span class="o">&lt;</span><span class="p">[</span><span class="nb">u8</span><span class="p">]</span><span class="o">&gt;</span> <span class="o">+</span> <span class="nv">'a</span> <span class="o">+</span> <span class="o">?</span><span class="nb">Sized</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="k">fn</span> <span class="nf">from</span><span class="p">(</span><span class="n">s</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="n">T</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">data</span> <span class="o">=</span> <span class="n">s</span><span class="nf">.as_ref</span><span class="p">();</span>
            <span class="k">let</span> <span class="n">w</span> <span class="o">=</span> <span class="n">data</span><span class="nf">.iter</span><span class="p">()</span><span class="nf">.position</span><span class="p">(|</span><span class="o">&amp;</span><span class="n">b</span><span class="p">|</span> <span class="n">b</span> <span class="o">==</span> <span class="sc">b'\n'</span><span class="p">)</span><span class="nf">.unwrap_or</span><span class="p">(</span><span class="n">data</span><span class="nf">.len</span><span class="p">());</span>
            <span class="k">let</span> <span class="n">h</span> <span class="o">=</span> <span class="p">(</span><span class="n">data</span><span class="nf">.len</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">w</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
            <span class="k">Self</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">h</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_star_1_16">Star 1</h3>
<div class="paragraph">
<p>I just calculated the load without actually modifying the grid.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
</pre></td><td class="code"><pre><span class="k">pub</span> <span class="k">fn</span> <span class="nf">star_1</span><span class="p">(</span><span class="o">&amp;</span><span class="nf">PuzzleData</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">h</span><span class="p">):</span> <span class="o">&amp;</span><span class="n">PuzzleData</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
    <span class="p">(</span><span class="mi">0</span><span class="o">..</span><span class="n">w</span><span class="p">)</span>
        <span class="nf">.map</span><span class="p">(|</span><span class="n">col</span><span class="p">|</span> <span class="p">{</span>
            <span class="p">(</span><span class="mi">0</span><span class="o">..</span><span class="n">h</span><span class="p">)</span><span class="nf">.fold</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">|(</span><span class="n">load</span><span class="p">,</span> <span class="n">free</span><span class="p">),</span> <span class="n">row</span><span class="p">|</span> <span class="p">{</span>
                <span class="k">match</span> <span class="n">data</span><span class="p">[</span><span class="n">col</span> <span class="o">+</span> <span class="n">row</span> <span class="o">*</span> <span class="p">(</span><span class="n">w</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span> <span class="p">{</span>
                    <span class="sc">b'#'</span> <span class="k">=&gt;</span> <span class="p">(</span><span class="n">load</span><span class="p">,</span> <span class="n">row</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span>
                    <span class="sc">b'O'</span> <span class="k">=&gt;</span> <span class="p">(</span><span class="n">load</span> <span class="o">+</span> <span class="n">h</span> <span class="o">-</span> <span class="n">free</span><span class="p">,</span> <span class="n">free</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span>
                    <span class="n">_</span> <span class="k">=&gt;</span> <span class="p">(</span><span class="n">load</span><span class="p">,</span> <span class="n">free</span><span class="p">),</span>
                <span class="p">}</span>
            <span class="p">})</span>
        <span class="p">})</span>
        <span class="nf">.fold</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="p">|</span><span class="n">sum</span><span class="p">,</span> <span class="p">(</span><span class="n">load</span><span class="p">,</span> <span class="n">_</span><span class="p">)|</span> <span class="n">sum</span> <span class="o">+</span> <span class="n">load</span><span class="p">)</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_star_2_16">Star 2</h3>
<div class="paragraph">
<p>Now, I need to modify the grid - at least I do not have a better idea.</p>
</div>
<div class="paragraph">
<p>Obviously, this was about finding a shortcut to simulating a billion cycles. I have no idea if there is an analytic way, but given the 'physics' of the problem, there should by periodic cycles after a while.</p>
</div>
<div class="paragraph">
<p>My first attempt was to check for repetitions in the rock locations themselves. That did not work, because I only compared to the configuration after the first cycle completed, but apparently the inputs are such that it takes a while before we reach the periodic behavior.</p>
</div>
<div class="paragraph">
<p>Then I just took the loads produced in each direction throughout one cycle and stored them in a vector (the numbers are small enough so that linear search is cheaper than the overhead of a hash map). This solution works independent of the number of initial steps it takes, before repeating cycles start. I might have double-checked that the actual rock locations do repeat as well&#8230;&#8203;</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
</pre></td><td class="code"><pre><span class="k">pub</span> <span class="k">fn</span> <span class="n">tilt</span><span class="o">&lt;</span><span class="n">F</span><span class="p">:</span> <span class="nf">Fn</span><span class="p">(</span><span class="nb">usize</span><span class="p">,</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span><span class="o">&gt;</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="p">[</span><span class="nb">u8</span><span class="p">],</span> <span class="n">d1</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span> <span class="n">d2</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span> <span class="n">idx</span><span class="p">:</span> <span class="n">F</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
    <span class="p">(</span><span class="mi">0</span><span class="o">..</span><span class="n">d1</span><span class="p">)</span>
        <span class="nf">.map</span><span class="p">(|</span><span class="n">x</span><span class="p">|</span> <span class="p">{</span>
            <span class="p">(</span><span class="mi">0</span><span class="o">..</span><span class="n">d2</span><span class="p">)</span><span class="nf">.fold</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">|(</span><span class="n">load</span><span class="p">,</span> <span class="n">free</span><span class="p">),</span> <span class="n">y</span><span class="p">|</span> <span class="k">match</span> <span class="n">data</span><span class="p">[</span><span class="nf">idx</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)]</span> <span class="p">{</span>
                <span class="sc">b'#'</span> <span class="k">=&gt;</span> <span class="p">(</span><span class="n">load</span><span class="p">,</span> <span class="n">y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span>
                <span class="sc">b'O'</span> <span class="k">=&gt;</span> <span class="p">{</span>
                    <span class="n">data</span><span class="nf">.swap</span><span class="p">(</span><span class="nf">idx</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">free</span><span class="p">),</span> <span class="nf">idx</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">));</span>
                    <span class="p">(</span><span class="n">load</span> <span class="o">+</span> <span class="n">d2</span> <span class="o">-</span> <span class="n">free</span><span class="p">,</span> <span class="n">free</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
                <span class="p">}</span>
                <span class="n">_</span> <span class="k">=&gt;</span> <span class="p">(</span><span class="n">load</span><span class="p">,</span> <span class="n">free</span><span class="p">),</span>
            <span class="p">})</span>
        <span class="p">})</span>
        <span class="nf">.fold</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="p">|</span><span class="n">sum</span><span class="p">,</span> <span class="p">(</span><span class="n">load</span><span class="p">,</span> <span class="n">_</span><span class="p">)|</span> <span class="n">sum</span> <span class="o">+</span> <span class="n">load</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">pub</span> <span class="k">fn</span> <span class="nf">cycle</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="p">[</span><span class="nb">u8</span><span class="p">],</span> <span class="n">w</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span> <span class="n">h</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="p">[</span><span class="nb">usize</span><span class="p">;</span> <span class="mi">4</span><span class="p">]</span> <span class="p">{</span>
    <span class="p">[</span>
        <span class="nf">tilt</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="p">|</span><span class="n">col</span><span class="p">,</span> <span class="n">row</span><span class="p">|</span> <span class="n">col</span> <span class="o">+</span> <span class="n">row</span> <span class="o">*</span> <span class="p">(</span><span class="n">w</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)),</span>
        <span class="nf">tilt</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="p">|</span><span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">|</span> <span class="n">col</span> <span class="o">+</span> <span class="n">row</span> <span class="o">*</span> <span class="p">(</span><span class="n">w</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)),</span>
        <span class="nf">tilt</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="p">|</span><span class="n">col</span><span class="p">,</span> <span class="n">row_inv</span><span class="p">|</span> <span class="n">col</span> <span class="o">+</span> <span class="p">(</span><span class="n">h</span> <span class="o">-</span> <span class="n">row_inv</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">w</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)),</span>
        <span class="nf">tilt</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="p">|</span><span class="n">row</span><span class="p">,</span> <span class="n">col_inv</span><span class="p">|</span> <span class="p">(</span><span class="n">w</span> <span class="o">-</span> <span class="n">col_inv</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">row</span> <span class="o">*</span> <span class="p">(</span><span class="n">w</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)),</span>
    <span class="p">]</span>
<span class="p">}</span>

<span class="k">pub</span> <span class="k">fn</span> <span class="nf">star_2</span><span class="p">(</span><span class="o">&amp;</span><span class="nf">PuzzleData</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">h</span><span class="p">):</span> <span class="o">&amp;</span><span class="n">PuzzleData</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="nf">.to_owned</span><span class="p">();</span>

    <span class="c1">// cycle until repetition is found</span>
    <span class="k">let</span> <span class="n">r</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="o">..</span><span class="p">)</span>
        <span class="nf">.scan</span><span class="p">(</span><span class="nn">Vec</span><span class="p">::</span><span class="nf">new</span><span class="p">(),</span> <span class="p">|</span><span class="n">list</span><span class="p">,</span> <span class="n">n_1</span><span class="p">|</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">loads</span> <span class="o">=</span> <span class="nf">cycle</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">data</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">h</span><span class="p">);</span>
            <span class="k">let</span> <span class="n">v</span> <span class="o">=</span> <span class="n">list</span>
                <span class="nf">.iter</span><span class="p">()</span>
                <span class="nf">.position</span><span class="p">(|</span><span class="n">prev</span><span class="p">|</span> <span class="n">prev</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">loads</span><span class="p">)</span>
                <span class="nf">.map</span><span class="p">(|</span><span class="n">n_0</span><span class="p">|</span> <span class="p">((</span><span class="mi">1_000_000_000</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="n">n_1</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span> <span class="o">%</span> <span class="p">(</span><span class="n">n_1</span> <span class="o">-</span> <span class="n">n_0</span><span class="p">));</span>
            <span class="n">list</span><span class="nf">.push</span><span class="p">(</span><span class="n">loads</span><span class="p">);</span>
            <span class="nf">Some</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
        <span class="p">})</span>
        <span class="nf">.flatten</span><span class="p">()</span>
        <span class="nf">.next</span><span class="p">()</span>
        <span class="nf">.unwrap</span><span class="p">();</span>

    <span class="c1">// execute residual cycles</span>
    <span class="k">for</span> <span class="n">_</span> <span class="k">in</span> <span class="mi">0</span><span class="o">..</span><span class="n">r</span> <span class="p">{</span>
        <span class="nf">cycle</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">data</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">h</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// determine load on north (without tilting to north)</span>
    <span class="p">(</span><span class="mi">0</span><span class="o">..</span><span class="n">w</span><span class="p">)</span>
        <span class="nf">.map</span><span class="p">(|</span><span class="n">col</span><span class="p">|</span> <span class="p">{</span>
            <span class="p">(</span><span class="mi">0</span><span class="o">..</span><span class="n">h</span><span class="p">)</span>
                <span class="nf">.filter</span><span class="p">(|</span><span class="o">&amp;</span><span class="n">row</span><span class="p">|</span> <span class="n">data</span><span class="p">[</span><span class="n">col</span> <span class="o">+</span> <span class="n">row</span> <span class="o">*</span> <span class="p">(</span><span class="n">w</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span> <span class="o">==</span> <span class="sc">b'O'</span><span class="p">)</span>
                <span class="nf">.map</span><span class="p">(|</span><span class="n">row</span><span class="p">|</span> <span class="n">h</span> <span class="o">-</span> <span class="n">row</span><span class="p">)</span>
                <span class="py">.sum</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span><span class="p">()</span>
        <span class="p">})</span>
        <span class="nf">.sum</span><span class="p">()</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_tests_14">Tests</h3>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
</pre></td><td class="code"><pre><span class="nd">#[cfg(test)]</span>
<span class="k">mod</span> <span class="n">tests</span> <span class="p">{</span>
    <span class="k">use</span> <span class="k">super</span><span class="p">::</span><span class="o">*</span><span class="p">;</span>

    <span class="k">const</span> <span class="n">CONTENT</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span> <span class="o">=</span> <span class="s">r#"O....#....
O.OO#....#
.....##...
OO.#O....O
.O.....O#.
O.#..O.#.#
..O..#O..O
.......O..
#....###..
#OO..#....
"#</span><span class="p">;</span>

    <span class="k">const</span> <span class="n">CONTENT_1</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span> <span class="o">=</span> <span class="s">r#".....#....
....#...O#
...OO##...
.OO#......
.....OOO#.
.O#...O#.#
....O#....
......OOOO
#...O###..
#..OO#....
"#</span><span class="p">;</span>

    <span class="k">const</span> <span class="n">CONTENT_2</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span> <span class="o">=</span> <span class="s">r#".....#....
....#...O#
.....##...
..O#......
.....OOO#.
.O#...O#.#
....O#...O
.......OOO
#..OO###..
#.OOO#...O
"#</span><span class="p">;</span>

    <span class="k">const</span> <span class="n">CONTENT_3</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span> <span class="o">=</span> <span class="s">r#".....#....
....#...O#
.....##...
..O#......
.....OOO#.
.O#...O#.#
....O#...O
.......OOO
#...O###.O
#.OOO#...O
"#</span><span class="p">;</span>

    <span class="nd">#[test]</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">test_from</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">let</span> <span class="nf">PuzzleData</span><span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">h</span><span class="p">)</span> <span class="o">=</span> <span class="nn">PuzzleData</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="n">CONTENT</span><span class="p">);</span>
        <span class="nd">assert_eq!</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="n">w</span><span class="p">);</span>
        <span class="nd">assert_eq!</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="n">h</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="nd">#[test]</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">test_cycle</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">let</span> <span class="nf">PuzzleData</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">h</span><span class="p">)</span> <span class="o">=</span> <span class="nn">PuzzleData</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="n">CONTENT</span><span class="p">);</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="nf">.to_owned</span><span class="p">();</span>
        <span class="nf">cycle</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">data</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">h</span><span class="p">);</span>
        <span class="nd">assert_eq!</span><span class="p">(</span><span class="nn">String</span><span class="p">::</span><span class="nf">from_utf8_lossy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">data</span><span class="p">),</span> <span class="n">CONTENT_1</span><span class="p">);</span>
        <span class="nf">cycle</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">data</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">h</span><span class="p">);</span>
        <span class="nd">assert_eq!</span><span class="p">(</span><span class="nn">String</span><span class="p">::</span><span class="nf">from_utf8_lossy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">data</span><span class="p">),</span> <span class="n">CONTENT_2</span><span class="p">);</span>
        <span class="nf">cycle</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">data</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">h</span><span class="p">);</span>
        <span class="nd">assert_eq!</span><span class="p">(</span><span class="nn">String</span><span class="p">::</span><span class="nf">from_utf8_lossy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">data</span><span class="p">),</span> <span class="n">CONTENT_3</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="nd">#[test]</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">test_star_1</span><span class="p">()</span> <span class="p">{</span>
        <span class="nd">assert_eq!</span><span class="p">(</span><span class="mi">136</span><span class="p">,</span> <span class="nf">star_1</span><span class="p">(</span><span class="o">&amp;</span><span class="n">CONTENT</span><span class="nf">.into</span><span class="p">()));</span>
    <span class="p">}</span>

    <span class="nd">#[test]</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">test_tilt_north</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">let</span> <span class="nf">PuzzleData</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">h</span><span class="p">)</span> <span class="o">=</span> <span class="nn">PuzzleData</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="n">CONTENT</span><span class="p">);</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="nf">.to_owned</span><span class="p">();</span>
        <span class="nd">assert_eq!</span><span class="p">(</span><span class="mi">136</span><span class="p">,</span> <span class="nf">tilt</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">data</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="p">|</span><span class="n">col</span><span class="p">,</span> <span class="n">row</span><span class="p">|</span> <span class="n">col</span> <span class="o">+</span> <span class="n">row</span> <span class="o">*</span> <span class="p">(</span><span class="n">w</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)));</span>
    <span class="p">}</span>

    <span class="nd">#[test]</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">test_star_2</span><span class="p">()</span> <span class="p">{</span>
        <span class="nd">assert_eq!</span><span class="p">(</span><span class="mi">64</span><span class="p">,</span> <span class="nf">star_2</span><span class="p">(</span><span class="o">&amp;</span><span class="n">CONTENT</span><span class="nf">.into</span><span class="p">()));</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p><a href="#top">Top</a></p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="sol-rust-15">Rust | Day 15: Lens Library</h2>
<div class="sectionbody">
<div class="paragraph">
<p><a href="https://rust-lang.org">Rust</a> solution to <a href="https://adventofcode.com/2023/day/15">AoC|2023|15</a>.</p>
</div>
<div class="sect2">
<h3 id="_star_1_17">Star 1</h3>
<div class="paragraph">
<p>A no-brainer</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre><span class="k">pub</span> <span class="k">fn</span> <span class="nf">hash</span><span class="p">(</span><span class="n">item</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
    <span class="n">item</span><span class="nf">.bytes</span><span class="p">()</span>
        <span class="nf">.fold</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="p">|</span><span class="n">hash</span><span class="p">,</span> <span class="n">b</span><span class="p">|</span> <span class="p">((</span><span class="n">hash</span> <span class="o">+</span> <span class="p">(</span><span class="n">b</span> <span class="k">as</span> <span class="nb">usize</span><span class="p">))</span> <span class="o">*</span> <span class="mi">17</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">255</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">pub</span> <span class="k">fn</span> <span class="nf">star_1</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
    <span class="n">data</span><span class="nf">.split</span><span class="p">(</span><span class="sc">','</span><span class="p">)</span><span class="nf">.map</span><span class="p">(</span><span class="nn">str</span><span class="p">::</span><span class="n">trim</span><span class="p">)</span><span class="nf">.map</span><span class="p">(</span><span class="n">hash</span><span class="p">)</span><span class="nf">.sum</span><span class="p">()</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_star_2_17">Star 2</h3>
<div class="paragraph">
<p>A bit of reading comprehension, mostly.</p>
</div>
<div class="paragraph">
<p>The input is parsed into pairs of a label and an optional value on the fly.</p>
</div>
<div class="paragraph">
<p>The vec of boxes is essentially a hash map, each box inside is a bucket of values that produce the same hash. The algorithm to apply for collision resolution is probably something like link::https://en.wikipedia.org/wiki/Hash_table#Separate_chaining[separate chaining], but link::https://rust-unofficial.github.io/too-many-lists/[linked lists] are no fun.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
</pre></td><td class="code"><pre><span class="k">pub</span> <span class="k">fn</span> <span class="nf">star_2</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">init_boxes</span> <span class="o">=</span> <span class="p">||</span> <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">boxes</span> <span class="o">=</span> <span class="nn">Vec</span><span class="p">::</span><span class="nf">with_capacity</span><span class="p">(</span><span class="mi">256</span><span class="p">);</span>
        <span class="n">boxes</span><span class="nf">.resize</span><span class="p">(</span><span class="mi">256</span><span class="p">,</span> <span class="nn">Vec</span><span class="p">::</span><span class="nf">new</span><span class="p">());</span>
        <span class="n">boxes</span>
    <span class="p">};</span>

    <span class="n">data</span><span class="nf">.split</span><span class="p">(</span><span class="sc">','</span><span class="p">)</span>
        <span class="nf">.map</span><span class="p">(</span><span class="nn">str</span><span class="p">::</span><span class="n">trim</span><span class="p">)</span>
        <span class="nf">.map</span><span class="p">(|</span><span class="n">step</span><span class="p">|</span> <span class="p">{</span>
            <span class="n">step</span><span class="nf">.split_once</span><span class="p">(</span><span class="sc">'='</span><span class="p">)</span>
                <span class="nf">.map</span><span class="p">(|(</span><span class="n">label</span><span class="p">,</span> <span class="n">value</span><span class="p">)|</span> <span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="nf">Some</span><span class="p">(</span><span class="n">value</span><span class="py">.parse</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">())))</span>
                <span class="nf">.or_else</span><span class="p">(||</span> <span class="n">step</span><span class="nf">.strip_suffix</span><span class="p">(</span><span class="sc">'-'</span><span class="p">)</span><span class="nf">.map</span><span class="p">(|</span><span class="n">label</span><span class="p">|</span> <span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="nb">None</span><span class="p">)))</span>
                <span class="nf">.unwrap</span><span class="p">()</span>
        <span class="p">})</span>
        <span class="nf">.fold</span><span class="p">(</span><span class="nf">init_boxes</span><span class="p">(),</span> <span class="p">|</span><span class="k">mut</span> <span class="n">boxes</span><span class="p">,</span> <span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">value</span><span class="p">)|</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">box_</span> <span class="o">=</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">boxes</span><span class="p">[</span><span class="nf">hash</span><span class="p">(</span><span class="n">label</span><span class="p">)];</span>
            <span class="k">let</span> <span class="n">idx</span> <span class="o">=</span> <span class="n">box_</span><span class="nf">.iter</span><span class="p">()</span><span class="nf">.position</span><span class="p">(|(</span><span class="n">other</span><span class="p">,</span> <span class="n">_</span><span class="p">)|</span> <span class="n">other</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">label</span><span class="p">);</span>
            <span class="k">match</span> <span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">idx</span><span class="p">)</span> <span class="p">{</span>
                <span class="p">(</span><span class="nf">Some</span><span class="p">(</span><span class="n">value</span><span class="p">),</span> <span class="nf">Some</span><span class="p">(</span><span class="n">idx</span><span class="p">))</span> <span class="k">=&gt;</span> <span class="n">box_</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">value</span><span class="p">),</span>
                <span class="p">(</span><span class="nf">Some</span><span class="p">(</span><span class="n">value</span><span class="p">),</span> <span class="n">_</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="n">box_</span><span class="nf">.push</span><span class="p">((</span><span class="n">label</span><span class="p">,</span> <span class="n">value</span><span class="p">)),</span>
                <span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="nf">Some</span><span class="p">(</span><span class="n">idx</span><span class="p">))</span> <span class="k">=&gt;</span> <span class="n">_</span> <span class="o">=</span> <span class="n">box_</span><span class="nf">.remove</span><span class="p">(</span><span class="n">idx</span><span class="p">),</span>
                <span class="n">_</span> <span class="k">=&gt;</span> <span class="p">(),</span>
            <span class="p">}</span>
            <span class="n">boxes</span>
        <span class="p">})</span>
        <span class="nf">.iter</span><span class="p">()</span>
        <span class="nf">.enumerate</span><span class="p">()</span>
        <span class="nf">.map</span><span class="p">(|(</span><span class="n">box_no</span><span class="p">,</span> <span class="n">box_</span><span class="p">)|</span> <span class="p">{</span>
            <span class="n">box_</span><span class="nf">.iter</span><span class="p">()</span>
                <span class="nf">.enumerate</span><span class="p">()</span>
                <span class="nf">.map</span><span class="p">(|(</span><span class="n">lens_no</span><span class="p">,</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="n">value</span><span class="p">))|</span> <span class="p">(</span><span class="n">box_no</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">lens_no</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">value</span><span class="p">)</span>
                <span class="py">.sum</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span><span class="p">()</span>
        <span class="p">})</span>
        <span class="nf">.sum</span><span class="p">()</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_tests_15">Tests</h3>
<div class="paragraph">
<p>Only created after the puzzle was solved today.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
</pre></td><td class="code"><pre><span class="nd">#[cfg(test)]</span>
<span class="k">mod</span> <span class="n">tests</span> <span class="p">{</span>
    <span class="k">use</span> <span class="k">super</span><span class="p">::</span><span class="o">*</span><span class="p">;</span>

    <span class="k">const</span> <span class="n">CONTENT</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span> <span class="o">=</span> <span class="s">r#"rn=1,cm-,qp=3,cm=2,qp-,pc=4,ot=9,ab=5,pc-,pc=6,ot=7"#</span><span class="p">;</span>

    <span class="nd">#[test]</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">test_star_1</span><span class="p">()</span> <span class="p">{</span>
        <span class="nd">assert_eq!</span><span class="p">(</span><span class="mi">1_320</span><span class="p">,</span> <span class="nf">star_1</span><span class="p">(</span><span class="n">CONTENT</span><span class="p">));</span>
    <span class="p">}</span>

    <span class="nd">#[test]</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">test_star_2</span><span class="p">()</span> <span class="p">{</span>
        <span class="nd">assert_eq!</span><span class="p">(</span><span class="mi">145</span><span class="p">,</span> <span class="nf">star_2</span><span class="p">(</span><span class="n">CONTENT</span><span class="p">));</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p><a href="#top">Top</a></p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="sol-rust-16">Rust | Day 16: The Floor Will Be Lava</h2>
<div class="sectionbody">
<div class="paragraph">
<p><a href="https://rust-lang.org">Rust</a> solution to <a href="https://adventofcode.com/2023/day/16">AoC|2023|16</a>.</p>
</div>
<div class="sect2">
<h3 id="_input_13">Input</h3>
<div class="paragraph">
<p>Forward the input data together with grid width and height.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
</pre></td><td class="code"><pre><span class="k">pub</span> <span class="k">mod</span> <span class="n">input</span> <span class="p">{</span>
    <span class="nd">#[derive(Debug)]</span>
    <span class="k">pub</span> <span class="k">struct</span> <span class="n">PuzzleData</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span><span class="p">(</span><span class="k">pub</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="p">[</span><span class="nb">u8</span><span class="p">],</span> <span class="k">pub</span> <span class="nb">usize</span><span class="p">,</span> <span class="k">pub</span> <span class="nb">usize</span><span class="p">);</span>

    <span class="k">impl</span><span class="o">&lt;</span><span class="nv">'a</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="nb">From</span><span class="o">&lt;&amp;</span><span class="nv">'a</span> <span class="n">T</span><span class="o">&gt;</span> <span class="k">for</span> <span class="n">PuzzleData</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span>
    <span class="k">where</span>
        <span class="n">T</span><span class="p">:</span> <span class="nb">AsRef</span><span class="o">&lt;</span><span class="p">[</span><span class="nb">u8</span><span class="p">]</span><span class="o">&gt;</span> <span class="o">+</span> <span class="nv">'a</span> <span class="o">+</span> <span class="o">?</span><span class="nb">Sized</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="k">fn</span> <span class="nf">from</span><span class="p">(</span><span class="n">s</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="n">T</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">data</span> <span class="o">=</span> <span class="n">s</span><span class="nf">.as_ref</span><span class="p">();</span>
            <span class="k">let</span> <span class="n">w</span> <span class="o">=</span> <span class="n">data</span><span class="nf">.iter</span><span class="p">()</span><span class="nf">.position</span><span class="p">(|</span><span class="o">&amp;</span><span class="n">b</span><span class="p">|</span> <span class="n">b</span> <span class="o">==</span> <span class="sc">b'\n'</span><span class="p">)</span><span class="nf">.unwrap_or</span><span class="p">(</span><span class="n">data</span><span class="nf">.len</span><span class="p">());</span>
            <span class="k">let</span> <span class="n">h</span> <span class="o">=</span> <span class="p">(</span><span class="n">data</span><span class="nf">.len</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">w</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
            <span class="k">Self</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">h</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_star_1_18">Star 1</h3>
<div class="paragraph">
<p>I implemented a depth first search to let the beam of light traverse the contraption. Breadth first search would have worked just as well, but pushing to and popping from the tail using a <code>Vec</code> is much faster than pushing to one end and popping from the other in a <code>VecDeque</code>.</p>
</div>
<div class="paragraph">
<p>The state of the search space includes a heading, so a tile is only to be considered seen if there was a beam at the same tile and in the same direction.</p>
</div>
<div class="paragraph">
<p>Key to performance is: avoid using <code>HashMap</code>, <code>HashSet</code>, <code>VecDeque</code>, &#8230;&#8203;</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
</pre></td><td class="code"><pre><span class="k">const</span> <span class="n">EAST</span><span class="p">:</span> <span class="nb">u8</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">const</span> <span class="n">NORTH</span><span class="p">:</span> <span class="nb">u8</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="k">const</span> <span class="n">WEST</span><span class="p">:</span> <span class="nb">u8</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
<span class="k">const</span> <span class="n">SOUTH</span><span class="p">:</span> <span class="nb">u8</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>

<span class="k">const</span> <span class="n">EAST_WEST</span><span class="p">:</span> <span class="nb">u8</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">const</span> <span class="n">NORTH_SOUTH</span><span class="p">:</span> <span class="nb">u8</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

<span class="k">pub</span> <span class="k">fn</span> <span class="nf">count_energized</span><span class="p">(</span>
    <span class="n">data</span><span class="p">:</span> <span class="o">&amp;</span><span class="p">[</span><span class="nb">u8</span><span class="p">],</span>
    <span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">h</span><span class="p">):</span> <span class="p">(</span><span class="nb">usize</span><span class="p">,</span> <span class="nb">usize</span><span class="p">),</span>
    <span class="p">((</span><span class="n">col</span><span class="p">,</span> <span class="n">row</span><span class="p">),</span> <span class="n">heading</span><span class="p">):</span> <span class="p">((</span><span class="nb">usize</span><span class="p">,</span> <span class="nb">usize</span><span class="p">),</span> <span class="nb">u8</span><span class="p">),</span>
<span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">queue</span> <span class="o">=</span> <span class="nn">Vec</span><span class="p">::</span><span class="nf">from</span><span class="p">([((</span><span class="n">col</span><span class="p">,</span> <span class="n">row</span><span class="p">),</span> <span class="n">heading</span><span class="p">)]);</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">seen</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[</span><span class="mi">0u8</span><span class="p">;</span> <span class="n">w</span> <span class="o">*</span> <span class="n">h</span><span class="p">];</span>
    <span class="n">seen</span><span class="p">[</span><span class="n">col</span> <span class="o">+</span> <span class="n">row</span> <span class="o">*</span> <span class="n">w</span><span class="p">]</span> <span class="p">|</span><span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">heading</span><span class="p">;</span>

    <span class="k">while</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(((</span><span class="n">col</span><span class="p">,</span> <span class="n">row</span><span class="p">),</span> <span class="n">heading</span><span class="p">))</span> <span class="o">=</span> <span class="n">queue</span><span class="nf">.pop</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">deltas</span><span class="p">:</span> <span class="o">&amp;</span><span class="p">[</span><span class="nb">u8</span><span class="p">]</span> <span class="o">=</span> <span class="k">match</span> <span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">col</span> <span class="o">+</span> <span class="n">row</span> <span class="o">*</span> <span class="p">(</span><span class="n">w</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)],</span> <span class="n">heading</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
            <span class="p">(</span><span class="sc">b'.'</span><span class="p">,</span> <span class="n">_</span><span class="p">)</span> <span class="p">|</span> <span class="p">(</span><span class="sc">b'-'</span><span class="p">,</span> <span class="n">EAST_WEST</span><span class="p">)</span> <span class="p">|</span> <span class="p">(</span><span class="sc">b'|'</span><span class="p">,</span> <span class="n">NORTH_SOUTH</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="o">&amp;</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="c1">// pass-through</span>
            <span class="p">(</span><span class="sc">b'-'</span><span class="p">,</span> <span class="n">_</span><span class="p">)</span> <span class="p">|</span> <span class="p">(</span><span class="sc">b'|'</span><span class="p">,</span> <span class="n">_</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="o">&amp;</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span>                            <span class="c1">// split, turn left &amp; right</span>
            <span class="p">(</span><span class="sc">b'/'</span><span class="p">,</span> <span class="n">EAST_WEST</span><span class="p">)</span> <span class="p">|</span> <span class="p">(</span><span class="sc">b'\\'</span><span class="p">,</span> <span class="n">NORTH_SOUTH</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="o">&amp;</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>            <span class="c1">// turn left</span>
            <span class="p">(</span><span class="sc">b'\\'</span><span class="p">,</span> <span class="n">EAST_WEST</span><span class="p">)</span> <span class="p">|</span> <span class="p">(</span><span class="sc">b'/'</span><span class="p">,</span> <span class="n">NORTH_SOUTH</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="o">&amp;</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span>            <span class="c1">// turn right</span>
            <span class="n">_</span> <span class="k">=&gt;</span> <span class="nd">panic!</span><span class="p">(),</span>
        <span class="p">};</span>

        <span class="k">for</span> <span class="n">delta</span> <span class="k">in</span> <span class="n">deltas</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">heading</span> <span class="o">=</span> <span class="p">(</span><span class="n">heading</span> <span class="o">+</span> <span class="n">delta</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">3</span><span class="p">;</span>
            <span class="k">let</span> <span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="n">row</span><span class="p">)</span> <span class="o">=</span> <span class="k">match</span> <span class="n">heading</span> <span class="p">{</span>
                <span class="n">EAST</span> <span class="k">=&gt;</span> <span class="p">(</span><span class="n">col</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">row</span><span class="p">),</span>
                <span class="n">NORTH</span> <span class="k">=&gt;</span> <span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="n">row</span><span class="nf">.wrapping_sub</span><span class="p">(</span><span class="mi">1</span><span class="p">)),</span>
                <span class="n">WEST</span> <span class="k">=&gt;</span> <span class="p">(</span><span class="n">col</span><span class="nf">.wrapping_sub</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">row</span><span class="p">),</span>
                <span class="n">SOUTH</span> <span class="k">=&gt;</span> <span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="n">row</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span>
                <span class="n">_</span> <span class="k">=&gt;</span> <span class="nd">panic!</span><span class="p">(),</span>
            <span class="p">};</span>
            <span class="k">if</span> <span class="n">col</span> <span class="o">&lt;</span> <span class="n">w</span> <span class="o">&amp;&amp;</span> <span class="n">row</span> <span class="o">&lt;</span> <span class="n">h</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">seen</span><span class="p">[</span><span class="n">col</span> <span class="o">+</span> <span class="n">row</span> <span class="o">*</span> <span class="n">w</span><span class="p">]</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">heading</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
                <span class="n">seen</span><span class="p">[</span><span class="n">col</span> <span class="o">+</span> <span class="n">row</span> <span class="o">*</span> <span class="n">w</span><span class="p">]</span> <span class="p">|</span><span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">heading</span><span class="p">;</span>
                <span class="n">queue</span><span class="nf">.push</span><span class="p">(((</span><span class="n">col</span><span class="p">,</span> <span class="n">row</span><span class="p">),</span> <span class="n">heading</span><span class="p">));</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">seen</span><span class="nf">.into_iter</span><span class="p">()</span><span class="nf">.filter</span><span class="p">(|</span><span class="o">&amp;</span><span class="n">v</span><span class="p">|</span> <span class="n">v</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span><span class="nf">.count</span><span class="p">()</span>
<span class="p">}</span>

<span class="k">pub</span> <span class="k">fn</span> <span class="nf">star_1</span><span class="p">(</span><span class="o">&amp;</span><span class="nf">PuzzleData</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">h</span><span class="p">):</span> <span class="o">&amp;</span><span class="n">PuzzleData</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
    <span class="nf">count_energized</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">h</span><span class="p">),</span> <span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">EAST</span><span class="p">))</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_star_2_18">Star 2</h3>
<div class="paragraph">
<p>I did not have a good idea to implement anything but linear search. And, looking at the time it takes to count energized tiles for one starting position/heading, linear search is good enough.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
</pre></td><td class="code"><pre><span class="k">pub</span> <span class="k">fn</span> <span class="nf">star_2</span><span class="p">(</span><span class="o">&amp;</span><span class="nf">PuzzleData</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">h</span><span class="p">):</span> <span class="o">&amp;</span><span class="n">PuzzleData</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
    <span class="p">(</span><span class="mi">0</span><span class="o">..</span><span class="n">w</span><span class="p">)</span>
        <span class="nf">.map</span><span class="p">(|</span><span class="n">col</span><span class="p">|</span> <span class="p">((</span><span class="n">col</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">SOUTH</span><span class="p">))</span>
        <span class="nf">.chain</span><span class="p">((</span><span class="mi">0</span><span class="o">..</span><span class="n">h</span><span class="p">)</span><span class="nf">.map</span><span class="p">(|</span><span class="n">row</span><span class="p">|</span> <span class="p">((</span><span class="n">w</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">row</span><span class="p">),</span> <span class="n">WEST</span><span class="p">)))</span>
        <span class="nf">.chain</span><span class="p">((</span><span class="mi">0</span><span class="o">..</span><span class="n">w</span><span class="p">)</span><span class="nf">.map</span><span class="p">(|</span><span class="n">col_inv</span><span class="p">|</span> <span class="p">((</span><span class="n">w</span> <span class="o">-</span> <span class="n">col_inv</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">h</span> <span class="o">-</span> <span class="mi">1</span><span class="p">),</span> <span class="n">NORTH</span><span class="p">)))</span>
        <span class="nf">.chain</span><span class="p">((</span><span class="mi">0</span><span class="o">..</span><span class="n">h</span><span class="p">)</span><span class="nf">.map</span><span class="p">(|</span><span class="n">row_inv</span><span class="p">|</span> <span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="n">h</span> <span class="o">-</span> <span class="n">row_inv</span> <span class="o">-</span> <span class="mi">1</span><span class="p">),</span> <span class="n">EAST</span><span class="p">)))</span>
        <span class="nf">.map</span><span class="p">(|</span><span class="n">start</span><span class="p">|</span> <span class="nf">count_energized</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">h</span><span class="p">),</span> <span class="n">start</span><span class="p">))</span>
        <span class="nf">.max</span><span class="p">()</span>
        <span class="nf">.unwrap</span><span class="p">()</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_tests_16">Tests</h3>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
</pre></td><td class="code"><pre><span class="nd">#[cfg(test)]</span>
<span class="k">mod</span> <span class="n">tests</span> <span class="p">{</span>
    <span class="k">use</span> <span class="k">super</span><span class="p">::</span><span class="o">*</span><span class="p">;</span>

    <span class="k">const</span> <span class="n">CONTENT</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span> <span class="o">=</span> <span class="s">r#".|...\....
|.-.\.....
.....|-...
........|.
..........
.........\
..../.\\..
.-.-/..|..
.|....-|.\
..//.|....
"#</span><span class="p">;</span>

    <span class="nd">#[test]</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">test_from</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">let</span> <span class="nf">PuzzleData</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">h</span><span class="p">)</span> <span class="o">=</span> <span class="nn">PuzzleData</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="n">CONTENT</span><span class="p">);</span>
        <span class="nd">assert_eq!</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="n">w</span><span class="p">);</span>
        <span class="nd">assert_eq!</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="n">h</span><span class="p">);</span>
        <span class="nd">assert_eq!</span><span class="p">(</span><span class="mi">110</span><span class="p">,</span> <span class="n">data</span><span class="nf">.len</span><span class="p">());</span>
    <span class="p">}</span>

    <span class="nd">#[test]</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">test_star_1</span><span class="p">()</span> <span class="p">{</span>
        <span class="nd">assert_eq!</span><span class="p">(</span><span class="mi">46</span><span class="p">,</span> <span class="nf">star_1</span><span class="p">(</span><span class="o">&amp;</span><span class="n">CONTENT</span><span class="nf">.into</span><span class="p">()));</span>
    <span class="p">}</span>

    <span class="nd">#[test]</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">test_star_2</span><span class="p">()</span> <span class="p">{</span>
        <span class="nd">assert_eq!</span><span class="p">(</span><span class="mi">51</span><span class="p">,</span> <span class="nf">star_2</span><span class="p">(</span><span class="o">&amp;</span><span class="n">CONTENT</span><span class="nf">.into</span><span class="p">()));</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p><a href="#top">Top</a></p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="sol-rust-17">Rust | Day 17: Clumsy Crucible</h2>
<div class="sectionbody">
<div class="paragraph">
<p><a href="https://rust-lang.org">Rust</a> solution to <a href="https://adventofcode.com/2023/day/17">AoC|2023|17</a>.</p>
</div>
<div class="sect2">
<h3 id="_input_14">Input</h3>
<div class="paragraph">
<p>Another grid with width and height.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
</pre></td><td class="code"><pre><span class="k">pub</span> <span class="k">mod</span> <span class="n">input</span> <span class="p">{</span>
    <span class="nd">#[derive(Debug)]</span>
    <span class="k">pub</span> <span class="k">struct</span> <span class="n">PuzzleData</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span><span class="p">(</span><span class="k">pub</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="p">[</span><span class="nb">u8</span><span class="p">],</span> <span class="k">pub</span> <span class="nb">usize</span><span class="p">,</span> <span class="k">pub</span> <span class="nb">usize</span><span class="p">);</span>

    <span class="k">impl</span><span class="o">&lt;</span><span class="nv">'a</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="nb">From</span><span class="o">&lt;&amp;</span><span class="nv">'a</span> <span class="n">T</span><span class="o">&gt;</span> <span class="k">for</span> <span class="n">PuzzleData</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span>
    <span class="k">where</span>
        <span class="n">T</span><span class="p">:</span> <span class="nb">AsRef</span><span class="o">&lt;</span><span class="p">[</span><span class="nb">u8</span><span class="p">]</span><span class="o">&gt;</span> <span class="o">+</span> <span class="nv">'a</span> <span class="o">+</span> <span class="o">?</span><span class="nb">Sized</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="k">fn</span> <span class="nf">from</span><span class="p">(</span><span class="n">s</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="n">T</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">data</span> <span class="o">=</span> <span class="n">s</span><span class="nf">.as_ref</span><span class="p">();</span>
            <span class="k">let</span> <span class="n">w</span> <span class="o">=</span> <span class="n">data</span><span class="nf">.iter</span><span class="p">()</span><span class="nf">.position</span><span class="p">(|</span><span class="n">b</span><span class="p">|</span> <span class="n">b</span> <span class="o">==</span> <span class="o">&amp;</span><span class="sc">b'\n'</span><span class="p">)</span><span class="nf">.unwrap_or</span><span class="p">(</span><span class="n">data</span><span class="nf">.len</span><span class="p">());</span>
            <span class="k">let</span> <span class="n">h</span> <span class="o">=</span> <span class="p">(</span><span class="n">data</span><span class="nf">.len</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">w</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
            <span class="k">Self</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">h</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_stars_1_2">Stars 1 &amp; 2</h3>
<div class="paragraph">
<p>It is time for Dijkstra and A*!</p>
</div>
<div class="paragraph">
<p>We need to navigate crucibles on a path that minimizes heat loss. each block of the grid has a heat loss associated to it. The specialty of the problem is that the crucible is constrained in its movement: it needs to advance a minimum number straight before it stops or changes direction and it must not move more than a maximum number of blocks in a straight line before it changes direction.</p>
</div>
<div class="paragraph">
<p>Obviously, we cannot just take the location on the map as the graph&#8217;s nodes. There is at least two ways to model the graph for the problem:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Nodes are defined by location, current heading, and steps since last change of heading; any node that can be reached by by changing direction (if allowed) and moving the minimum number of steps or moving 1 step in the same direction (if allowed) is an adjacent</p>
</li>
<li>
<p>Nodes are defined by location and current heading; any node that can be reached by changing direction and moving any valid number of steps is an adjacent</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>I came up with the first variant myself and found out about the second variant reading about solution ideas of others.</p>
</div>
<div class="paragraph">
<p>Since the number of steps since the last change of heading is part of a node&#8217;s description in the first variant, there is a single unique predecessor for every node in the graph. This implies that we will never reach a node with any lower cost then the cost assigned to it when we first reached it. We can thus use a simplified version of Dijkstra, where nodes are settled upon expansion, instead of only settling nodes when they are popped from the queue.</p>
</div>
<div class="paragraph">
<p>The second variant has a much smaller search space (allowing for a Dijkstra implementation without sets or maps), since the number of steps is not included. However, we will in general reach the same node several times and the cost is not guaranteed to be the lowest the first time. As an example, consider the situation below, where the node on the top-right is first reached from x with a cost of 43. Only after the nodes labeled with the weights [11] and [15] are expanded, the same node is reached a second time with a cost of 27 &lt; 43.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code>       (7)    (43)
        v       v
X 2 2 2 1 9 9 9 9 &lt; [27]
        1       1
        1       1
        1       1
 [11] &gt; 1 1 1 1 1 &lt; [15]</code></pre>
</div>
</div>
<div class="paragraph">
<p>As a lower bound for the cost to go, I use the minimum cost that would be possible without any constraints on changing direction. This is calculated in <code>loss_bounds</code>. This A* heuristic reduced the runtime quite a bit. The heuristic is on by default. It can be switched off with the feature <code>no-heuristic</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
</pre></td><td class="code"><pre><span class="nd">#[cfg(not(feature</span> <span class="nd">=</span> <span class="s">"no-heuristic"</span><span class="nd">))]</span>
<span class="k">fn</span> <span class="nf">loss_bounds</span><span class="p">(</span><span class="n">grid</span><span class="p">:</span> <span class="o">&amp;</span><span class="p">[</span><span class="nb">u8</span><span class="p">],</span> <span class="n">w</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span> <span class="n">h</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">SolT</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">collections</span><span class="p">::</span><span class="n">BinaryHeap</span><span class="p">;</span>

    <span class="k">let</span> <span class="n">target</span> <span class="o">=</span> <span class="p">(</span><span class="n">w</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">h</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">bounds</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[</span><span class="nn">SolT</span><span class="p">::</span><span class="n">MAX</span><span class="p">;</span> <span class="n">w</span> <span class="o">*</span> <span class="n">h</span><span class="p">];</span>
    <span class="n">bounds</span><span class="p">[</span><span class="n">w</span> <span class="o">*</span> <span class="n">h</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="c1">// queue is a max heap! Need to inverse cost.</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">queue</span> <span class="o">=</span>
        <span class="nn">BinaryHeap</span><span class="p">::</span><span class="nf">from</span><span class="p">([(</span><span class="nn">SolT</span><span class="p">::</span><span class="n">MAX</span> <span class="o">-</span> <span class="p">(</span><span class="n">grid</span><span class="p">[(</span><span class="n">w</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">h</span> <span class="o">-</span> <span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="sc">b'0'</span><span class="p">)</span> <span class="k">as</span> <span class="n">SolT</span><span class="p">,</span> <span class="n">target</span><span class="p">)]);</span>
    <span class="k">while</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">((</span><span class="n">cost_0</span><span class="p">,</span> <span class="p">(</span><span class="n">c0</span><span class="p">,</span> <span class="n">r0</span><span class="p">)))</span> <span class="o">=</span> <span class="n">queue</span><span class="nf">.pop</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">c1</span><span class="p">,</span> <span class="n">r1</span><span class="p">)</span> <span class="k">in</span> <span class="n">D</span>
            <span class="nf">.map</span><span class="p">(|(</span><span class="n">dc</span><span class="p">,</span> <span class="n">dr</span><span class="p">)|</span> <span class="p">(</span><span class="n">c0</span><span class="nf">.wrapping_add_signed</span><span class="p">(</span><span class="n">dc</span><span class="p">),</span> <span class="n">r0</span><span class="nf">.wrapping_add_signed</span><span class="p">(</span><span class="n">dr</span><span class="p">)))</span>
            <span class="nf">.into_iter</span><span class="p">()</span>
            <span class="nf">.filter</span><span class="p">(|</span><span class="o">&amp;</span><span class="p">(</span><span class="n">c1</span><span class="p">,</span> <span class="n">r1</span><span class="p">)|</span> <span class="n">c1</span> <span class="o">&lt;</span> <span class="n">w</span> <span class="o">&amp;&amp;</span> <span class="n">r1</span> <span class="o">&lt;</span> <span class="n">h</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="c1">// settle value; this is safe because the cost adder to reach a node</span>
            <span class="c1">// is the same no matter from which neighbor we reach the node</span>
            <span class="k">let</span> <span class="n">r</span> <span class="o">=</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">bounds</span><span class="p">[</span><span class="n">c1</span> <span class="o">+</span> <span class="n">r1</span> <span class="o">*</span> <span class="n">w</span><span class="p">];</span>
            <span class="k">if</span> <span class="o">*</span><span class="n">r</span> <span class="o">==</span> <span class="nn">SolT</span><span class="p">::</span><span class="n">MAX</span> <span class="p">{</span>
                <span class="o">*</span><span class="n">r</span> <span class="o">=</span> <span class="nn">SolT</span><span class="p">::</span><span class="n">MAX</span> <span class="o">-</span> <span class="n">cost_0</span><span class="p">;</span>
                <span class="n">queue</span><span class="nf">.push</span><span class="p">((</span><span class="n">cost_0</span> <span class="o">-</span> <span class="p">(</span><span class="n">grid</span><span class="p">[</span><span class="n">c1</span> <span class="o">+</span> <span class="n">r1</span> <span class="o">*</span> <span class="p">(</span><span class="n">w</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span> <span class="o">-</span> <span class="sc">b'0'</span><span class="p">)</span> <span class="k">as</span> <span class="n">SolT</span><span class="p">,</span> <span class="p">(</span><span class="n">c1</span><span class="p">,</span> <span class="n">r1</span><span class="p">)))</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">bounds</span>
<span class="p">}</span>

<span class="nd">#[cfg(not(feature</span> <span class="nd">=</span> <span class="s">"no-heuristic"</span><span class="nd">))]</span>
<span class="k">fn</span> <span class="nf">loss_bounds_heuristic</span><span class="p">(</span><span class="n">grid</span><span class="p">:</span> <span class="o">&amp;</span><span class="p">[</span><span class="nb">u8</span><span class="p">],</span> <span class="n">w</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span> <span class="n">h</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">impl</span> <span class="nf">Fn</span><span class="p">((</span><span class="nb">usize</span><span class="p">,</span> <span class="nb">usize</span><span class="p">))</span> <span class="k">-&gt;</span> <span class="n">SolT</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">bounds</span> <span class="o">=</span> <span class="nf">loss_bounds</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">h</span><span class="p">);</span>
    <span class="k">move</span> <span class="p">|(</span><span class="n">col</span><span class="p">,</span> <span class="n">row</span><span class="p">)|</span> <span class="n">bounds</span><span class="p">[</span><span class="n">col</span> <span class="o">+</span> <span class="n">row</span> <span class="o">*</span> <span class="n">w</span><span class="p">]</span>
<span class="p">}</span>

<span class="nd">#[cfg(feature</span> <span class="nd">=</span> <span class="s">"no-heuristic"</span><span class="nd">)]</span>
<span class="k">fn</span> <span class="nf">loss_bounds_heuristic</span><span class="p">(</span><span class="n">_</span><span class="p">:</span> <span class="o">&amp;</span><span class="p">[</span><span class="nb">u8</span><span class="p">],</span> <span class="n">_</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span> <span class="n">_</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">impl</span> <span class="nf">Fn</span><span class="p">((</span><span class="nb">usize</span><span class="p">,</span> <span class="nb">usize</span><span class="p">))</span> <span class="k">-&gt;</span> <span class="n">SolT</span> <span class="p">{</span>
    <span class="p">|</span><span class="n">_</span><span class="p">|</span> <span class="mi">0</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>I implemented both variants. Since the second options requires less run-time, I chose this as default. The first variant can be chosen using feature <code>settle-early</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
</pre></td><td class="code"><pre><span class="nd">#[cfg(feature</span> <span class="nd">=</span> <span class="s">"settle-early"</span><span class="nd">)]</span>
<span class="k">pub</span> <span class="k">fn</span> <span class="nf">optimize</span><span class="p">(</span><span class="n">grid</span><span class="p">:</span> <span class="o">&amp;</span><span class="p">[</span><span class="nb">u8</span><span class="p">],</span> <span class="n">w</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span> <span class="n">h</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span> <span class="n">s_max</span><span class="p">:</span> <span class="nb">u8</span><span class="p">,</span> <span class="n">s_min</span><span class="p">:</span> <span class="nb">u8</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">SolT</span> <span class="p">{</span>
    <span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">collections</span><span class="p">::{</span><span class="n">BinaryHeap</span><span class="p">,</span> <span class="n">HashSet</span><span class="p">};</span>
    <span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">iter</span><span class="p">::</span><span class="n">successors</span><span class="p">;</span>

    <span class="k">let</span> <span class="n">heuristic</span> <span class="o">=</span> <span class="nf">loss_bounds_heuristic</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">h</span><span class="p">);</span>

    <span class="k">let</span> <span class="n">start_cost</span> <span class="o">=</span> <span class="nf">heuristic</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>
    <span class="k">let</span> <span class="n">starts</span><span class="p">:</span> <span class="p">[(</span><span class="nb">usize</span><span class="p">,</span> <span class="n">NodeT</span><span class="p">);</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span>
        <span class="p">(</span><span class="n">start_cost</span><span class="p">,</span> <span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">s_max</span><span class="p">))),</span>
        <span class="p">(</span><span class="n">start_cost</span><span class="p">,</span> <span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">s_max</span><span class="p">))),</span>
    <span class="p">];</span>

    <span class="k">let</span> <span class="n">target_pos</span> <span class="o">=</span> <span class="p">(</span><span class="n">w</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">h</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>

    <span class="k">let</span> <span class="k">mut</span> <span class="n">queue</span> <span class="o">=</span> <span class="nn">BinaryHeap</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">seen</span> <span class="o">=</span> <span class="nn">HashSet</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">cost</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span> <span class="k">in</span> <span class="n">starts</span><span class="nf">.into_iter</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">queue</span><span class="nf">.push</span><span class="p">((</span><span class="nn">SolT</span><span class="p">::</span><span class="n">MAX</span> <span class="o">-</span> <span class="n">cost</span><span class="p">,</span> <span class="n">node</span><span class="p">));</span>
        <span class="n">seen</span><span class="nf">.insert</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="nd">#[cfg(feature</span> <span class="nd">=</span> <span class="s">"plot"</span><span class="nd">)]</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">parents</span> <span class="o">=</span> <span class="nn">HashMap</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>

    <span class="k">while</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">((</span><span class="n">cost_0</span><span class="p">,</span> <span class="p">((</span><span class="n">c0</span><span class="p">,</span> <span class="n">r0</span><span class="p">),</span> <span class="p">(</span><span class="n">hd0</span><span class="p">,</span> <span class="n">s0</span><span class="p">))))</span> <span class="o">=</span> <span class="n">queue</span><span class="nf">.pop</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">c0</span><span class="p">,</span> <span class="n">r0</span><span class="p">)</span> <span class="o">==</span> <span class="n">target_pos</span> <span class="p">{</span>
            <span class="nd">#[cfg(feature</span> <span class="nd">=</span> <span class="s">"plot"</span><span class="nd">)]</span>
            <span class="nd">println!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="nf">to_string</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="p">((</span><span class="n">c0</span><span class="p">,</span> <span class="n">r0</span><span class="p">),</span> <span class="p">(</span><span class="n">hd0</span><span class="p">,</span> <span class="n">s0</span><span class="p">)),</span> <span class="o">&amp;</span><span class="n">parents</span><span class="p">));</span>
            <span class="k">return</span> <span class="nn">SolT</span><span class="p">::</span><span class="n">MAX</span> <span class="o">-</span> <span class="n">cost_0</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">let</span> <span class="n">dhs</span><span class="p">:</span> <span class="o">&amp;</span><span class="p">[</span><span class="nb">u8</span><span class="p">]</span> <span class="o">=</span> <span class="k">if</span> <span class="n">s0</span> <span class="o">&lt;</span> <span class="n">s_max</span> <span class="p">{</span> <span class="o">&amp;</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span> <span class="p">}</span> <span class="k">else</span> <span class="p">{</span> <span class="o">&amp;</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span> <span class="p">};</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">cost_1</span><span class="p">,</span> <span class="n">node_1</span><span class="p">)</span> <span class="k">in</span> <span class="n">dhs</span>
            <span class="nf">.iter</span><span class="p">()</span>
            <span class="nf">.map</span><span class="p">(</span><span class="k">move</span> <span class="p">|</span><span class="o">&amp;</span><span class="n">dh</span><span class="p">|</span> <span class="p">((</span><span class="n">hd0</span> <span class="o">+</span> <span class="n">dh</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">3</span><span class="p">,</span> <span class="k">if</span> <span class="n">dh</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span> <span class="n">s0</span> <span class="p">}</span> <span class="k">else</span> <span class="p">{</span> <span class="mi">0</span> <span class="p">}))</span>
            <span class="nf">.filter_map</span><span class="p">(|(</span><span class="n">hd1</span><span class="p">,</span> <span class="n">s1</span><span class="p">)|</span> <span class="p">{</span>
                <span class="c1">// move one step or enough to complete s_min, whatever is more</span>
                <span class="k">let</span> <span class="n">to_go</span> <span class="o">=</span> <span class="mi">1</span><span class="nf">.max</span><span class="p">(</span><span class="n">s_min</span> <span class="o">-</span> <span class="n">s1</span><span class="nf">.min</span><span class="p">(</span><span class="n">s_min</span><span class="p">));</span>
                <span class="k">let</span> <span class="p">(</span><span class="n">dc</span><span class="p">,</span> <span class="n">dr</span><span class="p">)</span> <span class="o">=</span> <span class="n">D</span><span class="p">[</span><span class="n">hd1</span> <span class="k">as</span> <span class="nb">usize</span><span class="p">];</span>
                <span class="nf">successors</span><span class="p">(</span><span class="nf">Some</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="n">c0</span><span class="p">,</span> <span class="n">r0</span><span class="p">)),</span> <span class="p">|(</span><span class="n">weight</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">r</span><span class="p">)|</span> <span class="p">{</span>
                    <span class="c1">// return Some - summing weights - while in bounds</span>
                    <span class="k">let</span> <span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="n">c</span><span class="nf">.wrapping_add_signed</span><span class="p">(</span><span class="n">dc</span><span class="p">),</span> <span class="n">r</span><span class="nf">.wrapping_add_signed</span><span class="p">(</span><span class="n">dr</span><span class="p">));</span>
                    <span class="p">(</span><span class="n">c</span> <span class="o">&lt;</span> <span class="n">w</span> <span class="o">&amp;&amp;</span> <span class="n">r</span> <span class="o">&lt;</span> <span class="n">h</span><span class="p">)</span>
                        <span class="nf">.then</span><span class="p">(||</span> <span class="p">(</span><span class="n">weight</span> <span class="o">+</span> <span class="p">(</span><span class="n">grid</span><span class="p">[</span><span class="n">c</span> <span class="o">+</span> <span class="n">r</span> <span class="o">*</span> <span class="p">(</span><span class="n">w</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span> <span class="o">-</span> <span class="sc">b'0'</span><span class="p">)</span> <span class="k">as</span> <span class="n">SolT</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">r</span><span class="p">))</span>
                <span class="p">})</span>
                <span class="nf">.nth</span><span class="p">(</span><span class="n">to_go</span> <span class="k">as</span> <span class="n">_</span><span class="p">)</span>
                <span class="nf">.map</span><span class="p">(|(</span><span class="n">weight</span><span class="p">,</span> <span class="n">c1</span><span class="p">,</span> <span class="n">r1</span><span class="p">)|</span> <span class="p">{</span>
                    <span class="p">(</span>
                        <span class="n">cost_0</span> <span class="o">-</span> <span class="n">weight</span> <span class="o">+</span> <span class="nf">heuristic</span><span class="p">((</span><span class="n">c0</span><span class="p">,</span> <span class="n">r0</span><span class="p">))</span> <span class="o">-</span> <span class="nf">heuristic</span><span class="p">((</span><span class="n">c1</span><span class="p">,</span> <span class="n">r1</span><span class="p">)),</span>
                        <span class="p">((</span><span class="n">c1</span><span class="p">,</span> <span class="n">r1</span><span class="p">),</span> <span class="p">(</span><span class="n">hd1</span><span class="p">,</span> <span class="n">s1</span> <span class="o">+</span> <span class="n">to_go</span><span class="p">)),</span>
                    <span class="p">)</span>
                <span class="p">})</span>
            <span class="p">})</span>
        <span class="p">{</span>
            <span class="k">if</span> <span class="n">seen</span><span class="nf">.insert</span><span class="p">(</span><span class="n">node_1</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">queue</span><span class="nf">.push</span><span class="p">((</span><span class="n">cost_1</span><span class="p">,</span> <span class="n">node_1</span><span class="p">));</span>
                <span class="nd">#[cfg(feature</span> <span class="nd">=</span> <span class="s">"plot"</span><span class="nd">)]</span>
                <span class="n">parents</span><span class="nf">.insert</span><span class="p">(</span><span class="n">node_1</span><span class="p">,</span> <span class="p">((</span><span class="n">c0</span><span class="p">,</span> <span class="n">r0</span><span class="p">),</span> <span class="p">(</span><span class="n">hd0</span><span class="p">,</span> <span class="n">s0</span><span class="p">)));</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="nd">panic!</span><span class="p">(</span><span class="s">"No solution found."</span><span class="p">)</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
</pre></td><td class="code"><pre><span class="nd">#[cfg(not(feature</span> <span class="nd">=</span> <span class="s">"settle-early"</span><span class="nd">))]</span>
<span class="k">pub</span> <span class="k">fn</span> <span class="nf">optimize</span><span class="p">(</span><span class="n">grid</span><span class="p">:</span> <span class="o">&amp;</span><span class="p">[</span><span class="nb">u8</span><span class="p">],</span> <span class="n">w</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span> <span class="n">h</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span> <span class="n">s_max</span><span class="p">:</span> <span class="nb">u8</span><span class="p">,</span> <span class="n">s_min</span><span class="p">:</span> <span class="nb">u8</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">SolT</span> <span class="p">{</span>
    <span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">collections</span><span class="p">::</span><span class="n">BinaryHeap</span><span class="p">;</span>
    <span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">iter</span><span class="p">::</span><span class="n">successors</span><span class="p">;</span>

    <span class="k">let</span> <span class="n">heuristic</span> <span class="o">=</span> <span class="o">&amp;</span><span class="nf">loss_bounds_heuristic</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">h</span><span class="p">);</span>

    <span class="k">let</span> <span class="n">start_cost</span> <span class="o">=</span> <span class="nn">SolT</span><span class="p">::</span><span class="n">MAX</span> <span class="o">-</span> <span class="nf">heuristic</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>
    <span class="k">let</span> <span class="n">starts</span><span class="p">:</span> <span class="p">[(</span><span class="nb">usize</span><span class="p">,</span> <span class="n">NodeT</span><span class="p">);</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">[(</span><span class="n">start_cost</span><span class="p">,</span> <span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="mi">0</span><span class="p">)),</span> <span class="p">(</span><span class="n">start_cost</span><span class="p">,</span> <span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="mi">3</span><span class="p">))];</span>

    <span class="k">let</span> <span class="n">target_pos</span> <span class="o">=</span> <span class="p">(</span><span class="n">w</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">h</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>

    <span class="k">let</span> <span class="k">mut</span> <span class="n">queue</span> <span class="o">=</span> <span class="nn">BinaryHeap</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">settled</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[</span><span class="mi">0u8</span><span class="p">;</span> <span class="n">w</span> <span class="o">*</span> <span class="n">h</span><span class="p">];</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">costs</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[</span><span class="mi">0</span><span class="p">;</span> <span class="n">w</span> <span class="o">*</span> <span class="n">h</span> <span class="o">*</span> <span class="mi">4</span><span class="p">];</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">cost</span><span class="p">,</span> <span class="p">((</span><span class="n">c</span><span class="p">,</span> <span class="n">r</span><span class="p">),</span> <span class="n">hd</span><span class="p">))</span> <span class="k">in</span> <span class="n">starts</span><span class="nf">.into_iter</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">queue</span><span class="nf">.push</span><span class="p">((</span><span class="n">cost</span><span class="p">,</span> <span class="p">((</span><span class="n">c</span><span class="p">,</span> <span class="n">r</span><span class="p">),</span> <span class="n">hd</span><span class="p">)));</span>
        <span class="n">costs</span><span class="p">[</span><span class="n">c</span> <span class="o">+</span> <span class="n">r</span> <span class="o">*</span> <span class="n">w</span> <span class="o">+</span> <span class="p">(</span><span class="n">hd</span> <span class="k">as</span> <span class="nb">usize</span><span class="p">)</span> <span class="o">*</span> <span class="n">w</span> <span class="o">*</span> <span class="n">h</span><span class="p">]</span> <span class="o">=</span> <span class="n">cost</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="nd">#[cfg(feature</span> <span class="nd">=</span> <span class="s">"plot"</span><span class="nd">)]</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">parents</span> <span class="o">=</span> <span class="nn">HashMap</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>

    <span class="k">while</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">((</span><span class="n">cost_0</span><span class="p">,</span> <span class="p">((</span><span class="n">c0</span><span class="p">,</span> <span class="n">r0</span><span class="p">),</span> <span class="n">hd0</span><span class="p">)))</span> <span class="o">=</span> <span class="n">queue</span><span class="nf">.pop</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">c0</span><span class="p">,</span> <span class="n">r0</span><span class="p">)</span> <span class="o">==</span> <span class="n">target_pos</span> <span class="p">{</span>
            <span class="nd">#[cfg(feature</span> <span class="nd">=</span> <span class="s">"plot"</span><span class="nd">)]</span>
            <span class="nd">println!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="nf">to_string</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="p">((</span><span class="n">c0</span><span class="p">,</span> <span class="n">r0</span><span class="p">),</span> <span class="n">hd0</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">settled</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">parents</span><span class="p">));</span>
            <span class="k">return</span> <span class="nn">SolT</span><span class="p">::</span><span class="n">MAX</span> <span class="o">-</span> <span class="n">cost_0</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="n">settled</span><span class="p">[</span><span class="n">c0</span> <span class="o">+</span> <span class="n">r0</span> <span class="o">*</span> <span class="n">w</span><span class="p">]</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">hd0</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
            <span class="n">settled</span><span class="p">[</span><span class="n">c0</span> <span class="o">+</span> <span class="n">r0</span> <span class="o">*</span> <span class="n">w</span><span class="p">]</span> <span class="p">|</span><span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">hd0</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="k">continue</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">for</span> <span class="p">(</span><span class="n">cost_1</span><span class="p">,</span> <span class="p">((</span><span class="n">c1</span><span class="p">,</span> <span class="n">r1</span><span class="p">),</span> <span class="n">hd1</span><span class="p">))</span> <span class="k">in</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
            <span class="nf">.iter</span><span class="p">()</span>
            <span class="nf">.map</span><span class="p">(</span><span class="k">move</span> <span class="p">|</span><span class="o">&amp;</span><span class="n">dh</span><span class="p">|</span> <span class="p">(</span><span class="n">hd0</span> <span class="o">+</span> <span class="n">dh</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">3</span><span class="p">)</span>
            <span class="nf">.flat_map</span><span class="p">(|</span><span class="n">hd1</span><span class="p">|</span> <span class="p">{</span>
                <span class="k">let</span> <span class="p">(</span><span class="n">dc</span><span class="p">,</span> <span class="n">dr</span><span class="p">)</span> <span class="o">=</span> <span class="n">D</span><span class="p">[</span><span class="n">hd1</span> <span class="k">as</span> <span class="nb">usize</span><span class="p">];</span>
                <span class="nf">successors</span><span class="p">(</span><span class="nf">Some</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="n">c0</span><span class="p">,</span> <span class="n">r0</span><span class="p">)),</span> <span class="k">move</span> <span class="p">|(</span><span class="n">weight</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">r</span><span class="p">)|</span> <span class="p">{</span>
                    <span class="k">let</span> <span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="n">c</span><span class="nf">.wrapping_add_signed</span><span class="p">(</span><span class="n">dc</span><span class="p">),</span> <span class="n">r</span><span class="nf">.wrapping_add_signed</span><span class="p">(</span><span class="n">dr</span><span class="p">));</span>
                    <span class="p">(</span><span class="n">c</span> <span class="o">&lt;</span> <span class="n">w</span> <span class="o">&amp;&amp;</span> <span class="n">r</span> <span class="o">&lt;</span> <span class="n">h</span><span class="p">)</span>
                        <span class="nf">.then</span><span class="p">(||</span> <span class="p">(</span><span class="n">weight</span> <span class="o">+</span> <span class="p">(</span><span class="n">grid</span><span class="p">[</span><span class="n">c</span> <span class="o">+</span> <span class="n">r</span> <span class="o">*</span> <span class="p">(</span><span class="n">w</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span> <span class="o">-</span> <span class="sc">b'0'</span><span class="p">)</span> <span class="k">as</span> <span class="n">SolT</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">r</span><span class="p">))</span>
                <span class="p">})</span>
                <span class="nf">.take</span><span class="p">(</span><span class="n">s_max</span> <span class="k">as</span> <span class="nb">usize</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
                <span class="nf">.skip</span><span class="p">(</span><span class="mi">1</span><span class="nf">.max</span><span class="p">(</span><span class="n">s_min</span> <span class="k">as</span> <span class="n">_</span><span class="p">))</span>
                <span class="nf">.map</span><span class="p">(</span><span class="k">move</span> <span class="p">|(</span><span class="n">weight</span><span class="p">,</span> <span class="n">c1</span><span class="p">,</span> <span class="n">r1</span><span class="p">)|</span> <span class="p">{</span>
                    <span class="p">(</span>
                        <span class="n">cost_0</span> <span class="o">-</span> <span class="n">weight</span> <span class="o">+</span> <span class="nf">heuristic</span><span class="p">((</span><span class="n">c0</span><span class="p">,</span> <span class="n">r0</span><span class="p">))</span> <span class="o">-</span> <span class="nf">heuristic</span><span class="p">((</span><span class="n">c1</span><span class="p">,</span> <span class="n">r1</span><span class="p">)),</span>
                        <span class="p">((</span><span class="n">c1</span><span class="p">,</span> <span class="n">r1</span><span class="p">),</span> <span class="n">hd1</span><span class="p">),</span>
                    <span class="p">)</span>
                <span class="p">})</span>
            <span class="p">})</span>
            <span class="nf">.filter</span><span class="p">(|(</span><span class="n">_</span><span class="p">,</span> <span class="p">((</span><span class="n">r1</span><span class="p">,</span> <span class="n">c1</span><span class="p">),</span> <span class="n">hd1</span><span class="p">))|</span> <span class="n">settled</span><span class="p">[</span><span class="n">r1</span> <span class="o">+</span> <span class="n">c1</span> <span class="o">*</span> <span class="n">w</span><span class="p">]</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">hd1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">let</span> <span class="n">cost_1_prev</span> <span class="o">=</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">costs</span><span class="p">[</span><span class="n">c1</span> <span class="o">+</span> <span class="n">r1</span> <span class="o">*</span> <span class="n">w</span> <span class="o">+</span> <span class="p">(</span><span class="n">hd1</span> <span class="k">as</span> <span class="nb">usize</span><span class="p">)</span> <span class="o">*</span> <span class="n">w</span> <span class="o">*</span> <span class="n">h</span><span class="p">];</span>
            <span class="k">if</span> <span class="n">cost_1</span> <span class="o">&gt;</span> <span class="o">*</span><span class="n">cost_1_prev</span> <span class="p">{</span>
                <span class="o">*</span><span class="n">cost_1_prev</span> <span class="o">=</span> <span class="n">cost_1</span><span class="p">;</span>
                <span class="n">queue</span><span class="nf">.push</span><span class="p">((</span><span class="n">cost_1</span><span class="p">,</span> <span class="p">((</span><span class="n">c1</span><span class="p">,</span> <span class="n">r1</span><span class="p">),</span> <span class="n">hd1</span><span class="p">)));</span>
                <span class="nd">#[cfg(feature</span> <span class="nd">=</span> <span class="s">"plot"</span><span class="nd">)]</span>
                <span class="n">parents</span><span class="nf">.insert</span><span class="p">(((</span><span class="n">c1</span><span class="p">,</span> <span class="n">r1</span><span class="p">),</span> <span class="n">hd1</span><span class="p">),</span> <span class="p">((</span><span class="n">c0</span><span class="p">,</span> <span class="n">r0</span><span class="p">),</span> <span class="n">hd0</span><span class="p">));</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="nd">panic!</span><span class="p">(</span><span class="s">"No solution found."</span><span class="p">)</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_tests_17">Tests</h3>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
</pre></td><td class="code"><pre><span class="nd">#[cfg(test)]</span>
<span class="k">mod</span> <span class="n">tests</span> <span class="p">{</span>
    <span class="k">use</span> <span class="k">super</span><span class="p">::</span><span class="o">*</span><span class="p">;</span>

    <span class="k">const</span> <span class="n">CONTENT</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span> <span class="o">=</span> <span class="s">r#"2413432311323
3215453535623
3255245654254
3446585845452
4546657867536
1438598798454
4457876987766
3637877979653
4654967986887
4564679986453
1224686865563
2546548887735
4322674655533
"#</span><span class="p">;</span>

    <span class="k">const</span> <span class="n">CONTENT_2</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span> <span class="o">=</span> <span class="s">r#"111111111111
999999999991
999999999991
999999999991
999999999991
"#</span><span class="p">;</span>

    <span class="nd">#[test]</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">test_from</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">let</span> <span class="nf">PuzzleData</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">h</span><span class="p">)</span> <span class="o">=</span> <span class="nn">PuzzleData</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="n">CONTENT</span><span class="p">);</span>
        <span class="nd">assert_eq!</span><span class="p">(</span><span class="mi">13</span><span class="p">,</span> <span class="n">w</span><span class="p">);</span>
        <span class="nd">assert_eq!</span><span class="p">(</span><span class="mi">13</span><span class="p">,</span> <span class="n">h</span><span class="p">);</span>
        <span class="nd">assert_eq!</span><span class="p">(</span><span class="mi">13</span> <span class="o">*</span> <span class="mi">14</span><span class="p">,</span> <span class="n">grid</span><span class="nf">.len</span><span class="p">());</span>
    <span class="p">}</span>

    <span class="nd">#[test]</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">test_star_1</span><span class="p">()</span> <span class="p">{</span>
        <span class="nd">assert_eq!</span><span class="p">(</span><span class="mi">102</span><span class="p">,</span> <span class="nf">star_1</span><span class="p">(</span><span class="o">&amp;</span><span class="n">CONTENT</span><span class="nf">.into</span><span class="p">()));</span>
    <span class="p">}</span>

    <span class="nd">#[test]</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">test_star_2</span><span class="p">()</span> <span class="p">{</span>
        <span class="nd">assert_eq!</span><span class="p">(</span><span class="mi">94</span><span class="p">,</span> <span class="nf">star_2</span><span class="p">(</span><span class="o">&amp;</span><span class="n">CONTENT</span><span class="nf">.into</span><span class="p">()));</span>
        <span class="nd">assert_eq!</span><span class="p">(</span><span class="mi">71</span><span class="p">,</span> <span class="nf">star_2</span><span class="p">(</span><span class="o">&amp;</span><span class="n">CONTENT_2</span><span class="nf">.into</span><span class="p">()));</span>
    <span class="p">}</span>

    <span class="nd">#[cfg(not(feature</span> <span class="nd">=</span> <span class="s">"no-heuristic"</span><span class="nd">))]</span>
    <span class="nd">#[test]</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">test_loss_bounds</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">let</span> <span class="nf">PuzzleData</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">h</span><span class="p">)</span> <span class="o">=</span> <span class="n">CONTENT_2</span><span class="nf">.into</span><span class="p">();</span>
        <span class="k">let</span> <span class="n">bounds</span> <span class="o">=</span> <span class="nf">loss_bounds</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">h</span><span class="p">);</span>
        <span class="k">for</span> <span class="n">row</span> <span class="k">in</span> <span class="mi">0</span><span class="o">..</span><span class="n">h</span> <span class="p">{</span>
            <span class="k">for</span> <span class="n">col</span> <span class="k">in</span> <span class="mi">0</span><span class="o">..</span><span class="n">w</span> <span class="p">{</span>
                <span class="nd">print!</span><span class="p">(</span><span class="s">"{:&gt;3}"</span><span class="p">,</span> <span class="n">bounds</span><span class="p">[</span><span class="n">col</span> <span class="o">+</span> <span class="n">row</span> <span class="o">*</span> <span class="n">w</span><span class="p">]);</span>
            <span class="p">}</span>
            <span class="nd">println!</span><span class="p">();</span>
        <span class="p">}</span>

        <span class="k">let</span> <span class="n">exp</span> <span class="o">=</span> <span class="p">[</span>
            <span class="p">[</span><span class="mi">15</span><span class="p">,</span> <span class="mi">14</span><span class="p">,</span> <span class="mi">13</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">09</span><span class="p">,</span> <span class="mi">08</span><span class="p">,</span> <span class="mi">07</span><span class="p">,</span> <span class="mi">06</span><span class="p">,</span> <span class="mi">05</span><span class="p">,</span> <span class="mi">04</span><span class="p">],</span>
            <span class="p">[</span><span class="mi">16</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">14</span><span class="p">,</span> <span class="mi">13</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">09</span><span class="p">,</span> <span class="mi">08</span><span class="p">,</span> <span class="mi">07</span><span class="p">,</span> <span class="mi">04</span><span class="p">,</span> <span class="mi">03</span><span class="p">],</span>
            <span class="p">[</span><span class="mi">25</span><span class="p">,</span> <span class="mi">24</span><span class="p">,</span> <span class="mi">23</span><span class="p">,</span> <span class="mi">22</span><span class="p">,</span> <span class="mi">21</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">19</span><span class="p">,</span> <span class="mi">18</span><span class="p">,</span> <span class="mi">17</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">03</span><span class="p">,</span> <span class="mi">02</span><span class="p">],</span>
            <span class="p">[</span><span class="mi">34</span><span class="p">,</span> <span class="mi">33</span><span class="p">,</span> <span class="mi">32</span><span class="p">,</span> <span class="mi">31</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">29</span><span class="p">,</span> <span class="mi">28</span><span class="p">,</span> <span class="mi">27</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">02</span><span class="p">,</span> <span class="mi">01</span><span class="p">],</span>
            <span class="p">[</span><span class="mi">43</span><span class="p">,</span> <span class="mi">42</span><span class="p">,</span> <span class="mi">41</span><span class="p">,</span> <span class="mi">40</span><span class="p">,</span> <span class="mi">39</span><span class="p">,</span> <span class="mi">38</span><span class="p">,</span> <span class="mi">37</span><span class="p">,</span> <span class="mi">28</span><span class="p">,</span> <span class="mi">19</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">01</span><span class="p">,</span> <span class="mi">00</span><span class="p">],</span>
        <span class="p">]</span>
        <span class="nf">.concat</span><span class="p">();</span>

        <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">exp</span><span class="p">,</span> <span class="n">bounds</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p><a href="#top">Top</a></p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="sol-rust-18">Rust | Day 18: Lavaduct Lagoon</h2>
<div class="sectionbody">
<div class="paragraph">
<p><a href="https://rust-lang.org">Rust</a> solution to <a href="https://adventofcode.com/2023/day/18">AoC|2023|18</a>.</p>
</div>
<div class="sect2">
<h3 id="_star_1_19">Star 1</h3>
<div class="paragraph">
<p>On 10, we already calculated the surface enclosed in a polygon. Back then I scanned the complete grid line by line.
Today, it is time for the <a href="https://en.wikipedia.org/wiki/Shoelace_formula">Shoelace formula</a>. I quickly looked at it already when solving day 10.</p>
</div>
<div class="paragraph">
<p>The only part that requires some thinking is how to account for the fact that the coordinates represent lines of width 1. The shoelace formula gives the area, that we would get if we had zero-width lines centered in the actual lines. So we have to add half of the number of elements on the perimeter. For the corners, if we walk across the perimeter clockwise, a right turn will contribute three quarters of a unit while a left turn will contribute one quarter of a unit. Since we end up at the origin, there must be a right turn for every left turn plus an additional four right turns. Hence, I need to add one unit.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
</pre></td><td class="code"><pre><span class="k">pub</span> <span class="k">fn</span> <span class="n">shoelace</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="n">F</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">SolT</span>
<span class="k">where</span>
    <span class="n">F</span><span class="p">:</span> <span class="nb">Iterator</span><span class="o">&lt;</span><span class="n">Item</span> <span class="o">=</span> <span class="p">(</span><span class="nb">u8</span><span class="p">,</span> <span class="n">SolT</span><span class="p">)</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">{</span>
    <span class="k">let</span> <span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span> <span class="o">=</span> <span class="n">data</span><span class="nf">.fold</span><span class="p">(((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">|((</span><span class="n">x0</span><span class="p">,</span> <span class="n">y0</span><span class="p">),</span> <span class="n">s</span><span class="p">,</span> <span class="n">p</span><span class="p">),</span> <span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">len</span><span class="p">)|</span> <span class="p">{</span>
        <span class="k">let</span> <span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">y1</span><span class="p">)</span> <span class="o">=</span> <span class="k">match</span> <span class="n">d</span> <span class="p">{</span>
            <span class="mi">0</span> <span class="k">=&gt;</span> <span class="p">(</span><span class="n">x0</span> <span class="o">+</span> <span class="n">len</span><span class="p">,</span> <span class="n">y0</span><span class="p">),</span>
            <span class="mi">1</span> <span class="k">=&gt;</span> <span class="p">(</span><span class="n">x0</span><span class="p">,</span> <span class="n">y0</span> <span class="o">+</span> <span class="n">len</span><span class="p">),</span>
            <span class="mi">2</span> <span class="k">=&gt;</span> <span class="p">(</span><span class="n">x0</span> <span class="o">-</span> <span class="n">len</span><span class="p">,</span> <span class="n">y0</span><span class="p">),</span>
            <span class="mi">3</span> <span class="k">=&gt;</span> <span class="p">(</span><span class="n">x0</span><span class="p">,</span> <span class="n">y0</span> <span class="o">-</span> <span class="n">len</span><span class="p">),</span>
            <span class="n">_</span> <span class="k">=&gt;</span> <span class="nd">unreachable!</span><span class="p">(),</span>
        <span class="p">};</span>
        <span class="p">(</span>
            <span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">y1</span><span class="p">),</span>
            <span class="n">s</span> <span class="o">+</span> <span class="p">(</span><span class="n">y0</span> <span class="o">+</span> <span class="n">y1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">x0</span> <span class="o">-</span> <span class="n">x1</span><span class="p">),</span>
            <span class="n">p</span> <span class="o">+</span> <span class="n">x0</span><span class="nf">.max</span><span class="p">(</span><span class="n">x1</span><span class="p">)</span> <span class="o">-</span> <span class="n">x0</span><span class="nf">.min</span><span class="p">(</span><span class="n">x1</span><span class="p">)</span> <span class="o">+</span> <span class="n">y0</span><span class="nf">.max</span><span class="p">(</span><span class="n">y1</span><span class="p">)</span> <span class="o">-</span> <span class="n">y0</span><span class="nf">.min</span><span class="p">(</span><span class="n">y1</span><span class="p">),</span>
        <span class="p">)</span>
    <span class="p">});</span>
    <span class="n">s</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">p</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span>
<span class="p">}</span>

<span class="k">pub</span> <span class="k">fn</span> <span class="nf">star_1</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="o">&amp;&amp;</span><span class="nb">str</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">SolT</span> <span class="p">{</span>
    <span class="nf">shoelace</span><span class="p">(</span><span class="n">data</span><span class="nf">.lines</span><span class="p">()</span><span class="nf">.map</span><span class="p">(|</span><span class="n">line</span><span class="p">|</span> <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">parts</span> <span class="o">=</span> <span class="n">line</span><span class="nf">.split_ascii_whitespace</span><span class="p">();</span>
        <span class="p">(</span>
            <span class="k">match</span> <span class="n">parts</span><span class="nf">.next</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">()</span> <span class="p">{</span>
                <span class="s">"R"</span> <span class="k">=&gt;</span> <span class="mi">0</span><span class="p">,</span>
                <span class="s">"D"</span> <span class="k">=&gt;</span> <span class="mi">1</span><span class="p">,</span>
                <span class="s">"L"</span> <span class="k">=&gt;</span> <span class="mi">2</span><span class="p">,</span>
                <span class="s">"U"</span> <span class="k">=&gt;</span> <span class="mi">3</span><span class="p">,</span>
                <span class="n">d</span> <span class="k">=&gt;</span> <span class="nd">panic!</span><span class="p">(</span><span class="s">"Illegal direction: {}"</span><span class="p">,</span> <span class="n">d</span><span class="p">),</span>
            <span class="p">},</span>
            <span class="n">parts</span><span class="nf">.next</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">()</span><span class="nf">.parse</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">(),</span>
        <span class="p">)</span>
    <span class="p">}))</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_star_2_19">Star 2</h3>
<div class="paragraph">
<p>Same as star 1.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre><span class="k">pub</span> <span class="k">fn</span> <span class="nf">star_2</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="o">&amp;&amp;</span><span class="nb">str</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">SolT</span> <span class="p">{</span>
    <span class="nf">shoelace</span><span class="p">(</span><span class="n">data</span><span class="nf">.lines</span><span class="p">()</span><span class="nf">.map</span><span class="p">(|</span><span class="n">line</span><span class="p">|</span> <span class="p">{</span>
        <span class="n">line</span><span class="nf">.split_ascii_whitespace</span><span class="p">()</span>
            <span class="nf">.nth</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
            <span class="nf">.and_then</span><span class="p">(|</span><span class="n">code</span><span class="p">|</span> <span class="nn">SolT</span><span class="p">::</span><span class="nf">from_str_radix</span><span class="p">(</span><span class="o">&amp;</span><span class="n">code</span><span class="p">[</span><span class="mi">2</span><span class="o">..</span><span class="n">code</span><span class="nf">.len</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="mi">16</span><span class="p">)</span><span class="nf">.ok</span><span class="p">())</span>
            <span class="nf">.map</span><span class="p">(|</span><span class="n">code</span><span class="p">|</span> <span class="p">((</span><span class="n">code</span> <span class="o">&amp;</span> <span class="mi">0xf</span><span class="p">)</span> <span class="k">as</span> <span class="n">_</span><span class="p">,</span> <span class="n">code</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">))</span>
            <span class="nf">.unwrap</span><span class="p">()</span>
    <span class="p">}))</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_tests_18">Tests</h3>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
</pre></td><td class="code"><pre><span class="nd">#[cfg(test)]</span>
<span class="k">mod</span> <span class="n">tests</span> <span class="p">{</span>
    <span class="k">use</span> <span class="k">super</span><span class="p">::</span><span class="o">*</span><span class="p">;</span>

    <span class="k">const</span> <span class="n">CONTENT</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span> <span class="o">=</span> <span class="s">r#"R 6 (#70c710)
D 5 (#0dc571)
L 2 (#5713f0)
D 2 (#d2c081)
R 2 (#59c680)
D 2 (#411b91)
L 5 (#8ceee2)
U 2 (#caa173)
L 1 (#1b58a2)
U 2 (#caa171)
R 2 (#7807d2)
U 3 (#a77fa3)
L 2 (#015232)
U 2 (#7a21e3)
"#</span><span class="p">;</span>

    <span class="nd">#[test]</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">test_star_1</span><span class="p">()</span> <span class="p">{</span>
        <span class="nd">assert_eq!</span><span class="p">(</span><span class="mi">62</span><span class="p">,</span> <span class="nf">star_1</span><span class="p">(</span><span class="o">&amp;</span><span class="n">CONTENT</span><span class="p">));</span>
    <span class="p">}</span>

    <span class="nd">#[test]</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">test_star_2</span><span class="p">()</span> <span class="p">{</span>
        <span class="nd">assert_eq!</span><span class="p">(</span><span class="mi">952_408_144_115</span><span class="p">,</span> <span class="nf">star_2</span><span class="p">(</span><span class="o">&amp;</span><span class="n">CONTENT</span><span class="p">));</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p><a href="#top">Top</a></p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="sol-rust-19">Rust | Day 19: Aplenty</h2>
<div class="sectionbody">
<div class="paragraph">
<p><a href="https://rust-lang.org">Rust</a> solution to <a href="https://adventofcode.com/2023/day/19">AoC|2023|19</a>.</p>
</div>
<div class="sect2">
<h3 id="_input_15">Input</h3>
<div class="paragraph">
<p>Input parsing was a bit tedious today. Maybe regex would have worked faster here, but I still only use standard library.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
</pre></td><td class="code"><pre><span class="k">pub</span> <span class="k">mod</span> <span class="n">input</span> <span class="p">{</span>
    <span class="k">use</span> <span class="nn">std</span><span class="p">::{</span><span class="nn">cmp</span><span class="p">::</span><span class="n">Ordering</span><span class="p">,</span> <span class="nn">collections</span><span class="p">::</span><span class="n">HashMap</span><span class="p">};</span>

    <span class="k">pub</span> <span class="k">type</span> <span class="n">ValT</span> <span class="o">=</span> <span class="nb">usize</span><span class="p">;</span>
    <span class="k">pub</span> <span class="k">type</span> <span class="n">RuleT</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span> <span class="o">=</span> <span class="p">(</span><span class="nb">Option</span><span class="o">&lt;</span><span class="p">(</span><span class="nb">usize</span><span class="p">,</span> <span class="n">Ordering</span><span class="p">,</span> <span class="n">ValT</span><span class="p">)</span><span class="o">&gt;</span><span class="p">,</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="nb">str</span><span class="p">);</span>
    <span class="k">pub</span> <span class="k">type</span> <span class="n">PartT</span> <span class="o">=</span> <span class="p">[</span><span class="n">ValT</span><span class="p">;</span> <span class="mi">4</span><span class="p">];</span>

    <span class="nd">#[derive(Debug)]</span>
    <span class="k">pub</span> <span class="k">struct</span> <span class="n">PuzzleData</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span><span class="p">(</span><span class="k">pub</span> <span class="n">HashMap</span><span class="o">&lt;&amp;</span><span class="nv">'a</span> <span class="nb">str</span><span class="p">,</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">RuleT</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;&gt;&gt;</span><span class="p">,</span> <span class="k">pub</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">PartT</span><span class="o">&gt;</span><span class="p">);</span>

    <span class="k">fn</span> <span class="nf">parse_rule</span><span class="p">(</span><span class="n">rule</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">RuleT</span> <span class="p">{</span>
        <span class="n">rule</span><span class="nf">.split_once</span><span class="p">(</span><span class="sc">':'</span><span class="p">)</span>
            <span class="nf">.map</span><span class="p">(|(</span><span class="n">cond</span><span class="p">,</span> <span class="n">target</span><span class="p">)|</span> <span class="p">{</span>
                <span class="p">(</span>
                    <span class="nf">Some</span><span class="p">((</span>
                        <span class="k">match</span> <span class="n">cond</span><span class="nf">.as_bytes</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span> <span class="p">{</span>
                            <span class="sc">b'x'</span> <span class="k">=&gt;</span> <span class="mi">0</span><span class="p">,</span>
                            <span class="sc">b'm'</span> <span class="k">=&gt;</span> <span class="mi">1</span><span class="p">,</span>
                            <span class="sc">b'a'</span> <span class="k">=&gt;</span> <span class="mi">2</span><span class="p">,</span>
                            <span class="sc">b's'</span> <span class="k">=&gt;</span> <span class="mi">3</span><span class="p">,</span>
                            <span class="n">b</span> <span class="k">=&gt;</span> <span class="nd">panic!</span><span class="p">(</span><span class="s">"Bad symbol: '{}'"</span><span class="p">,</span> <span class="n">b</span> <span class="k">as</span> <span class="nb">char</span><span class="p">),</span>
                        <span class="p">},</span>
                        <span class="k">match</span> <span class="n">cond</span><span class="nf">.as_bytes</span><span class="p">()[</span><span class="mi">1</span><span class="p">]</span> <span class="p">{</span>
                            <span class="sc">b'&gt;'</span> <span class="k">=&gt;</span> <span class="nn">Ordering</span><span class="p">::</span><span class="n">Greater</span><span class="p">,</span>
                            <span class="sc">b'&lt;'</span> <span class="k">=&gt;</span> <span class="nn">Ordering</span><span class="p">::</span><span class="n">Less</span><span class="p">,</span>
                            <span class="n">b</span> <span class="k">=&gt;</span> <span class="nd">panic!</span><span class="p">(</span><span class="s">"Bad symbol: '{}'"</span><span class="p">,</span> <span class="n">b</span> <span class="k">as</span> <span class="nb">char</span><span class="p">),</span>
                        <span class="p">},</span>
                        <span class="n">cond</span><span class="p">[</span><span class="mi">2</span><span class="o">..</span><span class="p">]</span><span class="nf">.parse</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">(),</span>
                    <span class="p">)),</span>
                    <span class="n">target</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="p">})</span>
            <span class="nf">.unwrap_or</span><span class="p">((</span><span class="nb">None</span><span class="p">,</span> <span class="n">rule</span><span class="p">))</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="nf">parse_workflows</span><span class="p">(</span><span class="n">workflow</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">HashMap</span><span class="o">&lt;&amp;</span><span class="nb">str</span><span class="p">,</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">RuleT</span><span class="o">&gt;&gt;</span> <span class="p">{</span>
        <span class="n">workflow</span>
            <span class="nf">.lines</span><span class="p">()</span>
            <span class="nf">.map</span><span class="p">(|</span><span class="n">line</span><span class="p">|</span> <span class="p">{</span>
                <span class="n">line</span><span class="nf">.split_once</span><span class="p">(</span><span class="sc">'{'</span><span class="p">)</span>
                    <span class="nf">.and_then</span><span class="p">(|(</span><span class="n">label</span><span class="p">,</span> <span class="n">rules</span><span class="p">)|</span> <span class="n">rules</span><span class="nf">.strip_suffix</span><span class="p">(</span><span class="sc">'}'</span><span class="p">)</span><span class="nf">.map</span><span class="p">(|</span><span class="n">rules</span><span class="p">|</span> <span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">rules</span><span class="p">)))</span>
                    <span class="nf">.unwrap</span><span class="p">()</span>
            <span class="p">})</span>
            <span class="nf">.map</span><span class="p">(|(</span><span class="n">label</span><span class="p">,</span> <span class="n">rules</span><span class="p">)|</span> <span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">rules</span><span class="nf">.split</span><span class="p">(</span><span class="sc">','</span><span class="p">)</span><span class="nf">.map</span><span class="p">(</span><span class="n">parse_rule</span><span class="p">)</span><span class="nf">.collect</span><span class="p">()))</span>
            <span class="nf">.collect</span><span class="p">()</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="nf">parse_parts</span><span class="p">(</span><span class="n">parts</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">PartT</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="n">parts</span>
            <span class="nf">.lines</span><span class="p">()</span>
            <span class="nf">.map</span><span class="p">(|</span><span class="n">part</span><span class="p">|</span> <span class="p">{</span>
                <span class="k">let</span> <span class="k">mut</span> <span class="n">values</span> <span class="o">=</span> <span class="n">part</span>
                    <span class="py">.trim_matches</span><span class="p">::</span><span class="o">&lt;&amp;</span><span class="p">[</span><span class="nb">char</span><span class="p">]</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="p">[</span><span class="sc">'{'</span><span class="p">,</span> <span class="sc">'}'</span><span class="p">])</span>
                    <span class="nf">.split</span><span class="p">(</span><span class="sc">','</span><span class="p">)</span>
                    <span class="nf">.map</span><span class="p">(|</span><span class="n">n</span><span class="p">|</span> <span class="n">n</span><span class="p">[</span><span class="mi">2</span><span class="o">..</span><span class="p">]</span><span class="nf">.parse</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">());</span>
                <span class="p">[</span>
                    <span class="n">values</span><span class="nf">.next</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">(),</span>
                    <span class="n">values</span><span class="nf">.next</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">(),</span>
                    <span class="n">values</span><span class="nf">.next</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">(),</span>
                    <span class="n">values</span><span class="nf">.next</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">(),</span>
                <span class="p">]</span>
            <span class="p">})</span>
            <span class="nf">.collect</span><span class="p">()</span>
    <span class="p">}</span>

    <span class="k">impl</span><span class="o">&lt;</span><span class="nv">'a</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="nb">From</span><span class="o">&lt;&amp;</span><span class="nv">'a</span> <span class="n">T</span><span class="o">&gt;</span> <span class="k">for</span> <span class="n">PuzzleData</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span>
    <span class="k">where</span>
        <span class="n">T</span><span class="p">:</span> <span class="nb">AsRef</span><span class="o">&lt;</span><span class="nb">str</span><span class="o">&gt;</span> <span class="o">+</span> <span class="nv">'a</span> <span class="o">+</span> <span class="o">?</span><span class="nb">Sized</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="k">fn</span> <span class="nf">from</span><span class="p">(</span><span class="n">s</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="n">T</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
            <span class="n">s</span><span class="nf">.as_ref</span><span class="p">()</span>
                <span class="nf">.split_once</span><span class="p">(</span><span class="s">"</span><span class="se">\n\n</span><span class="s">"</span><span class="p">)</span>
                <span class="nf">.map</span><span class="p">(|(</span><span class="n">workflows</span><span class="p">,</span> <span class="n">parts</span><span class="p">)|</span> <span class="k">Self</span><span class="p">(</span><span class="nf">parse_workflows</span><span class="p">(</span><span class="n">workflows</span><span class="p">),</span> <span class="nf">parse_parts</span><span class="p">(</span><span class="n">parts</span><span class="p">)))</span>
                <span class="nf">.unwrap</span><span class="p">()</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_star_1_20">Star 1</h3>
<div class="paragraph">
<p>Just recurse through the workflows until a part is accepted or rejected. Recursion is done using a <code>successors</code> iterator.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
</pre></td><td class="code"><pre><span class="k">pub</span> <span class="k">fn</span> <span class="nf">star_1</span><span class="p">(</span><span class="nf">PuzzleData</span><span class="p">(</span><span class="n">workflows</span><span class="p">,</span> <span class="n">parts</span><span class="p">):</span> <span class="o">&amp;</span><span class="n">PuzzleData</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">SolT</span> <span class="p">{</span>
    <span class="n">parts</span>
        <span class="nf">.iter</span><span class="p">()</span>
        <span class="nf">.filter</span><span class="p">(|</span><span class="n">part</span><span class="p">|</span> <span class="p">{</span>
            <span class="nf">Some</span><span class="p">(</span><span class="s">"A"</span><span class="p">)</span>
                <span class="o">==</span> <span class="nf">successors</span><span class="p">(</span><span class="nf">Some</span><span class="p">(</span><span class="s">"in"</span><span class="p">),</span> <span class="p">|</span><span class="o">&amp;</span><span class="n">target</span><span class="p">|</span> <span class="p">{</span>
                    <span class="n">workflows</span><span class="nf">.get</span><span class="p">(</span><span class="n">target</span><span class="p">)</span><span class="nf">.and_then</span><span class="p">(|</span><span class="n">workflow</span><span class="p">|</span> <span class="p">{</span>
                        <span class="n">workflow</span>
                            <span class="nf">.iter</span><span class="p">()</span>
                            <span class="nf">.find</span><span class="p">(|(</span><span class="n">cond</span><span class="p">,</span> <span class="n">_</span><span class="p">)|</span> <span class="p">{</span>
                                <span class="n">cond</span><span class="nf">.map</span><span class="p">(|(</span><span class="n">idx</span><span class="p">,</span> <span class="n">ord</span><span class="p">,</span> <span class="n">val</span><span class="p">)|</span> <span class="n">part</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="nf">.cmp</span><span class="p">(</span><span class="o">&amp;</span><span class="n">val</span><span class="p">)</span> <span class="o">==</span> <span class="n">ord</span><span class="p">)</span>
                                    <span class="nf">.unwrap_or</span><span class="p">(</span><span class="k">true</span><span class="p">)</span>
                            <span class="p">})</span>
                            <span class="nf">.map</span><span class="p">(|</span><span class="o">&amp;</span><span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="n">target</span><span class="p">)|</span> <span class="n">target</span><span class="p">)</span>
                    <span class="p">})</span>
                <span class="p">})</span>
                <span class="nf">.last</span><span class="p">()</span>
        <span class="p">})</span>
        <span class="nf">.map</span><span class="p">(|</span><span class="n">part</span><span class="p">|</span> <span class="n">part</span><span class="nf">.iter</span><span class="p">()</span><span class="py">.sum</span><span class="p">::</span><span class="o">&lt;</span><span class="n">SolT</span><span class="o">&gt;</span><span class="p">())</span>
        <span class="nf">.sum</span><span class="p">()</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_star_2_20">Star 2</h3>
<div class="paragraph">
<p>Divide and conquer!</p>
</div>
<div class="paragraph">
<p>Any rule splits the allowed ranges in one part which matches the rule and another part which does not (both are possibly empty). These two parts are then handled separately. The part with matches by recursing to the target workflow of the rule, the part which does not match by checking the next rule in the workflow.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
</pre></td><td class="code"><pre><span class="k">pub</span> <span class="k">fn</span> <span class="nf">star_2_rec</span><span class="p">(</span>
    <span class="n">workflows</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">HashMap</span><span class="o">&lt;&amp;</span><span class="nb">str</span><span class="p">,</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">RuleT</span><span class="o">&gt;&gt;</span><span class="p">,</span>
    <span class="n">target</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">,</span>
    <span class="k">mut</span> <span class="n">v_min</span><span class="p">:</span> <span class="n">PartT</span><span class="p">,</span>
    <span class="k">mut</span> <span class="n">v_max</span><span class="p">:</span> <span class="n">PartT</span><span class="p">,</span>
<span class="p">)</span> <span class="k">-&gt;</span> <span class="n">SolT</span> <span class="p">{</span>
    <span class="k">match</span> <span class="n">target</span> <span class="p">{</span>
        <span class="s">"A"</span> <span class="k">=&gt;</span> <span class="p">{</span>
            <span class="k">return</span> <span class="p">(</span><span class="mi">0</span><span class="o">..</span><span class="mi">4</span><span class="p">)</span>
                <span class="nf">.map</span><span class="p">(|</span><span class="n">idx</span><span class="p">|</span> <span class="p">(</span><span class="n">v_max</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">-</span> <span class="n">v_min</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span> <span class="k">as</span> <span class="n">SolT</span><span class="p">)</span>
                <span class="nf">.product</span><span class="p">()</span>
        <span class="p">}</span>
        <span class="s">"R"</span> <span class="k">=&gt;</span> <span class="k">return</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">_</span> <span class="k">=&gt;</span> <span class="p">(),</span>
    <span class="p">}</span>

    <span class="k">let</span> <span class="k">mut</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">rule</span><span class="p">,</span> <span class="n">next</span><span class="p">)</span> <span class="k">in</span> <span class="n">workflows</span><span class="nf">.get</span><span class="p">(</span><span class="n">target</span><span class="p">)</span><span class="nf">.unwrap</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">match</span> <span class="n">rule</span>
            <span class="nf">.map</span><span class="p">(|(</span><span class="n">idx</span><span class="p">,</span> <span class="n">ord</span><span class="p">,</span> <span class="n">val</span><span class="p">)|</span> <span class="p">{</span>
                <span class="p">(</span>
                    <span class="n">idx</span><span class="p">,</span>
                    <span class="n">val</span><span class="p">,</span>
                    <span class="n">v_min</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="nf">.cmp</span><span class="p">(</span><span class="o">&amp;</span><span class="n">val</span><span class="p">)</span> <span class="o">==</span> <span class="n">ord</span><span class="p">,</span>
                    <span class="p">(</span><span class="n">v_max</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span><span class="nf">.cmp</span><span class="p">(</span><span class="o">&amp;</span><span class="n">val</span><span class="p">)</span> <span class="o">==</span> <span class="n">ord</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="p">})</span>
            <span class="nf">.unwrap_or</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">true</span><span class="p">,</span> <span class="k">true</span><span class="p">))</span>
        <span class="p">{</span>
            <span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="k">false</span><span class="p">,</span> <span class="k">false</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">(),</span> <span class="c1">// rule does not match at all -&gt; check next rule</span>
            <span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="k">true</span><span class="p">,</span> <span class="k">true</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="c1">// rule fully matches -&gt; recurse and stop checking further rules here</span>
                <span class="k">return</span> <span class="n">count</span> <span class="o">+</span> <span class="nf">star_2_rec</span><span class="p">(</span><span class="n">workflows</span><span class="p">,</span> <span class="n">next</span><span class="p">,</span> <span class="n">v_min</span><span class="p">,</span> <span class="n">v_max</span><span class="p">);</span>
            <span class="p">}</span>
            <span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="k">true</span><span class="p">,</span> <span class="k">false</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="c1">// rule matches for values_min_match[idx]..val -&gt; recurse</span>
                <span class="k">let</span> <span class="p">(</span><span class="n">v_min_rec</span><span class="p">,</span> <span class="k">mut</span> <span class="n">v_max_rec</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="n">v_min</span><span class="p">,</span> <span class="n">v_max</span><span class="p">);</span>
                <span class="n">v_max_rec</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
                <span class="n">count</span> <span class="o">+=</span> <span class="nf">star_2_rec</span><span class="p">(</span><span class="n">workflows</span><span class="p">,</span> <span class="n">next</span><span class="p">,</span> <span class="n">v_min_rec</span><span class="p">,</span> <span class="n">v_max_rec</span><span class="p">);</span>
                <span class="c1">// rule does not match for val..values_max[idx] -&gt; check next rule</span>
                <span class="n">v_min</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="k">false</span><span class="p">,</span> <span class="k">true</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="c1">// rule matches for val + 1..values_max_match[idx] -&gt; recurse</span>
                <span class="k">let</span> <span class="p">(</span><span class="k">mut</span> <span class="n">v_min_rec</span><span class="p">,</span> <span class="n">v_max_rec</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="n">v_min</span><span class="p">,</span> <span class="n">v_max</span><span class="p">);</span>
                <span class="n">v_min_rec</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
                <span class="n">count</span> <span class="o">+=</span> <span class="nf">star_2_rec</span><span class="p">(</span><span class="n">workflows</span><span class="p">,</span> <span class="n">next</span><span class="p">,</span> <span class="n">v_min_rec</span><span class="p">,</span> <span class="n">v_max_rec</span><span class="p">);</span>
                <span class="c1">// rule does not match for values_min[idx]..val + 1 -&gt; check next rule</span>
                <span class="n">v_max</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="nd">unreachable!</span><span class="p">(</span><span class="s">"Eventually everything shall match"</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">pub</span> <span class="k">fn</span> <span class="nf">star_2</span><span class="p">(</span><span class="nf">PuzzleData</span><span class="p">(</span><span class="n">workflows</span><span class="p">,</span> <span class="n">_</span><span class="p">):</span> <span class="o">&amp;</span><span class="n">PuzzleData</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">SolT</span> <span class="p">{</span>
    <span class="nf">star_2_rec</span><span class="p">(</span><span class="n">workflows</span><span class="p">,</span> <span class="s">"in"</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">;</span> <span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">4001</span><span class="p">;</span> <span class="mi">4</span><span class="p">])</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_tests_19">Tests</h3>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
</pre></td><td class="code"><pre><span class="nd">#[cfg(test)]</span>
<span class="k">mod</span> <span class="n">tests</span> <span class="p">{</span>
    <span class="k">use</span> <span class="k">super</span><span class="p">::</span><span class="o">*</span><span class="p">;</span>

    <span class="k">const</span> <span class="n">CONTENT</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span> <span class="o">=</span> <span class="s">r#"px{a&lt;2006:qkq,m&gt;2090:A,rfg}
pv{a&gt;1716:R,A}
lnx{m&gt;1548:A,A}
rfg{s&lt;537:gd,x&gt;2440:R,A}
qs{s&gt;3448:A,lnx}
qkq{x&lt;1416:A,crn}
crn{x&gt;2662:A,R}
in{s&lt;1351:px,qqz}
qqz{s&gt;2770:qs,m&lt;1801:hdj,R}
gd{a&gt;3333:R,R}
hdj{m&gt;838:A,pv}

{x=787,m=2655,a=1222,s=2876}
{x=1679,m=44,a=2067,s=496}
{x=2036,m=264,a=79,s=2244}
{x=2461,m=1339,a=466,s=291}
{x=2127,m=1623,a=2188,s=1013}
"#</span><span class="p">;</span>

    <span class="nd">#[test]</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">test_from</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">data</span> <span class="o">=</span> <span class="nn">PuzzleData</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="n">CONTENT</span><span class="p">);</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"{data:?}"</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="nd">#[test]</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">test_star_1</span><span class="p">()</span> <span class="p">{</span>
        <span class="nd">assert_eq!</span><span class="p">(</span><span class="mi">19_114</span><span class="p">,</span> <span class="nf">star_1</span><span class="p">(</span><span class="o">&amp;</span><span class="n">CONTENT</span><span class="nf">.into</span><span class="p">()));</span>
    <span class="p">}</span>

    <span class="nd">#[test]</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">test_star_2</span><span class="p">()</span> <span class="p">{</span>
        <span class="nd">assert_eq!</span><span class="p">(</span><span class="mi">167_409_079_868_000</span><span class="p">,</span> <span class="nf">star_2</span><span class="p">(</span><span class="o">&amp;</span><span class="n">CONTENT</span><span class="nf">.into</span><span class="p">()));</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p><a href="#top">Top</a></p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="sol-rust-20">Rust | Day 20: Pulse Propagation</h2>
<div class="sectionbody">
<div class="paragraph">
<p><a href="https://rust-lang.org">Rust</a> solution to <a href="https://adventofcode.com/2023/day/20">AoC|2023|20</a>.</p>
</div>
<div class="sect2">
<h3 id="_input_16">Input</h3>
<div class="paragraph">
<p>Reading and understanding the puzzle description was a bit of a challenge today.</p>
</div>
<div class="paragraph">
<p>The puzzle contains nodes that have a type (plain, flip-flop, conjunction) and an identifier. Each node has zero to many target nodes it sends to.</p>
</div>
<div class="paragraph">
<p>To avoid expensive lookups later on, I assign a unique id to each node, which can be used directly as index into vectors.</p>
</div>
<div class="paragraph">
<p>The input is modeled as a vector of vectors for the targets, a vector of types (<code>u8</code>) and the ids of the <code>broadcaster</code> and, if present, the <code>rx</code> node (needed for part 2).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
</pre></td><td class="code"><pre><span class="k">pub</span> <span class="k">mod</span> <span class="n">input</span> <span class="p">{</span>
    <span class="nd">#[derive(Debug,</span> <span class="nd">PartialEq,</span> <span class="nd">Eq)]</span>
    <span class="k">pub</span> <span class="k">struct</span> <span class="n">PuzzleData</span> <span class="p">{</span>
        <span class="k">pub</span> <span class="n">bc</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
        <span class="k">pub</span> <span class="n">rx</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span><span class="p">,</span>
        <span class="k">pub</span> <span class="n">targets</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;&gt;</span><span class="p">,</span>
        <span class="k">pub</span> <span class="n">types</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">u8</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="n">get_id</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span><span class="p">(</span><span class="n">nodes</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="nb">Vec</span><span class="o">&lt;&amp;</span><span class="nv">'a</span> <span class="nb">str</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="nb">str</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">id</span> <span class="o">=</span> <span class="n">nodes</span><span class="nf">.iter</span><span class="p">()</span><span class="nf">.position</span><span class="p">(|</span><span class="o">&amp;</span><span class="n">n</span><span class="p">|</span> <span class="n">n</span> <span class="o">==</span> <span class="n">node</span><span class="p">)</span><span class="nf">.unwrap_or</span><span class="p">(</span><span class="n">nodes</span><span class="nf">.len</span><span class="p">());</span>
        <span class="k">if</span> <span class="n">id</span> <span class="o">==</span> <span class="n">nodes</span><span class="nf">.len</span><span class="p">()</span> <span class="p">{</span>
            <span class="n">nodes</span><span class="nf">.push</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="n">id</span>
    <span class="p">}</span>

    <span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="nb">From</span><span class="o">&lt;&amp;</span><span class="n">T</span><span class="o">&gt;</span> <span class="k">for</span> <span class="n">PuzzleData</span>
    <span class="k">where</span>
        <span class="n">T</span><span class="p">:</span> <span class="nb">AsRef</span><span class="o">&lt;</span><span class="nb">str</span><span class="o">&gt;</span> <span class="o">+</span> <span class="o">?</span><span class="nb">Sized</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="k">fn</span> <span class="nf">from</span><span class="p">(</span><span class="n">s</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">T</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
            <span class="k">let</span> <span class="k">mut</span> <span class="n">nodes</span> <span class="o">=</span> <span class="nn">Vec</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
            <span class="k">let</span> <span class="k">mut</span> <span class="n">targets</span> <span class="o">=</span> <span class="nn">Vec</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
            <span class="k">let</span> <span class="k">mut</span> <span class="n">types</span> <span class="o">=</span> <span class="nn">Vec</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
            <span class="k">for</span> <span class="n">line</span> <span class="k">in</span> <span class="n">s</span><span class="nf">.as_ref</span><span class="p">()</span><span class="nf">.lines</span><span class="p">()</span> <span class="p">{</span>
                <span class="k">let</span> <span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">targets_part</span><span class="p">)</span> <span class="o">=</span> <span class="n">line</span><span class="nf">.split_once</span><span class="p">(</span><span class="s">" -&gt; "</span><span class="p">)</span><span class="nf">.unwrap</span><span class="p">();</span>
                <span class="k">let</span> <span class="p">(</span><span class="n">source_type</span><span class="p">,</span> <span class="n">source</span><span class="p">)</span> <span class="o">=</span> <span class="k">match</span> <span class="n">source</span><span class="nf">.as_bytes</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span> <span class="p">{</span>
                    <span class="sc">b'%'</span> <span class="k">=&gt;</span> <span class="p">(</span><span class="sc">b'%'</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">source</span><span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="p">]),</span>
                    <span class="sc">b'&amp;'</span> <span class="k">=&gt;</span> <span class="p">(</span><span class="sc">b'&amp;'</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">source</span><span class="p">[</span><span class="mi">1</span><span class="o">..</span><span class="p">]),</span>
                    <span class="n">b</span> <span class="k">if</span> <span class="n">b</span><span class="nf">.is_ascii_alphabetic</span><span class="p">()</span> <span class="k">=&gt;</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">source</span><span class="p">),</span>
                    <span class="n">_</span> <span class="k">=&gt;</span> <span class="nd">panic!</span><span class="p">(),</span>
                <span class="p">};</span>

                <span class="k">let</span> <span class="n">source_id</span> <span class="o">=</span> <span class="nf">get_id</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">nodes</span><span class="p">,</span> <span class="n">source</span><span class="p">);</span>
                <span class="k">let</span> <span class="n">target_ids</span> <span class="o">=</span> <span class="n">targets_part</span>
                    <span class="nf">.split</span><span class="p">(</span><span class="s">", "</span><span class="p">)</span>
                    <span class="py">.collect</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="n">_</span><span class="o">&gt;&gt;</span><span class="p">()</span>
                    <span class="nf">.iter</span><span class="p">()</span>
                    <span class="nf">.map</span><span class="p">(|</span><span class="o">&amp;</span><span class="n">target</span><span class="p">|</span> <span class="nf">get_id</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">nodes</span><span class="p">,</span> <span class="n">target</span><span class="p">))</span>
                    <span class="py">.collect</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="n">_</span><span class="o">&gt;&gt;</span><span class="p">();</span>

                <span class="n">targets</span><span class="nf">.resize</span><span class="p">(</span><span class="n">nodes</span><span class="nf">.len</span><span class="p">(),</span> <span class="nn">Vec</span><span class="p">::</span><span class="nf">default</span><span class="p">());</span>
                <span class="n">targets</span><span class="p">[</span><span class="n">source_id</span><span class="p">]</span> <span class="o">=</span> <span class="n">target_ids</span><span class="p">;</span>

                <span class="n">types</span><span class="nf">.resize</span><span class="p">(</span><span class="n">nodes</span><span class="nf">.len</span><span class="p">(),</span> <span class="mi">0</span><span class="p">);</span>
                <span class="n">types</span><span class="p">[</span><span class="n">source_id</span><span class="p">]</span> <span class="o">=</span> <span class="n">source_type</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="k">let</span> <span class="n">bc</span> <span class="o">=</span> <span class="n">nodes</span>
                <span class="nf">.iter</span><span class="p">()</span>
                <span class="nf">.position</span><span class="p">(|</span><span class="o">&amp;</span><span class="n">name</span><span class="p">|</span> <span class="n">name</span> <span class="o">==</span> <span class="s">"broadcaster"</span><span class="p">)</span>
                <span class="nf">.unwrap</span><span class="p">();</span>
            <span class="k">let</span> <span class="n">rx</span> <span class="o">=</span> <span class="n">nodes</span><span class="nf">.iter</span><span class="p">()</span><span class="nf">.position</span><span class="p">(|</span><span class="o">&amp;</span><span class="n">name</span><span class="p">|</span> <span class="n">name</span> <span class="o">==</span> <span class="s">"rx"</span><span class="p">);</span>

            <span class="k">Self</span> <span class="p">{</span>
                <span class="n">bc</span><span class="p">,</span>
                <span class="n">rx</span><span class="p">,</span>
                <span class="n">targets</span><span class="p">,</span>
                <span class="n">types</span><span class="p">,</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_star_1_21">Star 1</h3>
<div class="paragraph">
<p>Nodes may have memory assigned to them. Flip-flops have a single bit, conjunctions have multiple bits, and plain nodes do not have any memory. For conjunction nodes, each bit of memory is reserved to receive data from one specific source.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
</pre></td><td class="code"><pre><span class="nd">#[derive(Clone,</span> <span class="nd">PartialEq,</span> <span class="nd">Eq)]</span>
<span class="k">pub</span> <span class="k">enum</span> <span class="n">Mem</span> <span class="p">{</span>
    <span class="n">Plain</span><span class="p">,</span>
    <span class="nf">FlipFlop</span><span class="p">(</span><span class="nb">bool</span><span class="p">),</span>
    <span class="nf">Conjunction</span><span class="p">(</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="p">(</span><span class="nb">usize</span><span class="p">,</span> <span class="nb">bool</span><span class="p">)</span><span class="o">&gt;</span><span class="p">),</span>
<span class="p">}</span>

<span class="k">pub</span> <span class="k">fn</span> <span class="nf">dump_memory</span><span class="p">(</span><span class="n">mems</span><span class="p">:</span> <span class="o">&amp;</span><span class="p">[</span><span class="n">Mem</span><span class="p">])</span> <span class="k">-&gt;</span> <span class="p">(</span><span class="nb">u128</span><span class="p">,</span> <span class="nb">u128</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">mems</span><span class="nf">.iter</span><span class="p">()</span><span class="nf">.fold</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">|(</span><span class="n">dump</span><span class="p">,</span> <span class="n">mask</span><span class="p">),</span> <span class="n">mem</span><span class="p">|</span> <span class="k">match</span> <span class="n">mem</span> <span class="p">{</span>
        <span class="nn">Mem</span><span class="p">::</span><span class="n">Plain</span> <span class="k">=&gt;</span> <span class="p">(</span><span class="n">dump</span><span class="p">,</span> <span class="n">mask</span><span class="p">),</span>
        <span class="nn">Mem</span><span class="p">::</span><span class="nf">FlipFlop</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">(</span><span class="n">dump</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span> <span class="p">|</span> <span class="o">*</span><span class="n">val</span> <span class="k">as</span> <span class="nb">u128</span><span class="p">,</span> <span class="n">mask</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span> <span class="p">|</span> <span class="mi">1</span><span class="p">),</span>
        <span class="nn">Mem</span><span class="p">::</span><span class="nf">Conjunction</span><span class="p">(</span><span class="n">values</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="n">values</span><span class="nf">.iter</span><span class="p">()</span><span class="nf">.fold</span><span class="p">((</span><span class="n">dump</span><span class="p">,</span> <span class="n">mask</span><span class="p">),</span> <span class="p">|(</span><span class="n">dump</span><span class="p">,</span> <span class="n">mask</span><span class="p">),</span> <span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="n">val</span><span class="p">)|</span> <span class="p">{</span>
            <span class="p">(</span><span class="n">dump</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span> <span class="p">|</span> <span class="o">*</span><span class="n">val</span> <span class="k">as</span> <span class="nb">u128</span><span class="p">,</span> <span class="n">mask</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span> <span class="p">|</span> <span class="mi">1</span><span class="p">)</span>
        <span class="p">}),</span>
    <span class="p">})</span>
<span class="p">}</span>

<span class="k">pub</span> <span class="k">fn</span> <span class="nf">init</span><span class="p">(</span><span class="n">targets</span><span class="p">:</span> <span class="o">&amp;</span><span class="p">[</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span><span class="p">],</span> <span class="n">types</span><span class="p">:</span> <span class="o">&amp;</span><span class="p">[</span><span class="nb">u8</span><span class="p">])</span> <span class="k">-&gt;</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">Mem</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">memories</span> <span class="o">=</span> <span class="n">types</span>
        <span class="nf">.iter</span><span class="p">()</span>
        <span class="nf">.map</span><span class="p">(|</span><span class="o">&amp;</span><span class="n">t</span><span class="p">|</span> <span class="k">match</span> <span class="n">t</span> <span class="p">{</span>
            <span class="mi">0</span> <span class="k">=&gt;</span> <span class="nn">Mem</span><span class="p">::</span><span class="n">Plain</span><span class="p">,</span>
            <span class="sc">b'&amp;'</span> <span class="k">=&gt;</span> <span class="nn">Mem</span><span class="p">::</span><span class="nf">Conjunction</span><span class="p">(</span><span class="nn">Vec</span><span class="p">::</span><span class="nf">new</span><span class="p">()),</span>
            <span class="sc">b'%'</span> <span class="k">=&gt;</span> <span class="nn">Mem</span><span class="p">::</span><span class="nf">FlipFlop</span><span class="p">(</span><span class="k">false</span><span class="p">),</span>
            <span class="n">_</span> <span class="k">=&gt;</span> <span class="nd">panic!</span><span class="p">(),</span>
        <span class="p">})</span>
        <span class="py">.collect</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="n">_</span><span class="o">&gt;&gt;</span><span class="p">();</span>

    <span class="k">for</span> <span class="n">k</span> <span class="k">in</span> <span class="mi">0</span><span class="o">..</span><span class="n">types</span><span class="nf">.len</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">for</span> <span class="o">&amp;</span><span class="n">target</span> <span class="k">in</span> <span class="o">&amp;</span><span class="n">targets</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="p">{</span>
            <span class="k">if</span> <span class="k">let</span> <span class="nn">Mem</span><span class="p">::</span><span class="nf">Conjunction</span><span class="p">(</span><span class="k">ref</span> <span class="k">mut</span> <span class="n">vec</span><span class="p">)</span> <span class="o">=</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">memories</span><span class="p">[</span><span class="n">target</span><span class="p">]</span> <span class="p">{</span>
                <span class="n">vec</span><span class="nf">.push</span><span class="p">((</span><span class="n">k</span><span class="p">,</span> <span class="k">false</span><span class="p">));</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">memories</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>To solve the first part, I first implemented a function that simulates a single button press. It accepts a callback to do something upon transmissions. Packets are pushed in a FIFO queue to make sure the order is preserved.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
</pre></td><td class="code"><pre><span class="k">pub</span> <span class="k">fn</span> <span class="n">press_button</span><span class="o">&lt;</span><span class="n">F</span><span class="o">&gt;</span><span class="p">(</span><span class="n">memories</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="p">[</span><span class="n">Mem</span><span class="p">],</span> <span class="n">bc</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span> <span class="n">targets</span><span class="p">:</span> <span class="o">&amp;</span><span class="p">[</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span><span class="p">],</span> <span class="k">mut</span> <span class="n">callback</span><span class="p">:</span> <span class="n">F</span><span class="p">)</span>
<span class="k">where</span>
    <span class="n">F</span><span class="p">:</span> <span class="nf">FnMut</span><span class="p">(</span><span class="nb">usize</span><span class="p">,</span> <span class="nb">usize</span><span class="p">,</span> <span class="nb">bool</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="p">(),</span>
<span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">queue</span> <span class="o">=</span> <span class="nn">VecDeque</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>

    <span class="k">for</span> <span class="o">&amp;</span><span class="n">target</span> <span class="k">in</span> <span class="o">&amp;</span><span class="n">targets</span><span class="p">[</span><span class="n">bc</span><span class="p">]</span> <span class="p">{</span>
        <span class="n">queue</span><span class="nf">.push_back</span><span class="p">((</span><span class="n">target</span><span class="p">,</span> <span class="n">bc</span><span class="p">,</span> <span class="k">false</span><span class="p">));</span>
    <span class="p">}</span>

    <span class="k">while</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">((</span><span class="n">target</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">value</span><span class="p">))</span> <span class="o">=</span> <span class="n">queue</span><span class="nf">.pop_front</span><span class="p">()</span> <span class="p">{</span>
        <span class="nf">callback</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>

        <span class="k">match</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">memories</span><span class="p">[</span><span class="n">target</span><span class="p">]</span> <span class="p">{</span>
            <span class="nn">Mem</span><span class="p">::</span><span class="nf">FlipFlop</span><span class="p">(</span><span class="k">ref</span> <span class="k">mut</span> <span class="n">mem</span><span class="p">)</span> <span class="k">if</span> <span class="o">!</span><span class="n">value</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="o">*</span><span class="n">mem</span> <span class="o">=</span> <span class="o">!*</span><span class="n">mem</span><span class="p">;</span>
                <span class="k">for</span> <span class="o">&amp;</span><span class="n">t</span> <span class="k">in</span> <span class="o">&amp;</span><span class="n">targets</span><span class="p">[</span><span class="n">target</span><span class="p">]</span> <span class="p">{</span>
                    <span class="n">queue</span><span class="nf">.push_back</span><span class="p">((</span><span class="n">t</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="o">*</span><span class="n">mem</span><span class="p">));</span>
                <span class="p">}</span>
            <span class="p">}</span>
            <span class="nn">Mem</span><span class="p">::</span><span class="nf">Conjunction</span><span class="p">(</span><span class="k">ref</span> <span class="k">mut</span> <span class="n">mems</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="k">let</span> <span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="n">mem</span><span class="p">)</span> <span class="o">=</span> <span class="n">mems</span><span class="nf">.iter_mut</span><span class="p">()</span><span class="nf">.find</span><span class="p">(|(</span><span class="n">id</span><span class="p">,</span> <span class="n">_</span><span class="p">)|</span> <span class="o">*</span><span class="n">id</span> <span class="o">==</span> <span class="n">source</span><span class="p">)</span><span class="nf">.unwrap</span><span class="p">();</span>
                <span class="o">*</span><span class="n">mem</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>
                <span class="k">let</span> <span class="n">upd</span> <span class="o">=</span> <span class="o">!</span><span class="n">mems</span><span class="nf">.iter</span><span class="p">()</span><span class="nf">.all</span><span class="p">(|(</span><span class="n">_</span><span class="p">,</span> <span class="n">v</span><span class="p">)|</span> <span class="o">*</span><span class="n">v</span><span class="p">);</span>
                <span class="k">for</span> <span class="o">&amp;</span><span class="n">t</span> <span class="k">in</span> <span class="o">&amp;</span><span class="n">targets</span><span class="p">[</span><span class="n">target</span><span class="p">]</span> <span class="p">{</span>
                    <span class="n">queue</span><span class="nf">.push_back</span><span class="p">((</span><span class="n">t</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">upd</span><span class="p">));</span>
                <span class="p">}</span>
            <span class="p">}</span>
            <span class="n">_</span> <span class="k">=&gt;</span> <span class="p">(),</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>I then created a <code>SendCounter</code> struct, which provides the callback and does the counting, and that&#8217;s basically it.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
</pre></td><td class="code"><pre><span class="nd">#[derive(Debug,</span> <span class="nd">Default,</span> <span class="nd">PartialEq,</span> <span class="nd">Eq)]</span>
<span class="k">struct</span> <span class="nf">SendCounter</span><span class="p">(</span><span class="nb">usize</span><span class="p">,</span> <span class="nb">usize</span><span class="p">);</span>

<span class="k">impl</span> <span class="n">SendCounter</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">callback</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">impl</span> <span class="nf">FnMut</span><span class="p">(</span><span class="nb">usize</span><span class="p">,</span> <span class="nb">usize</span><span class="p">,</span> <span class="nb">bool</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="p">()</span> <span class="o">+</span> <span class="nv">'_</span> <span class="p">{</span>
        <span class="p">|</span><span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">value</span><span class="p">|</span> <span class="k">self</span><span class="nf">.count</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="nf">count</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">bool</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="n">value</span> <span class="p">{</span>
            <span class="k">self</span><span class="na">.0</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="k">self</span><span class="na">.1</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="nf">get</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
        <span class="k">self</span><span class="na">.0</span> <span class="o">*</span> <span class="k">self</span><span class="na">.1</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">pub</span> <span class="k">fn</span> <span class="nf">star_1</span><span class="p">(</span>
    <span class="n">PuzzleData</span> <span class="p">{</span>
        <span class="n">bc</span><span class="p">,</span>
        <span class="n">rx</span><span class="p">:</span> <span class="n">_</span><span class="p">,</span>
        <span class="n">targets</span><span class="p">,</span>
        <span class="n">types</span><span class="p">,</span>
    <span class="p">}:</span> <span class="o">&amp;</span><span class="n">PuzzleData</span><span class="p">,</span>
<span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">mem</span> <span class="o">=</span> <span class="nf">init</span><span class="p">(</span><span class="n">targets</span><span class="p">,</span> <span class="n">types</span><span class="p">);</span>

    <span class="k">let</span> <span class="k">mut</span> <span class="n">counter</span> <span class="o">=</span> <span class="nn">SendCounter</span><span class="p">::</span><span class="nf">default</span><span class="p">();</span>
    <span class="k">for</span> <span class="n">_</span> <span class="k">in</span> <span class="mi">0</span><span class="o">..</span><span class="mi">1_000</span> <span class="p">{</span>
        <span class="n">counter</span><span class="nf">.count</span><span class="p">(</span><span class="k">false</span><span class="p">);</span> <span class="c1">// button press</span>
        <span class="nf">press_button</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">mem</span><span class="p">,</span> <span class="o">*</span><span class="n">bc</span><span class="p">,</span> <span class="n">targets</span><span class="p">,</span> <span class="n">counter</span><span class="nf">.callback</span><span class="p">());</span>
    <span class="p">}</span>
    <span class="n">counter</span><span class="nf">.get</span><span class="p">()</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_star_2_21">Star 2</h3>
<div class="paragraph">
<p>I am not sure how much I like that second part.</p>
</div>
<div class="paragraph">
<p>It is one of the challenges, where we need to exploit properties of the puzzle input, that the description does not disclose.</p>
</div>
<div class="paragraph">
<p>It turned out quite quickly, that there is no periodicity that can be reasonable exploited (obviously there is periodicity, since there is a finite number of states, 91 bits in my case)</p>
</div>
<div class="paragraph">
<p>After playing around a while, I realized that there is a single node that sends to <code>rx</code>, which is a conjunction. All nodes that send to this conjunction turn out to send <code>high</code> with a periodicity of some large prime number. So the answer is the product of those prime numbers.</p>
</div>
<div class="paragraph">
<p>There is again a struct, <code>Sources</code>, which is used to determine the number of steps it takes to reach all nodes that send to the single source node of <code>rx</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
</pre></td><td class="code"><pre><span class="k">struct</span> <span class="n">Sources</span> <span class="p">{</span>
    <span class="n">values</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">Option</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;&gt;</span><span class="p">,</span>
    <span class="n">source</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
    <span class="n">source_sources</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="n">buttons</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">pub</span> <span class="k">fn</span> <span class="nf">find_sources</span><span class="p">(</span><span class="n">targets</span><span class="p">:</span> <span class="o">&amp;</span><span class="p">[</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span><span class="p">],</span> <span class="n">target</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="n">targets</span>
        <span class="nf">.iter</span><span class="p">()</span>
        <span class="nf">.enumerate</span><span class="p">()</span>
        <span class="nf">.filter</span><span class="p">(|(</span><span class="n">_</span><span class="p">,</span> <span class="n">targets</span><span class="p">)|</span> <span class="n">targets</span><span class="nf">.contains</span><span class="p">(</span><span class="o">&amp;</span><span class="n">target</span><span class="p">))</span>
        <span class="nf">.map</span><span class="p">(|(</span><span class="n">pos</span><span class="p">,</span> <span class="n">_</span><span class="p">)|</span> <span class="n">pos</span><span class="p">)</span>
        <span class="nf">.collect</span><span class="p">()</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">Sources</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">create</span><span class="p">(</span><span class="n">targets</span><span class="p">:</span> <span class="o">&amp;</span><span class="p">[</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span><span class="p">],</span> <span class="n">rx</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">sources</span> <span class="o">=</span> <span class="nf">find_sources</span><span class="p">(</span><span class="o">&amp;</span><span class="n">targets</span><span class="p">,</span> <span class="n">rx</span><span class="p">);</span>
        <span class="nd">assert_eq!</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">sources</span><span class="nf">.len</span><span class="p">());</span>
        <span class="k">let</span> <span class="n">source</span> <span class="o">=</span> <span class="n">sources</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
        <span class="k">let</span> <span class="n">source_sources</span> <span class="o">=</span> <span class="nf">find_sources</span><span class="p">(</span><span class="o">&amp;</span><span class="n">targets</span><span class="p">,</span> <span class="n">source</span><span class="p">);</span>
        <span class="k">let</span> <span class="n">values</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[</span><span class="nb">None</span><span class="p">;</span> <span class="n">source_sources</span><span class="nf">.len</span><span class="p">()];</span>

        <span class="k">Self</span> <span class="p">{</span>
            <span class="n">values</span><span class="p">,</span>
            <span class="n">source</span><span class="p">,</span>
            <span class="n">source_sources</span><span class="p">,</span>
            <span class="n">buttons</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="nf">callback</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">impl</span> <span class="nf">FnMut</span><span class="p">(</span><span class="nb">usize</span><span class="p">,</span> <span class="nb">usize</span><span class="p">,</span> <span class="nb">bool</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="p">()</span> <span class="o">+</span> <span class="nv">'_</span> <span class="p">{</span>
        <span class="p">|</span><span class="n">target</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">value</span><span class="p">|</span> <span class="p">{</span>
            <span class="k">if</span> <span class="n">target</span> <span class="o">==</span> <span class="k">self</span><span class="py">.source</span> <span class="o">&amp;&amp;</span> <span class="n">value</span> <span class="p">{</span>
                <span class="k">let</span> <span class="n">id</span> <span class="o">=</span> <span class="k">self</span>
                    <span class="py">.source_sources</span>
                    <span class="nf">.iter</span><span class="p">()</span>
                    <span class="nf">.position</span><span class="p">(|</span><span class="o">&amp;</span><span class="n">id</span><span class="p">|</span> <span class="n">id</span> <span class="o">==</span> <span class="n">source</span><span class="p">)</span>
                    <span class="nf">.unwrap</span><span class="p">();</span>
                <span class="k">if</span> <span class="k">self</span><span class="py">.values</span><span class="p">[</span><span class="n">id</span><span class="p">]</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
                    <span class="k">self</span><span class="py">.values</span><span class="p">[</span><span class="n">id</span><span class="p">]</span> <span class="o">=</span> <span class="nf">Some</span><span class="p">(</span><span class="k">self</span><span class="py">.buttons</span><span class="p">);</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="nf">button</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">self</span><span class="py">.buttons</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="nf">done</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">bool</span> <span class="p">{</span>
        <span class="k">self</span><span class="py">.values</span><span class="nf">.iter</span><span class="p">()</span><span class="nf">.all</span><span class="p">(|</span><span class="n">v</span><span class="p">|</span> <span class="n">v</span><span class="nf">.is_some</span><span class="p">())</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="nf">get</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
        <span class="k">self</span><span class="py">.values</span><span class="nf">.iter</span><span class="p">()</span><span class="nf">.flatten</span><span class="p">()</span><span class="nf">.product</span><span class="p">()</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">pub</span> <span class="k">fn</span> <span class="nf">star_2</span><span class="p">(</span>
    <span class="n">PuzzleData</span> <span class="p">{</span>
        <span class="n">bc</span><span class="p">,</span>
        <span class="n">rx</span><span class="p">,</span>
        <span class="n">targets</span><span class="p">,</span>
        <span class="n">types</span><span class="p">,</span>
    <span class="p">}:</span> <span class="o">&amp;</span><span class="n">PuzzleData</span><span class="p">,</span>
<span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">memories</span> <span class="o">=</span> <span class="nf">init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">targets</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">types</span><span class="p">);</span>

    <span class="k">let</span> <span class="k">mut</span> <span class="n">sources</span> <span class="o">=</span> <span class="nn">Sources</span><span class="p">::</span><span class="nf">create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">targets</span><span class="p">,</span> <span class="n">rx</span><span class="nf">.unwrap</span><span class="p">());</span>
    <span class="k">while</span> <span class="o">!</span><span class="n">sources</span><span class="nf">.done</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">sources</span><span class="nf">.button</span><span class="p">();</span>
        <span class="nf">press_button</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">memories</span><span class="p">,</span> <span class="o">*</span><span class="n">bc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">targets</span><span class="p">,</span> <span class="n">sources</span><span class="nf">.callback</span><span class="p">());</span>
    <span class="p">}</span>
    <span class="n">sources</span><span class="nf">.get</span><span class="p">()</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_tests_20">Tests</h3>
<div class="paragraph">
<p>Today was more a day for exploratory testing (aka run, print debug statements, run again, try this and that, find patterns, &#8230;&#8203;). The <code>dump_memory</code> function is a left-over from this.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
</pre></td><td class="code"><pre><span class="nd">#[cfg(test)]</span>
<span class="k">mod</span> <span class="n">tests</span> <span class="p">{</span>
    <span class="k">use</span> <span class="k">super</span><span class="p">::</span><span class="o">*</span><span class="p">;</span>

    <span class="k">const</span> <span class="n">CONTENT_1</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span> <span class="o">=</span> <span class="s">r#"broadcaster -&gt; a, b, c
%a -&gt; b
%b -&gt; c
%c -&gt; inv
&amp;inv -&gt; a
"#</span><span class="p">;</span>

    <span class="k">const</span> <span class="n">CONTENT_2</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span> <span class="o">=</span> <span class="s">r#"broadcaster -&gt; a
%a -&gt; inv, con
&amp;inv -&gt; b
%b -&gt; con
&amp;con -&gt; output
"#</span><span class="p">;</span>

    <span class="nd">#[test]</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">test_from</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">data</span> <span class="o">=</span> <span class="nn">PuzzleData</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="n">CONTENT_1</span><span class="p">);</span>
        <span class="c1">// "broadcaster", "a", "b", "c", "inv"</span>
        <span class="k">let</span> <span class="n">exp</span> <span class="o">=</span> <span class="n">PuzzleData</span> <span class="p">{</span>
            <span class="n">bc</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
            <span class="n">rx</span><span class="p">:</span> <span class="nb">None</span><span class="p">,</span>
            <span class="n">targets</span><span class="p">:</span> <span class="nd">vec!</span><span class="p">[</span><span class="nd">vec!</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="nd">vec!</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="nd">vec!</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="nd">vec!</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="nd">vec!</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span>
            <span class="n">types</span><span class="p">:</span> <span class="nd">vec!</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="sc">b'%'</span><span class="p">,</span> <span class="sc">b'%'</span><span class="p">,</span> <span class="sc">b'%'</span><span class="p">,</span> <span class="sc">b'&amp;'</span><span class="p">],</span>
        <span class="p">};</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"{data:?}"</span><span class="p">);</span>
        <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">exp</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>

        <span class="k">let</span> <span class="n">data</span> <span class="o">=</span> <span class="nn">PuzzleData</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="n">CONTENT_2</span><span class="p">);</span>
        <span class="c1">// "broadcaster", "a", "inv", "con", "b", "output"</span>
        <span class="k">let</span> <span class="n">exp</span> <span class="o">=</span> <span class="n">PuzzleData</span> <span class="p">{</span>
            <span class="n">bc</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
            <span class="n">rx</span><span class="p">:</span> <span class="nb">None</span><span class="p">,</span>
            <span class="n">targets</span><span class="p">:</span> <span class="nd">vec!</span><span class="p">[</span><span class="nd">vec!</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="nd">vec!</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="nd">vec!</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="nd">vec!</span><span class="p">[</span><span class="mi">5</span><span class="p">],</span> <span class="nd">vec!</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="nd">vec!</span><span class="p">[]],</span>
            <span class="n">types</span><span class="p">:</span> <span class="nd">vec!</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="sc">b'%'</span><span class="p">,</span> <span class="sc">b'&amp;'</span><span class="p">,</span> <span class="sc">b'&amp;'</span><span class="p">,</span> <span class="sc">b'%'</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
        <span class="p">};</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"{data:?}"</span><span class="p">);</span>
        <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">exp</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="nd">#[test]</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">test_star_1</span><span class="p">()</span> <span class="p">{</span>
        <span class="nd">assert_eq!</span><span class="p">(</span><span class="mi">32_000_000</span><span class="p">,</span> <span class="nf">star_1</span><span class="p">(</span><span class="o">&amp;</span><span class="n">CONTENT_1</span><span class="nf">.into</span><span class="p">()));</span>
        <span class="nd">assert_eq!</span><span class="p">(</span><span class="mi">11_687_500</span><span class="p">,</span> <span class="nf">star_1</span><span class="p">(</span><span class="o">&amp;</span><span class="n">CONTENT_2</span><span class="nf">.into</span><span class="p">()));</span>
    <span class="p">}</span>

    <span class="nd">#[test]</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">test_press_button_with_send_counter</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">PuzzleData</span> <span class="p">{</span>
            <span class="n">bc</span><span class="p">,</span>
            <span class="n">rx</span><span class="p">:</span> <span class="n">_</span><span class="p">,</span>
            <span class="n">targets</span><span class="p">,</span>
            <span class="n">types</span><span class="p">,</span>
        <span class="p">}</span> <span class="o">=</span> <span class="n">CONTENT_2</span><span class="nf">.into</span><span class="p">();</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">mem</span> <span class="o">=</span> <span class="nf">init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">targets</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">types</span><span class="p">);</span>

        <span class="k">let</span> <span class="k">mut</span> <span class="n">counter</span> <span class="o">=</span> <span class="nn">SendCounter</span><span class="p">::</span><span class="nf">default</span><span class="p">();</span>

        <span class="nf">press_button</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">mem</span><span class="p">,</span> <span class="n">bc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">targets</span><span class="p">,</span> <span class="n">counter</span><span class="nf">.callback</span><span class="p">());</span>
        <span class="nd">assert_eq!</span><span class="p">(</span><span class="nf">SendCounter</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="n">counter</span><span class="p">);</span>

        <span class="nf">press_button</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">mem</span><span class="p">,</span> <span class="n">bc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">targets</span><span class="p">,</span> <span class="n">counter</span><span class="nf">.callback</span><span class="p">());</span>
        <span class="nd">assert_eq!</span><span class="p">(</span><span class="nf">SendCounter</span><span class="p">(</span><span class="mi">4</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span> <span class="o">+</span> <span class="mi">3</span><span class="p">),</span> <span class="n">counter</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="nd">#[test]</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">test_dump_memory</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">PuzzleData</span> <span class="p">{</span>
            <span class="n">bc</span><span class="p">:</span> <span class="n">_</span><span class="p">,</span>
            <span class="n">rx</span><span class="p">:</span> <span class="n">_</span><span class="p">,</span>
            <span class="n">targets</span><span class="p">,</span>
            <span class="n">types</span><span class="p">,</span>
        <span class="p">}</span> <span class="o">=</span> <span class="n">CONTENT_1</span><span class="nf">.into</span><span class="p">();</span>
        <span class="k">let</span> <span class="n">mem</span> <span class="o">=</span> <span class="nf">init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">targets</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">types</span><span class="p">);</span>
        <span class="nd">assert_eq!</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0xf</span><span class="p">),</span> <span class="nf">dump_memory</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mem</span><span class="p">));</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p><a href="#top">Top</a></p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="sol-rust-21">Rust | Day 21: Step Counter</h2>
<div class="sectionbody">
<div class="paragraph">
<p><a href="https://rust-lang.org">Rust</a> solution to <a href="https://adventofcode.com/2023/day/21">AoC|2023|21</a>.</p>
</div>
<div class="paragraph">
<p>The solution got somehow complicated today.</p>
</div>
<div class="paragraph">
<p>The solution uses the fact that there are no rocks on the perimeter of a garden tile. This results in the 'diagonal tiles' to repeat themselves, all tiles above and to the right of the center tile have identical costs modulo an offset. The same is true for the north-west, south-west and south-east tiles.</p>
</div>
<div class="paragraph">
<p>The tiles in a straight line from the center tile also happen to repeat (after a few initial tiles). This allows to replace most of the counting by direct calculations.</p>
</div>
<div class="paragraph">
<p>Here is the not so nice looking solution:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno">  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16
 17
 18
 19
 20
 21
 22
 23
 24
 25
 26
 27
 28
 29
 30
 31
 32
 33
 34
 35
 36
 37
 38
 39
 40
 41
 42
 43
 44
 45
 46
 47
 48
 49
 50
 51
 52
 53
 54
 55
 56
 57
 58
 59
 60
 61
 62
 63
 64
 65
 66
 67
 68
 69
 70
 71
 72
 73
 74
 75
 76
 77
 78
 79
 80
 81
 82
 83
 84
 85
 86
 87
 88
 89
 90
 91
 92
 93
 94
 95
 96
 97
 98
 99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
166
167
168
169
170
171
172
173
174
175
176
177
178
179
180
181
182
183
184
185
186
187
188
189
190
191
192
193
194
195
196
197
198
199
200
201
202
203
204
205
206
207
208
209
210
211
212
213
214
215
216
217
218
219
220
221
222
223
224
225
226
227
228
229
230
231
232
233
234
235
236
237
238
239
240
241
242
243
244
245
246
247
248
249
250
251
252
253
254
255
256
257
258
259
260
261
262
263
264
265
266
267
268
269
270
271
272
273
274
275
276
277
278
279
280
281
282
283
284
285
286
287
288
289
290
291
292
293
294
295
296
297
298
299
300
301
302
303
304
305
306
307
308
309
310
311
312
313
</pre></td><td class="code"><pre><span class="k">pub</span> <span class="k">type</span> <span class="n">Steps</span> <span class="o">=</span> <span class="nb">u32</span><span class="p">;</span>

<span class="nd">#[derive(Debug,</span> <span class="nd">PartialEq,</span> <span class="nd">Eq,</span> <span class="nd">PartialOrd,</span> <span class="nd">Ord,</span> <span class="nd">Clone,</span> <span class="nd">Copy)]</span>
<span class="k">pub</span> <span class="k">enum</span> <span class="n">Heading</span> <span class="p">{</span>
    <span class="n">East</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">North</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="n">West</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
    <span class="n">South</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
<span class="p">}</span>

<span class="nd">#[derive(Debug,</span> <span class="nd">PartialEq,</span> <span class="nd">Eq,</span> <span class="nd">PartialOrd,</span> <span class="nd">Ord)]</span>
<span class="k">pub</span> <span class="k">struct</span> <span class="n">Boundary</span> <span class="p">{</span>
    <span class="n">offset</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
    <span class="n">heading</span><span class="p">:</span> <span class="n">Heading</span><span class="p">,</span>
    <span class="n">data</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">Steps</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">Boundary</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">from_matrix</span><span class="p">(</span>
        <span class="n">data</span><span class="p">:</span> <span class="o">&amp;</span><span class="p">[</span><span class="n">Steps</span><span class="p">],</span>
        <span class="n">w</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
        <span class="n">h</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
        <span class="n">heading</span><span class="p">:</span> <span class="n">Heading</span><span class="p">,</span>
        <span class="n">offset</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
    <span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">data</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">_</span><span class="o">&gt;</span> <span class="o">=</span> <span class="k">match</span> <span class="n">heading</span> <span class="p">{</span>
            <span class="nn">Heading</span><span class="p">::</span><span class="n">East</span> <span class="k">=&gt;</span> <span class="p">(</span><span class="mi">0</span><span class="o">..</span><span class="n">h</span><span class="p">)</span>
                <span class="nf">.map</span><span class="p">(|</span><span class="n">row_inv</span><span class="p">|</span> <span class="n">data</span><span class="p">[</span><span class="n">w</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">+</span> <span class="p">(</span><span class="n">h</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">row_inv</span><span class="p">)</span> <span class="o">*</span> <span class="n">w</span><span class="p">])</span>
                <span class="nf">.collect</span><span class="p">(),</span>
            <span class="nn">Heading</span><span class="p">::</span><span class="n">North</span> <span class="k">=&gt;</span> <span class="p">(</span><span class="mi">0</span><span class="o">..</span><span class="n">w</span><span class="p">)</span><span class="nf">.map</span><span class="p">(|</span><span class="n">col_inv</span><span class="p">|</span> <span class="n">data</span><span class="p">[</span><span class="n">w</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">col_inv</span><span class="p">])</span><span class="nf">.collect</span><span class="p">(),</span>
            <span class="nn">Heading</span><span class="p">::</span><span class="n">West</span> <span class="k">=&gt;</span> <span class="p">(</span><span class="mi">0</span><span class="o">..</span><span class="n">h</span><span class="p">)</span><span class="nf">.map</span><span class="p">(|</span><span class="n">row</span><span class="p">|</span> <span class="n">data</span><span class="p">[</span><span class="n">row</span> <span class="o">*</span> <span class="n">w</span><span class="p">])</span><span class="nf">.collect</span><span class="p">(),</span>
            <span class="nn">Heading</span><span class="p">::</span><span class="n">South</span> <span class="k">=&gt;</span> <span class="p">(</span><span class="mi">0</span><span class="o">..</span><span class="n">w</span><span class="p">)</span><span class="nf">.map</span><span class="p">(|</span><span class="n">col</span><span class="p">|</span> <span class="n">data</span><span class="p">[</span><span class="n">col</span> <span class="o">+</span> <span class="p">(</span><span class="n">h</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">w</span><span class="p">])</span><span class="nf">.collect</span><span class="p">(),</span>
        <span class="p">};</span>

        <span class="k">let</span> <span class="n">min_cost</span> <span class="o">=</span> <span class="o">*</span><span class="n">data</span><span class="nf">.iter</span><span class="p">()</span><span class="nf">.min</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">();</span>
        <span class="k">let</span> <span class="n">offset</span> <span class="o">=</span> <span class="k">if</span> <span class="n">min_cost</span> <span class="o">==</span> <span class="nn">Steps</span><span class="p">::</span><span class="n">MAX</span> <span class="p">{</span>
            <span class="nn">usize</span><span class="p">::</span><span class="n">MAX</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="n">data</span><span class="nf">.iter_mut</span><span class="p">()</span>
                <span class="nf">.filter</span><span class="p">(|</span><span class="n">d</span><span class="p">|</span> <span class="o">**</span><span class="n">d</span> <span class="o">!=</span> <span class="nn">Steps</span><span class="p">::</span><span class="n">MAX</span><span class="p">)</span>
                <span class="nf">.for_each</span><span class="p">(|</span><span class="n">d</span><span class="p">|</span> <span class="o">*</span><span class="n">d</span> <span class="o">-=</span> <span class="n">min_cost</span><span class="p">);</span>

            <span class="n">offset</span> <span class="o">+</span> <span class="n">min_cost</span> <span class="k">as</span> <span class="nb">usize</span>
        <span class="p">};</span>

        <span class="k">Self</span> <span class="p">{</span>
            <span class="n">data</span><span class="p">,</span>
            <span class="n">heading</span><span class="p">,</span>
            <span class="n">offset</span><span class="p">,</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="nd">#[derive(Debug,</span> <span class="nd">PartialEq,</span> <span class="nd">Eq)]</span>
<span class="k">pub</span> <span class="k">struct</span> <span class="n">Grid</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">pub</span><span class="p">(</span><span class="k">crate</span><span class="p">)</span> <span class="n">data</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="p">[</span><span class="nb">u8</span><span class="p">],</span>
    <span class="k">pub</span><span class="p">(</span><span class="k">crate</span><span class="p">)</span> <span class="n">w</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
    <span class="k">pub</span><span class="p">(</span><span class="k">crate</span><span class="p">)</span> <span class="n">h</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">mod</span> <span class="n">grid</span> <span class="p">{</span>
    <span class="k">use</span> <span class="k">super</span><span class="p">::</span><span class="n">Steps</span><span class="p">;</span>

    <span class="k">pub</span><span class="p">(</span><span class="k">crate</span><span class="p">)</span> <span class="k">fn</span> <span class="nf">cost_counts</span><span class="p">(</span><span class="n">costs</span><span class="p">:</span> <span class="o">&amp;</span><span class="p">[</span><span class="n">Steps</span><span class="p">])</span> <span class="k">-&gt;</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="n">costs</span><span class="nf">.iter</span><span class="p">()</span><span class="nf">.filter</span><span class="p">(|</span><span class="o">&amp;&amp;</span><span class="n">cost</span><span class="p">|</span> <span class="n">cost</span> <span class="o">!=</span> <span class="nn">Steps</span><span class="p">::</span><span class="n">MAX</span><span class="p">)</span><span class="nf">.fold</span><span class="p">(</span>
            <span class="nn">Vec</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span><span class="p">::</span><span class="nf">new</span><span class="p">(),</span>
            <span class="p">|</span><span class="k">mut</span> <span class="n">counts</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cost</span><span class="p">|</span> <span class="p">{</span>
                <span class="n">counts</span><span class="nf">.resize</span><span class="p">(</span><span class="n">counts</span><span class="nf">.len</span><span class="p">()</span><span class="nf">.max</span><span class="p">(</span><span class="n">cost</span> <span class="k">as</span> <span class="nb">usize</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
                <span class="n">counts</span><span class="p">[</span><span class="n">cost</span> <span class="k">as</span> <span class="nb">usize</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
                <span class="n">counts</span>
            <span class="p">},</span>
        <span class="p">)</span>
    <span class="p">}</span>

    <span class="k">pub</span><span class="p">(</span><span class="k">crate</span><span class="p">)</span> <span class="k">fn</span> <span class="nf">count_reachable</span><span class="p">(</span><span class="n">costs</span><span class="p">:</span> <span class="o">&amp;</span><span class="p">[</span><span class="n">Steps</span><span class="p">],</span> <span class="n">offset</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span> <span class="n">steps</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
        <span class="n">costs</span>
            <span class="nf">.iter</span><span class="p">()</span>
            <span class="nf">.map</span><span class="p">(|</span><span class="o">&amp;</span><span class="n">cost</span><span class="p">|</span> <span class="n">offset</span> <span class="o">+</span> <span class="n">cost</span> <span class="k">as</span> <span class="nb">usize</span><span class="p">)</span>
            <span class="nf">.filter</span><span class="p">(|</span><span class="o">&amp;</span><span class="n">cost</span><span class="p">|</span> <span class="n">cost</span> <span class="o">&lt;=</span> <span class="n">steps</span> <span class="o">&amp;&amp;</span> <span class="n">cost</span> <span class="o">&amp;</span> <span class="mi">1</span> <span class="o">==</span> <span class="n">steps</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span>
            <span class="nf">.count</span><span class="p">()</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">impl</span><span class="o">&lt;</span><span class="nv">'a</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="nb">From</span><span class="o">&lt;&amp;</span><span class="nv">'a</span> <span class="n">T</span><span class="o">&gt;</span> <span class="k">for</span> <span class="n">Grid</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span>
<span class="k">where</span>
    <span class="n">T</span><span class="p">:</span> <span class="nb">AsRef</span><span class="o">&lt;</span><span class="p">[</span><span class="nb">u8</span><span class="p">]</span><span class="o">&gt;</span> <span class="o">+</span> <span class="nv">'a</span> <span class="o">+</span> <span class="o">?</span><span class="nb">Sized</span><span class="p">,</span>
<span class="p">{</span>
    <span class="k">fn</span> <span class="nf">from</span><span class="p">(</span><span class="n">value</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="n">T</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">data</span> <span class="o">=</span> <span class="n">value</span><span class="nf">.as_ref</span><span class="p">();</span>
        <span class="k">let</span> <span class="n">w</span> <span class="o">=</span> <span class="n">data</span><span class="nf">.iter</span><span class="p">()</span><span class="nf">.position</span><span class="p">(|</span><span class="o">&amp;</span><span class="n">b</span><span class="p">|</span> <span class="n">b</span> <span class="o">==</span> <span class="sc">b'\n'</span><span class="p">)</span><span class="nf">.unwrap_or</span><span class="p">(</span><span class="n">data</span><span class="nf">.len</span><span class="p">());</span>
        <span class="k">let</span> <span class="n">h</span> <span class="o">=</span> <span class="p">(</span><span class="n">data</span><span class="nf">.len</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">w</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
        <span class="k">Self</span> <span class="p">{</span> <span class="n">data</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">h</span> <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">Grid</span><span class="o">&lt;</span><span class="nv">'_</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">get_start</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="p">(</span><span class="nb">usize</span><span class="p">,</span> <span class="nb">usize</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">self</span><span class="py">.data</span>
            <span class="nf">.iter</span><span class="p">()</span>
            <span class="nf">.position</span><span class="p">(|</span><span class="o">&amp;</span><span class="n">b</span><span class="p">|</span> <span class="n">b</span> <span class="o">==</span> <span class="sc">b'S'</span><span class="p">)</span>
            <span class="nf">.map</span><span class="p">(|</span><span class="n">p</span><span class="p">|</span> <span class="p">(</span><span class="n">p</span> <span class="o">%</span> <span class="p">(</span><span class="k">self</span><span class="py">.w</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="n">p</span> <span class="o">/</span> <span class="p">(</span><span class="k">self</span><span class="py">.w</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)))</span>
            <span class="nf">.unwrap</span><span class="p">()</span>
    <span class="p">}</span>

    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">reachable_in_steps</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">steps</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
        <span class="nd">assert!</span><span class="p">(</span><span class="k">self</span><span class="py">.w</span> <span class="o">==</span> <span class="k">self</span><span class="py">.h</span><span class="p">);</span>

        <span class="k">let</span> <span class="p">(</span><span class="k">mut</span> <span class="n">total_count</span><span class="p">,</span> <span class="n">boundaries</span><span class="p">)</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.center_tile_boundaries</span><span class="p">(</span><span class="n">steps</span><span class="p">);</span>

        <span class="k">for</span> <span class="n">boundary</span> <span class="k">in</span> <span class="n">boundaries</span>
            <span class="nf">.as_ref</span><span class="p">()</span>
            <span class="nf">.iter</span><span class="p">()</span>
            <span class="nf">.filter</span><span class="p">(|</span><span class="n">boundary</span><span class="p">|</span> <span class="n">boundary</span><span class="py">.offset</span> <span class="o">!=</span> <span class="nn">usize</span><span class="p">::</span><span class="n">MAX</span> <span class="o">&amp;&amp;</span> <span class="n">boundary</span><span class="py">.data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="nn">Steps</span><span class="p">::</span><span class="n">MAX</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">let</span> <span class="n">offset</span> <span class="o">=</span> <span class="n">boundary</span><span class="py">.offset</span> <span class="o">+</span> <span class="n">boundary</span><span class="py">.data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">as</span> <span class="nb">usize</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
            <span class="k">let</span> <span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="o">..</span><span class="n">boundary</span><span class="py">.data</span><span class="nf">.len</span><span class="p">()</span> <span class="k">as</span> <span class="n">Steps</span><span class="p">)</span><span class="nf">.rev</span><span class="p">()</span><span class="nf">.collect</span><span class="p">();</span>
            <span class="k">let</span> <span class="n">boundary</span> <span class="o">=</span> <span class="n">Boundary</span> <span class="p">{</span>
                <span class="n">data</span><span class="p">,</span>
                <span class="n">offset</span><span class="p">,</span>
                <span class="n">heading</span><span class="p">:</span> <span class="n">boundary</span><span class="py">.heading</span><span class="p">,</span>
            <span class="p">};</span>
            <span class="k">let</span> <span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="n">costs</span><span class="p">)</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.next_boundary</span><span class="p">(</span><span class="o">&amp;</span><span class="n">boundary</span><span class="p">,</span> <span class="nn">usize</span><span class="p">::</span><span class="n">MAX</span><span class="p">);</span>
            <span class="k">let</span> <span class="n">cost_counts</span> <span class="o">=</span> <span class="nn">grid</span><span class="p">::</span><span class="nf">cost_counts</span><span class="p">(</span><span class="o">&amp;</span><span class="n">costs</span><span class="p">);</span>

            <span class="c1">// fits if offset + (s - 1) * self.w + max_steps &lt;= steps</span>
            <span class="c1">// (s - 1) * self.w &lt;= (steps - offset - max_steps)</span>
            <span class="k">let</span> <span class="n">n</span> <span class="o">=</span> <span class="p">(</span><span class="n">steps</span> <span class="o">+</span> <span class="k">self</span><span class="py">.w</span><span class="p">)</span><span class="nf">.saturating_sub</span><span class="p">(</span><span class="n">offset</span> <span class="o">+</span> <span class="n">cost_counts</span><span class="nf">.len</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="k">self</span><span class="py">.w</span><span class="p">;</span>

            <span class="c1">// short cut as long as max_step fits</span>
            <span class="k">if</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
                <span class="k">let</span> <span class="n">cost_counts_even</span> <span class="o">=</span> <span class="n">cost_counts</span><span class="nf">.iter</span><span class="p">()</span><span class="nf">.step_by</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="nf">.skip</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="py">.sum</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span><span class="p">();</span>
                <span class="k">let</span> <span class="n">cost_counts_odd</span> <span class="o">=</span> <span class="n">cost_counts</span><span class="nf">.iter</span><span class="p">()</span><span class="nf">.skip</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="nf">.step_by</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="py">.sum</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span><span class="p">();</span>

                <span class="c1">// sum of even numbers from 1 to n</span>
                <span class="k">let</span> <span class="n">sum_even</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">n</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">n</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
                <span class="c1">// sum of odd numbers from 1 to n</span>
                <span class="k">let</span> <span class="n">sum_odd</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="p">((</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">((</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">-</span> <span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>

                <span class="n">total_count</span> <span class="o">+=</span> <span class="k">if</span> <span class="p">(</span><span class="n">steps</span> <span class="o">-</span> <span class="n">offset</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">1</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
                    <span class="n">sum_odd</span> <span class="o">*</span> <span class="n">cost_counts_even</span> <span class="o">+</span> <span class="n">sum_even</span> <span class="o">*</span> <span class="n">cost_counts_odd</span>
                <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                    <span class="n">sum_odd</span> <span class="o">*</span> <span class="n">cost_counts_odd</span> <span class="o">+</span> <span class="n">sum_even</span> <span class="o">*</span> <span class="n">cost_counts_even</span>
                <span class="p">};</span>
            <span class="p">}</span>

            <span class="c1">// do the counting for the remaining tiles</span>
            <span class="k">for</span> <span class="n">s</span> <span class="k">in</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="o">..</span> <span class="p">{</span>
                <span class="k">let</span> <span class="n">off</span> <span class="o">=</span> <span class="n">offset</span> <span class="o">+</span> <span class="p">(</span><span class="n">s</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="k">self</span><span class="py">.w</span><span class="p">;</span>
                <span class="k">let</span> <span class="n">count</span> <span class="o">=</span> <span class="nn">grid</span><span class="p">::</span><span class="nf">count_reachable</span><span class="p">(</span><span class="o">&amp;</span><span class="n">costs</span><span class="p">,</span> <span class="n">off</span><span class="p">,</span> <span class="n">steps</span><span class="p">);</span>
                <span class="n">total_count</span> <span class="o">+=</span> <span class="n">s</span> <span class="o">*</span> <span class="n">count</span><span class="p">;</span>

                <span class="k">if</span> <span class="n">count</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
                    <span class="k">break</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="k">for</span> <span class="n">boundary</span> <span class="k">in</span> <span class="n">boundaries</span>
            <span class="nf">.into_iter</span><span class="p">()</span>
            <span class="nf">.filter</span><span class="p">(|</span><span class="n">boundary</span><span class="p">|</span> <span class="n">boundary</span><span class="py">.offset</span> <span class="o">!=</span> <span class="nn">usize</span><span class="p">::</span><span class="n">MAX</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="c1">// find steady state</span>
            <span class="k">let</span> <span class="k">mut</span> <span class="n">cur</span> <span class="o">=</span> <span class="n">boundary</span><span class="p">;</span>
            <span class="k">let</span> <span class="n">steady_state</span> <span class="o">=</span> <span class="k">loop</span> <span class="p">{</span>
                <span class="k">let</span> <span class="p">(</span><span class="n">next</span><span class="p">,</span> <span class="n">costs</span><span class="p">)</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.next_boundary</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cur</span><span class="p">,</span> <span class="n">steps</span><span class="p">);</span>
                <span class="n">total_count</span> <span class="o">+=</span> <span class="nn">grid</span><span class="p">::</span><span class="nf">count_reachable</span><span class="p">(</span><span class="o">&amp;</span><span class="n">costs</span><span class="p">,</span> <span class="n">cur</span><span class="py">.offset</span><span class="p">,</span> <span class="n">steps</span><span class="p">);</span>

                <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">next</span><span class="p">)</span> <span class="o">=</span> <span class="n">next</span> <span class="k">else</span> <span class="p">{</span> <span class="k">break</span> <span class="nb">None</span> <span class="p">};</span>
                <span class="k">if</span> <span class="n">cur</span><span class="py">.data</span> <span class="o">==</span> <span class="n">next</span><span class="py">.data</span> <span class="p">{</span>
                    <span class="k">break</span> <span class="nf">Some</span><span class="p">((</span><span class="n">next</span><span class="p">,</span> <span class="n">costs</span><span class="p">));</span>
                <span class="p">}</span>
                <span class="n">cur</span> <span class="o">=</span> <span class="n">next</span><span class="p">;</span>
            <span class="p">};</span>

            <span class="k">let</span> <span class="nf">Some</span><span class="p">((</span><span class="n">boundary</span><span class="p">,</span> <span class="n">costs</span><span class="p">))</span> <span class="o">=</span> <span class="n">steady_state</span> <span class="k">else</span> <span class="p">{</span>
                <span class="k">continue</span><span class="p">;</span>
            <span class="p">};</span>
            <span class="k">let</span> <span class="n">offset</span> <span class="o">=</span> <span class="n">boundary</span><span class="py">.offset</span><span class="p">;</span>

            <span class="k">let</span> <span class="n">cost_counts</span> <span class="o">=</span> <span class="nn">grid</span><span class="p">::</span><span class="nf">cost_counts</span><span class="p">(</span><span class="o">&amp;</span><span class="n">costs</span><span class="p">);</span>

            <span class="c1">// fits if offset + (s - 1) * self.w + max_steps &lt;= steps</span>
            <span class="c1">// (s - 1) * self.w &lt;= (steps - offset - max_steps)</span>
            <span class="k">let</span> <span class="n">n</span> <span class="o">=</span> <span class="p">(</span><span class="n">steps</span> <span class="o">+</span> <span class="k">self</span><span class="py">.w</span><span class="p">)</span><span class="nf">.saturating_sub</span><span class="p">(</span><span class="n">offset</span> <span class="o">+</span> <span class="n">cost_counts</span><span class="nf">.len</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="k">self</span><span class="py">.w</span><span class="p">;</span>

            <span class="k">if</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
                <span class="k">let</span> <span class="n">cost_counts_even</span> <span class="o">=</span> <span class="n">cost_counts</span><span class="nf">.iter</span><span class="p">()</span><span class="nf">.step_by</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="nf">.skip</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="py">.sum</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span><span class="p">();</span>
                <span class="k">let</span> <span class="n">cost_counts_odd</span> <span class="o">=</span> <span class="n">cost_counts</span><span class="nf">.iter</span><span class="p">()</span><span class="nf">.skip</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="nf">.step_by</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="py">.sum</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span><span class="p">();</span>

                <span class="n">total_count</span> <span class="o">+=</span> <span class="k">if</span> <span class="p">(</span><span class="n">steps</span> <span class="o">-</span> <span class="n">offset</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">1</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
                    <span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">cost_counts_even</span> <span class="o">+</span> <span class="p">(</span><span class="n">n</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">cost_counts_odd</span>
                <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                    <span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">cost_counts_odd</span> <span class="o">+</span> <span class="p">(</span><span class="n">n</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">cost_counts_even</span>
                <span class="p">};</span>
            <span class="p">}</span>

            <span class="k">for</span> <span class="n">s</span> <span class="k">in</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="o">..</span> <span class="p">{</span>
                <span class="k">let</span> <span class="n">count</span> <span class="o">=</span> <span class="nn">grid</span><span class="p">::</span><span class="nf">count_reachable</span><span class="p">(</span><span class="o">&amp;</span><span class="n">costs</span><span class="p">,</span> <span class="n">offset</span> <span class="o">+</span> <span class="p">(</span><span class="n">s</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="k">self</span><span class="py">.w</span><span class="p">,</span> <span class="n">steps</span><span class="p">);</span>
                <span class="n">total_count</span> <span class="o">+=</span> <span class="n">count</span><span class="p">;</span>
                <span class="k">if</span> <span class="n">count</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
                    <span class="k">break</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="n">total_count</span>
    <span class="p">}</span>

    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">next_boundary</span><span class="p">(</span>
        <span class="o">&amp;</span><span class="k">self</span><span class="p">,</span>
        <span class="n">boundary</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Boundary</span><span class="p">,</span>
        <span class="n">steps</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
    <span class="p">)</span> <span class="k">-&gt;</span> <span class="p">(</span><span class="nb">Option</span><span class="o">&lt;</span><span class="n">Boundary</span><span class="o">&gt;</span><span class="p">,</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">Steps</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">let</span> <span class="p">(</span><span class="n">off_c</span><span class="p">,</span> <span class="n">fac_c</span><span class="p">,</span> <span class="n">off_r</span><span class="p">,</span> <span class="n">fac_r</span><span class="p">)</span> <span class="o">=</span> <span class="k">match</span> <span class="n">boundary</span><span class="py">.heading</span> <span class="p">{</span>
            <span class="nn">Heading</span><span class="p">::</span><span class="n">East</span> <span class="k">=&gt;</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">self</span><span class="py">.h</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span>
            <span class="nn">Heading</span><span class="p">::</span><span class="n">North</span> <span class="k">=&gt;</span> <span class="p">(</span><span class="k">self</span><span class="py">.w</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="k">self</span><span class="py">.h</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
            <span class="nn">Heading</span><span class="p">::</span><span class="n">West</span> <span class="k">=&gt;</span> <span class="p">(</span><span class="k">self</span><span class="py">.w</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
            <span class="nn">Heading</span><span class="p">::</span><span class="n">South</span> <span class="k">=&gt;</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
        <span class="p">};</span>
        <span class="k">let</span> <span class="p">(</span><span class="k">mut</span> <span class="n">queue</span><span class="p">,</span> <span class="k">mut</span> <span class="n">costs</span><span class="p">)</span> <span class="o">=</span> <span class="n">boundary</span>
            <span class="py">.data</span>
            <span class="nf">.iter</span><span class="p">()</span>
            <span class="nf">.enumerate</span><span class="p">()</span>
            <span class="nf">.map</span><span class="p">(|(</span><span class="n">v</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">d</span><span class="p">)|</span> <span class="p">{</span>
                <span class="p">(</span>
                    <span class="n">d</span><span class="nf">.saturating_add</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span>
                    <span class="p">(</span>
                        <span class="n">off_c</span><span class="nf">.wrapping_add_signed</span><span class="p">(</span><span class="n">fac_c</span> <span class="o">*</span> <span class="n">v</span> <span class="k">as</span> <span class="nb">isize</span><span class="p">),</span>
                        <span class="n">off_r</span><span class="nf">.wrapping_add_signed</span><span class="p">(</span><span class="n">fac_r</span> <span class="o">*</span> <span class="n">v</span> <span class="k">as</span> <span class="nb">isize</span><span class="p">),</span>
                    <span class="p">),</span>
                <span class="p">)</span>
            <span class="p">})</span>
            <span class="nf">.fold</span><span class="p">(</span>
                <span class="p">(</span><span class="nn">BinaryHeap</span><span class="p">::</span><span class="nf">new</span><span class="p">(),</span> <span class="nd">vec!</span><span class="p">[</span><span class="nn">Steps</span><span class="p">::</span><span class="n">MAX</span><span class="p">;</span> <span class="k">self</span><span class="py">.w</span> <span class="o">*</span> <span class="k">self</span><span class="py">.h</span><span class="p">]),</span>
                <span class="p">|(</span><span class="k">mut</span> <span class="n">heap</span><span class="p">,</span> <span class="k">mut</span> <span class="n">costs</span><span class="p">),</span> <span class="p">(</span><span class="n">cost</span><span class="p">,</span> <span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="n">row</span><span class="p">))|</span> <span class="p">{</span>
                    <span class="n">heap</span><span class="nf">.push</span><span class="p">((</span><span class="o">!</span><span class="n">cost</span><span class="p">,</span> <span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="n">row</span><span class="p">)));</span>
                    <span class="n">costs</span><span class="p">[</span><span class="n">col</span> <span class="o">+</span> <span class="n">row</span> <span class="o">*</span> <span class="k">self</span><span class="py">.w</span><span class="p">]</span> <span class="o">=</span> <span class="n">cost</span><span class="p">;</span>
                    <span class="p">(</span><span class="n">heap</span><span class="p">,</span> <span class="n">costs</span><span class="p">)</span>
                <span class="p">},</span>
            <span class="p">);</span>

        <span class="k">while</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">((</span><span class="n">cost</span><span class="p">,</span> <span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="n">row</span><span class="p">)))</span> <span class="o">=</span> <span class="n">queue</span><span class="nf">.pop</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">if</span> <span class="n">boundary</span><span class="py">.offset</span> <span class="o">==</span> <span class="nn">usize</span><span class="p">::</span><span class="n">MAX</span> <span class="p">||</span> <span class="n">boundary</span><span class="py">.offset</span> <span class="o">+</span> <span class="o">!</span><span class="n">cost</span> <span class="k">as</span> <span class="nb">usize</span> <span class="o">&gt;=</span> <span class="n">steps</span> <span class="p">{</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="c1">// add adjacents</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="n">row</span><span class="p">)</span> <span class="k">in</span> <span class="p">[(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)]</span>
                <span class="nf">.into_iter</span><span class="p">()</span>
                <span class="nf">.map</span><span class="p">(|(</span><span class="n">dc</span><span class="p">,</span> <span class="n">dr</span><span class="p">)|</span> <span class="p">(</span><span class="n">col</span><span class="nf">.wrapping_add_signed</span><span class="p">(</span><span class="n">dc</span><span class="p">),</span> <span class="n">row</span><span class="nf">.wrapping_add_signed</span><span class="p">(</span><span class="n">dr</span><span class="p">)))</span>
                <span class="nf">.filter</span><span class="p">(|</span><span class="o">&amp;</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="n">row</span><span class="p">)|</span> <span class="p">{</span>
                    <span class="p">(</span><span class="n">col</span> <span class="o">&lt;</span> <span class="k">self</span><span class="py">.w</span> <span class="o">&amp;&amp;</span> <span class="n">row</span> <span class="o">&lt;</span> <span class="k">self</span><span class="py">.h</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="k">self</span><span class="py">.data</span><span class="p">[</span><span class="n">col</span> <span class="o">+</span> <span class="n">row</span> <span class="o">*</span> <span class="p">(</span><span class="k">self</span><span class="py">.w</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span> <span class="o">!=</span> <span class="sc">b'#'</span>
                <span class="p">})</span>
            <span class="p">{</span>
                <span class="k">if</span> <span class="n">costs</span><span class="p">[</span><span class="n">col</span> <span class="o">+</span> <span class="n">row</span> <span class="o">*</span> <span class="k">self</span><span class="py">.w</span><span class="p">]</span> <span class="o">==</span> <span class="nn">Steps</span><span class="p">::</span><span class="n">MAX</span> <span class="p">{</span>
                    <span class="n">costs</span><span class="p">[</span><span class="n">col</span> <span class="o">+</span> <span class="n">row</span> <span class="o">*</span> <span class="k">self</span><span class="py">.w</span><span class="p">]</span> <span class="o">=</span> <span class="o">!</span><span class="n">cost</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
                    <span class="n">queue</span><span class="nf">.push</span><span class="p">((</span><span class="n">cost</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="n">row</span><span class="p">)));</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="k">let</span> <span class="n">next</span> <span class="o">=</span> <span class="nn">Boundary</span><span class="p">::</span><span class="nf">from_matrix</span><span class="p">(</span><span class="o">&amp;</span><span class="n">costs</span><span class="p">,</span> <span class="k">self</span><span class="py">.w</span><span class="p">,</span> <span class="k">self</span><span class="py">.h</span><span class="p">,</span> <span class="n">boundary</span><span class="py">.heading</span><span class="p">,</span> <span class="n">boundary</span><span class="py">.offset</span><span class="p">);</span>

        <span class="p">((</span><span class="n">next</span><span class="py">.offset</span> <span class="o">!=</span> <span class="nn">usize</span><span class="p">::</span><span class="n">MAX</span><span class="p">)</span><span class="nf">.then_some</span><span class="p">(</span><span class="n">next</span><span class="p">),</span> <span class="n">costs</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">center_tile_costs</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">steps</span><span class="p">:</span> <span class="n">Steps</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="p">(</span><span class="n">Steps</span><span class="p">,</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">Steps</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">start</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.get_start</span><span class="p">();</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">costs</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[</span><span class="nn">Steps</span><span class="p">::</span><span class="n">MAX</span><span class="p">;</span> <span class="k">self</span><span class="py">.w</span> <span class="o">*</span> <span class="k">self</span><span class="py">.h</span><span class="p">];</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">queue</span> <span class="o">=</span> <span class="nn">VecDeque</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
        <span class="n">costs</span><span class="p">[</span><span class="n">start</span><span class="na">.0</span> <span class="o">+</span> <span class="n">start</span><span class="na">.1</span> <span class="o">*</span> <span class="k">self</span><span class="py">.w</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">queue</span><span class="nf">.push_back</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="n">start</span><span class="p">));</span>

        <span class="k">while</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">((</span><span class="n">cost</span><span class="p">,</span> <span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="n">row</span><span class="p">)))</span> <span class="o">=</span> <span class="n">queue</span><span class="nf">.pop_front</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">if</span> <span class="n">cost</span> <span class="o">&gt;=</span> <span class="n">steps</span> <span class="p">{</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="k">for</span> <span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="n">row</span><span class="p">)</span> <span class="k">in</span> <span class="p">[(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)]</span>
                <span class="nf">.into_iter</span><span class="p">()</span>
                <span class="nf">.map</span><span class="p">(|(</span><span class="n">dc</span><span class="p">,</span> <span class="n">dr</span><span class="p">)|</span> <span class="p">(</span><span class="n">col</span><span class="nf">.wrapping_add_signed</span><span class="p">(</span><span class="n">dc</span><span class="p">),</span> <span class="n">row</span><span class="nf">.wrapping_add_signed</span><span class="p">(</span><span class="n">dr</span><span class="p">)))</span>
                <span class="nf">.filter</span><span class="p">(|</span><span class="o">&amp;</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="n">row</span><span class="p">)|</span> <span class="p">{</span>
                    <span class="p">(</span><span class="n">col</span> <span class="o">&lt;</span> <span class="k">self</span><span class="py">.w</span> <span class="o">&amp;&amp;</span> <span class="n">row</span> <span class="o">&lt;</span> <span class="k">self</span><span class="py">.h</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="k">self</span><span class="py">.data</span><span class="p">[</span><span class="n">col</span> <span class="o">+</span> <span class="n">row</span> <span class="o">*</span> <span class="p">(</span><span class="k">self</span><span class="py">.w</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span> <span class="o">!=</span> <span class="sc">b'#'</span>
                <span class="p">})</span>
            <span class="p">{</span>
                <span class="k">if</span> <span class="n">costs</span><span class="p">[</span><span class="n">col</span> <span class="o">+</span> <span class="n">row</span> <span class="o">*</span> <span class="k">self</span><span class="py">.w</span><span class="p">]</span> <span class="o">==</span> <span class="nn">Steps</span><span class="p">::</span><span class="n">MAX</span> <span class="p">{</span>
                    <span class="n">costs</span><span class="p">[</span><span class="n">col</span> <span class="o">+</span> <span class="n">row</span> <span class="o">*</span> <span class="k">self</span><span class="py">.w</span><span class="p">]</span> <span class="o">=</span> <span class="n">cost</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
                    <span class="n">queue</span><span class="nf">.push_back</span><span class="p">((</span><span class="n">cost</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="n">row</span><span class="p">)));</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="k">let</span> <span class="n">count</span> <span class="o">=</span> <span class="n">costs</span>
            <span class="nf">.iter</span><span class="p">()</span>
            <span class="nf">.filter</span><span class="p">(|</span><span class="o">&amp;&amp;</span><span class="n">c</span><span class="p">|</span> <span class="n">c</span> <span class="o">&lt;=</span> <span class="n">steps</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">c</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="n">steps</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">))</span>
            <span class="nf">.count</span><span class="p">();</span>
        <span class="p">(</span><span class="n">count</span> <span class="k">as</span> <span class="n">_</span><span class="p">,</span> <span class="n">costs</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">center_tile_boundaries</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">steps</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="p">(</span><span class="nb">usize</span><span class="p">,</span> <span class="p">[</span><span class="n">Boundary</span><span class="p">;</span> <span class="mi">4</span><span class="p">])</span> <span class="p">{</span>
        <span class="k">let</span> <span class="p">(</span><span class="n">count</span><span class="p">,</span> <span class="n">costs</span><span class="p">)</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.center_tile_costs</span><span class="p">(</span><span class="n">steps</span><span class="nf">.min</span><span class="p">(</span><span class="nn">Steps</span><span class="p">::</span><span class="n">MAX</span> <span class="k">as</span> <span class="n">_</span><span class="p">)</span> <span class="k">as</span> <span class="n">_</span><span class="p">);</span>

        <span class="p">(</span>
            <span class="n">count</span> <span class="k">as</span> <span class="n">_</span><span class="p">,</span>
            <span class="p">[</span>
                <span class="nn">Boundary</span><span class="p">::</span><span class="nf">from_matrix</span><span class="p">(</span><span class="o">&amp;</span><span class="n">costs</span><span class="p">,</span> <span class="k">self</span><span class="py">.w</span><span class="p">,</span> <span class="k">self</span><span class="py">.h</span><span class="p">,</span> <span class="nn">Heading</span><span class="p">::</span><span class="n">East</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
                <span class="nn">Boundary</span><span class="p">::</span><span class="nf">from_matrix</span><span class="p">(</span><span class="o">&amp;</span><span class="n">costs</span><span class="p">,</span> <span class="k">self</span><span class="py">.w</span><span class="p">,</span> <span class="k">self</span><span class="py">.h</span><span class="p">,</span> <span class="nn">Heading</span><span class="p">::</span><span class="n">North</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
                <span class="nn">Boundary</span><span class="p">::</span><span class="nf">from_matrix</span><span class="p">(</span><span class="o">&amp;</span><span class="n">costs</span><span class="p">,</span> <span class="k">self</span><span class="py">.w</span><span class="p">,</span> <span class="k">self</span><span class="py">.h</span><span class="p">,</span> <span class="nn">Heading</span><span class="p">::</span><span class="n">West</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
                <span class="nn">Boundary</span><span class="p">::</span><span class="nf">from_matrix</span><span class="p">(</span><span class="o">&amp;</span><span class="n">costs</span><span class="p">,</span> <span class="k">self</span><span class="py">.w</span><span class="p">,</span> <span class="k">self</span><span class="py">.h</span><span class="p">,</span> <span class="nn">Heading</span><span class="p">::</span><span class="n">South</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
            <span class="p">],</span>
        <span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p><a href="#top">Top</a></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="sol-rust-22">Rust | Day 22: Sand Slabs</h2>
<div class="sectionbody">
<div class="paragraph">
<p><a href="https://rust-lang.org">Rust</a> solution to <a href="https://adventofcode.com/2023/day/22">AoC|2023|22</a>.</p>
</div>
<div class="paragraph">
<p>Feels a bit like Tetris in 3D. I felt reminded of <a href="https://adventofcode.com/2022/day/17">Aoc|2022|17</a>, but in the end it was very different.</p>
</div>
<div class="sect2">
<h3 id="_input_17">Input</h3>
<div class="paragraph">
<p>I decided to create some <code>struct</code> types today. The input is parsed into a <code>Vec</code> of <code>Brick</code> elements. Each <code>Brick</code> is a pair of <code>Point</code> elements.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
</pre></td><td class="code"><pre><span class="k">pub</span> <span class="k">mod</span> <span class="n">input</span> <span class="p">{</span>
    <span class="k">use</span> <span class="k">crate</span><span class="p">::{</span><span class="n">Brick</span><span class="p">,</span> <span class="n">Point</span><span class="p">};</span>

    <span class="nd">#[derive(Debug)]</span>
    <span class="k">pub</span> <span class="k">struct</span> <span class="nf">PuzzleData</span><span class="p">(</span><span class="k">pub</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">Brick</span><span class="o">&gt;</span><span class="p">);</span>

    <span class="k">impl</span> <span class="nb">From</span><span class="o">&lt;&amp;</span><span class="nb">str</span><span class="o">&gt;</span> <span class="k">for</span> <span class="n">Point</span> <span class="p">{</span>
        <span class="k">fn</span> <span class="nf">from</span><span class="p">(</span><span class="n">value</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
            <span class="k">let</span> <span class="k">mut</span> <span class="n">values</span> <span class="o">=</span> <span class="n">value</span><span class="nf">.split</span><span class="p">(</span><span class="sc">','</span><span class="p">)</span><span class="nf">.map</span><span class="p">(|</span><span class="n">v</span><span class="p">|</span> <span class="n">v</span><span class="nf">.parse</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">());</span>
            <span class="k">Self</span> <span class="p">{</span>
                <span class="n">x</span><span class="p">:</span> <span class="n">values</span><span class="nf">.next</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">(),</span>
                <span class="n">y</span><span class="p">:</span> <span class="n">values</span><span class="nf">.next</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">(),</span>
                <span class="n">z</span><span class="p">:</span> <span class="n">values</span><span class="nf">.next</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">(),</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">impl</span> <span class="nb">From</span><span class="o">&lt;&amp;</span><span class="nb">str</span><span class="o">&gt;</span> <span class="k">for</span> <span class="n">Brick</span> <span class="p">{</span>
        <span class="k">fn</span> <span class="nf">from</span><span class="p">(</span><span class="n">value</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
            <span class="n">value</span>
                <span class="nf">.split_once</span><span class="p">(</span><span class="sc">'~'</span><span class="p">)</span>
                <span class="nf">.map</span><span class="p">(|(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)|</span> <span class="k">Self</span><span class="p">(</span><span class="n">a</span><span class="nf">.into</span><span class="p">(),</span> <span class="n">b</span><span class="nf">.into</span><span class="p">()))</span>
                <span class="nf">.unwrap</span><span class="p">()</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="nb">From</span><span class="o">&lt;&amp;</span><span class="n">T</span><span class="o">&gt;</span> <span class="k">for</span> <span class="n">PuzzleData</span>
    <span class="k">where</span>
        <span class="n">T</span><span class="p">:</span> <span class="nb">AsRef</span><span class="o">&lt;</span><span class="nb">str</span><span class="o">&gt;</span> <span class="o">+</span> <span class="o">?</span><span class="nb">Sized</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="k">fn</span> <span class="nf">from</span><span class="p">(</span><span class="n">s</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">T</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
            <span class="k">Self</span><span class="p">(</span><span class="n">s</span><span class="nf">.as_ref</span><span class="p">()</span><span class="nf">.lines</span><span class="p">()</span><span class="nf">.map</span><span class="p">(</span><span class="nn">Brick</span><span class="p">::</span><span class="n">from</span><span class="p">)</span><span class="nf">.collect</span><span class="p">())</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_star_1_2_2">Star 1 &amp; 2</h3>
<div class="paragraph">
<p>Since settling the <code>SandStack</code> consumes an important part of the runtime (probably with a bit of room for optimization), I wanted to do it only once and implemented both solutions in one function.</p>
</div>
<div class="paragraph">
<p>Here is my lengthy solution. The key parts are</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Build the sand stack and figure out which bricks are on top of each other; main parts implemented in <code>SandStack::from</code>, <code>Brick::compare</code>. The compare function will also return the upper <code>z</code>-coordinate of the lower brick.</p>
</li>
<li>
<p>Settle the stack, so that everything is touching either a brick below or solid ground: <code>SandStack::settle</code> uses recursive <code>SandStack::settle_rec</code></p>
</li>
<li>
<p>Solution to part 1 in <code>SandStack::count_disintegrateable</code></p>
</li>
<li>
<p>Solution to part 2 in <code>SandStack::sum_count_falling</code> - a kind of 'lowest-first-traversal'. Could maybe be optimized with some caching.</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno">  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16
 17
 18
 19
 20
 21
 22
 23
 24
 25
 26
 27
 28
 29
 30
 31
 32
 33
 34
 35
 36
 37
 38
 39
 40
 41
 42
 43
 44
 45
 46
 47
 48
 49
 50
 51
 52
 53
 54
 55
 56
 57
 58
 59
 60
 61
 62
 63
 64
 65
 66
 67
 68
 69
 70
 71
 72
 73
 74
 75
 76
 77
 78
 79
 80
 81
 82
 83
 84
 85
 86
 87
 88
 89
 90
 91
 92
 93
 94
 95
 96
 97
 98
 99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
166
167
168
169
170
171
172
173
174
175
176
177
178
179
180
</pre></td><td class="code"><pre><span class="k">pub</span> <span class="k">type</span> <span class="n">Coord</span> <span class="o">=</span> <span class="nb">usize</span><span class="p">;</span>

<span class="nd">#[derive(Debug,</span> <span class="nd">PartialEq,</span> <span class="nd">Eq,</span> <span class="nd">PartialOrd,</span> <span class="nd">Ord,</span> <span class="nd">Clone,</span> <span class="nd">Copy)]</span>
<span class="k">pub</span> <span class="k">struct</span> <span class="n">Point</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="n">x</span><span class="p">:</span> <span class="n">Coord</span><span class="p">,</span>
    <span class="k">pub</span> <span class="n">y</span><span class="p">:</span> <span class="n">Coord</span><span class="p">,</span>
    <span class="k">pub</span> <span class="n">z</span><span class="p">:</span> <span class="n">Coord</span><span class="p">,</span>
<span class="p">}</span>

<span class="nd">#[derive(Debug,</span> <span class="nd">PartialEq,</span> <span class="nd">Eq,</span> <span class="nd">PartialOrd,</span> <span class="nd">Ord,</span> <span class="nd">Clone,</span> <span class="nd">Copy)]</span>
<span class="k">pub</span> <span class="k">struct</span> <span class="nf">Brick</span><span class="p">(</span><span class="k">pub</span> <span class="n">Point</span><span class="p">,</span> <span class="k">pub</span> <span class="n">Point</span><span class="p">);</span>

<span class="k">pub</span> <span class="k">struct</span> <span class="n">SandStack</span> <span class="p">{</span>
    <span class="n">bricks</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">Brick</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="n">belows</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="p">(</span><span class="nb">usize</span><span class="p">,</span> <span class="n">Coord</span><span class="p">)</span><span class="o">&gt;&gt;</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">trait</span> <span class="n">Intersect</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">intersect</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">Self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">Intersect</span> <span class="k">for</span> <span class="n">RangeInclusive</span><span class="o">&lt;</span><span class="n">Coord</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">intersect</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">Self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
        <span class="o">*</span><span class="k">self</span><span class="nf">.start</span><span class="p">()</span><span class="nf">.max</span><span class="p">(</span><span class="n">other</span><span class="nf">.start</span><span class="p">())</span><span class="o">..=*</span><span class="k">self</span><span class="nf">.end</span><span class="p">()</span><span class="nf">.min</span><span class="p">(</span><span class="n">other</span><span class="nf">.end</span><span class="p">())</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="nb">From</span><span class="o">&lt;</span><span class="p">(</span><span class="n">Coord</span><span class="p">,</span> <span class="n">Coord</span><span class="p">,</span> <span class="n">Coord</span><span class="p">)</span><span class="o">&gt;</span> <span class="k">for</span> <span class="n">Point</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">from</span><span class="p">((</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">):</span> <span class="p">(</span><span class="n">Coord</span><span class="p">,</span> <span class="n">Coord</span><span class="p">,</span> <span class="n">Coord</span><span class="p">))</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
        <span class="k">Self</span> <span class="p">{</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">Brick</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">compare</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">Self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="p">(</span><span class="n">Ordering</span><span class="p">,</span> <span class="n">Coord</span><span class="p">)</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">if</span> <span class="o">!</span><span class="k">self</span><span class="nf">.x_range</span><span class="p">()</span><span class="nf">.intersect</span><span class="p">(</span><span class="o">&amp;</span><span class="n">other</span><span class="nf">.x_range</span><span class="p">())</span><span class="nf">.is_empty</span><span class="p">()</span>
            <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="k">self</span><span class="nf">.y_range</span><span class="p">()</span><span class="nf">.intersect</span><span class="p">(</span><span class="o">&amp;</span><span class="n">other</span><span class="nf">.y_range</span><span class="p">())</span><span class="nf">.is_empty</span><span class="p">()</span>
        <span class="p">{</span>
            <span class="nf">Some</span><span class="p">((</span>
                <span class="k">self</span><span class="nf">.top_z</span><span class="p">()</span><span class="nf">.cmp</span><span class="p">(</span><span class="o">&amp;</span><span class="n">other</span><span class="nf">.top_z</span><span class="p">()),</span>
                <span class="k">self</span><span class="nf">.top_z</span><span class="p">()</span><span class="nf">.min</span><span class="p">(</span><span class="n">other</span><span class="nf">.top_z</span><span class="p">()),</span>
            <span class="p">))</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="nb">None</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">x_range</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">RangeInclusive</span><span class="o">&lt;</span><span class="n">Coord</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">self</span><span class="na">.0</span><span class="py">.x</span><span class="nf">.min</span><span class="p">(</span><span class="k">self</span><span class="na">.1</span><span class="py">.x</span><span class="p">)</span><span class="o">..=</span><span class="k">self</span><span class="na">.0</span><span class="py">.x</span><span class="nf">.max</span><span class="p">(</span><span class="k">self</span><span class="na">.1</span><span class="py">.x</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">y_range</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">RangeInclusive</span><span class="o">&lt;</span><span class="n">Coord</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">self</span><span class="na">.0</span><span class="py">.y</span><span class="nf">.min</span><span class="p">(</span><span class="k">self</span><span class="na">.1</span><span class="py">.y</span><span class="p">)</span><span class="o">..=</span><span class="k">self</span><span class="na">.0</span><span class="py">.y</span><span class="nf">.max</span><span class="p">(</span><span class="k">self</span><span class="na">.1</span><span class="py">.y</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">top_z</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Coord</span> <span class="p">{</span>
        <span class="k">self</span><span class="na">.0</span><span class="py">.z</span><span class="nf">.max</span><span class="p">(</span><span class="k">self</span><span class="na">.1</span><span class="py">.z</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">bottom_z</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Coord</span> <span class="p">{</span>
        <span class="k">self</span><span class="na">.0</span><span class="py">.z</span><span class="nf">.min</span><span class="p">(</span><span class="k">self</span><span class="na">.1</span><span class="py">.z</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="nb">From</span><span class="o">&lt;&amp;</span><span class="n">PuzzleData</span><span class="o">&gt;</span> <span class="k">for</span> <span class="n">SandStack</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">from</span><span class="p">(</span><span class="nf">PuzzleData</span><span class="p">(</span><span class="n">bricks</span><span class="p">):</span> <span class="o">&amp;</span><span class="n">PuzzleData</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">belows</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[</span><span class="nn">Vec</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span> <span class="n">bricks</span><span class="nf">.len</span><span class="p">()];</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">k1</span><span class="p">,</span> <span class="n">b1</span><span class="p">)</span> <span class="k">in</span> <span class="n">bricks</span><span class="nf">.iter</span><span class="p">()</span><span class="nf">.enumerate</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">k2</span><span class="p">,</span> <span class="n">b2</span><span class="p">)</span> <span class="k">in</span> <span class="n">bricks</span><span class="nf">.iter</span><span class="p">()</span><span class="nf">.enumerate</span><span class="p">()</span><span class="nf">.skip</span><span class="p">(</span><span class="n">k1</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">match</span> <span class="n">b1</span><span class="nf">.compare</span><span class="p">(</span><span class="n">b2</span><span class="p">)</span> <span class="p">{</span>
                    <span class="nf">Some</span><span class="p">((</span><span class="nn">Ordering</span><span class="p">::</span><span class="n">Greater</span><span class="p">,</span> <span class="n">b</span><span class="p">))</span> <span class="k">=&gt;</span> <span class="n">belows</span><span class="p">[</span><span class="n">k1</span><span class="p">]</span><span class="nf">.push</span><span class="p">((</span><span class="n">k2</span><span class="p">,</span> <span class="n">b</span><span class="p">)),</span>
                    <span class="nf">Some</span><span class="p">((</span><span class="n">_</span><span class="p">,</span> <span class="n">b</span><span class="p">))</span> <span class="k">=&gt;</span> <span class="n">belows</span><span class="p">[</span><span class="n">k2</span><span class="p">]</span><span class="nf">.push</span><span class="p">((</span><span class="n">k1</span><span class="p">,</span> <span class="n">b</span><span class="p">)),</span>
                    <span class="nb">None</span> <span class="k">=&gt;</span> <span class="p">(),</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">let</span> <span class="n">bricks</span> <span class="o">=</span> <span class="n">bricks</span><span class="nf">.to_owned</span><span class="p">();</span>
        <span class="k">Self</span> <span class="p">{</span> <span class="n">bricks</span><span class="p">,</span> <span class="n">belows</span> <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">SandStack</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">settle_rec</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">settled</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">offsets</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="p">[</span><span class="nb">usize</span><span class="p">],</span> <span class="n">k</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="n">settled</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="p">||</span> <span class="k">self</span><span class="py">.bricks</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="nf">.bottom_z</span><span class="p">()</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">{</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">let</span> <span class="n">z</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="o">..</span><span class="k">self</span><span class="py">.belows</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="nf">.len</span><span class="p">())</span>
            <span class="nf">.map</span><span class="p">(|</span><span class="n">p</span><span class="p">|</span> <span class="p">{</span>
                <span class="k">let</span> <span class="p">(</span><span class="n">k2</span><span class="p">,</span> <span class="n">_</span><span class="p">)</span> <span class="o">=</span> <span class="k">self</span><span class="py">.belows</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">p</span><span class="p">];</span>
                <span class="k">self</span><span class="nf">.settle_rec</span><span class="p">(</span><span class="n">settled</span><span class="p">,</span> <span class="n">offsets</span><span class="p">,</span> <span class="n">k2</span><span class="p">);</span>
                <span class="k">let</span> <span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="k">ref</span> <span class="k">mut</span> <span class="n">z</span><span class="p">)</span> <span class="o">=</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="py">.belows</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">p</span><span class="p">];</span>
                <span class="o">*</span><span class="n">z</span> <span class="o">-=</span> <span class="n">offsets</span><span class="p">[</span><span class="n">k2</span><span class="p">];</span>
                <span class="o">*</span><span class="n">z</span>
            <span class="p">})</span>
            <span class="nf">.max</span><span class="p">()</span>
            <span class="nf">.unwrap_or</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

        <span class="k">let</span> <span class="n">me</span> <span class="o">=</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="py">.bricks</span><span class="p">[</span><span class="n">k</span><span class="p">];</span>
        <span class="nd">assert!</span><span class="p">(</span><span class="n">me</span><span class="nf">.bottom_z</span><span class="p">()</span> <span class="o">&gt;</span> <span class="n">z</span><span class="p">);</span>

        <span class="n">offsets</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">me</span><span class="nf">.bottom_z</span><span class="p">()</span> <span class="o">-</span> <span class="n">z</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
        <span class="n">me</span><span class="na">.0</span><span class="py">.z</span> <span class="o">-=</span> <span class="n">offsets</span><span class="p">[</span><span class="n">k</span><span class="p">];</span>
        <span class="n">me</span><span class="na">.1</span><span class="py">.z</span> <span class="o">-=</span> <span class="n">offsets</span><span class="p">[</span><span class="n">k</span><span class="p">];</span>

        <span class="n">settled</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="k">true</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">settle</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">settled</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[</span><span class="kc">false</span><span class="p">;</span> <span class="k">self</span><span class="py">.bricks</span><span class="nf">.len</span><span class="p">()];</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">offsets</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[</span><span class="mi">0</span><span class="p">;</span> <span class="k">self</span><span class="py">.bricks</span><span class="nf">.len</span><span class="p">()];</span>
        <span class="k">for</span> <span class="n">k</span> <span class="k">in</span> <span class="mi">0</span><span class="o">..</span><span class="k">self</span><span class="py">.bricks</span><span class="nf">.len</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">self</span><span class="nf">.settle_rec</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">settled</span><span class="p">,</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">offsets</span><span class="p">,</span> <span class="n">k</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">count_disintegrateable</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">unique_supporters</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[</span><span class="kc">false</span><span class="p">;</span> <span class="k">self</span><span class="py">.bricks</span><span class="nf">.len</span><span class="p">()];</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">me</span><span class="p">)</span> <span class="k">in</span> <span class="k">self</span><span class="py">.bricks</span><span class="nf">.iter</span><span class="p">()</span><span class="nf">.enumerate</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">supporters</span> <span class="o">=</span> <span class="k">self</span><span class="py">.belows</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
                <span class="nf">.iter</span><span class="p">()</span>
                <span class="nf">.filter</span><span class="p">(|(</span><span class="n">_</span><span class="p">,</span> <span class="n">z</span><span class="p">)|</span> <span class="n">z</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">==</span> <span class="n">me</span><span class="nf">.bottom_z</span><span class="p">())</span>
                <span class="nf">.map</span><span class="p">(|(</span><span class="n">p</span><span class="p">,</span> <span class="n">_</span><span class="p">)|</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
                <span class="nf">.take</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
                <span class="py">.collect</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="n">_</span><span class="o">&gt;&gt;</span><span class="p">();</span>
            <span class="k">if</span> <span class="n">supporters</span><span class="nf">.len</span><span class="p">()</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">{</span>
                <span class="n">unique_supporters</span><span class="p">[</span><span class="n">supporters</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="k">true</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">self</span><span class="py">.bricks</span><span class="nf">.len</span><span class="p">()</span> <span class="o">-</span> <span class="n">unique_supporters</span><span class="nf">.into_iter</span><span class="p">()</span><span class="nf">.filter</span><span class="p">(|</span><span class="o">&amp;</span><span class="n">s</span><span class="p">|</span> <span class="n">s</span><span class="p">)</span><span class="nf">.count</span><span class="p">()</span>
    <span class="p">}</span>

    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">sum_count_falling</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
        <span class="c1">// figure out what is supported above and what is supporting below</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">supported</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[</span><span class="nn">Vec</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span> <span class="k">self</span><span class="py">.bricks</span><span class="nf">.len</span><span class="p">()];</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">supporting</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[</span><span class="nn">Vec</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span> <span class="k">self</span><span class="py">.bricks</span><span class="nf">.len</span><span class="p">()];</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">k_above</span><span class="p">,</span> <span class="p">(</span><span class="n">z_above</span><span class="p">,</span> <span class="n">belows</span><span class="p">))</span> <span class="k">in</span> <span class="p">(</span><span class="k">self</span><span class="py">.bricks</span><span class="nf">.iter</span><span class="p">()</span><span class="nf">.map</span><span class="p">(</span><span class="nn">Brick</span><span class="p">::</span><span class="n">bottom_z</span><span class="p">))</span>
            <span class="nf">.zip</span><span class="p">(</span><span class="k">self</span><span class="py">.belows</span><span class="nf">.iter</span><span class="p">())</span>
            <span class="nf">.enumerate</span><span class="p">()</span>
        <span class="p">{</span>
            <span class="k">for</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">k_below</span><span class="p">,</span> <span class="n">_</span><span class="p">)</span> <span class="k">in</span> <span class="n">belows</span><span class="nf">.iter</span><span class="p">()</span><span class="nf">.filter</span><span class="p">(|(</span><span class="n">_</span><span class="p">,</span> <span class="n">z_below</span><span class="p">)|</span> <span class="n">z_below</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">==</span> <span class="n">z_above</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">supported</span><span class="p">[</span><span class="n">k_below</span><span class="p">]</span><span class="nf">.push</span><span class="p">(</span><span class="n">k_above</span><span class="p">);</span>
                <span class="n">supporting</span><span class="p">[</span><span class="n">k_above</span><span class="p">]</span><span class="nf">.push</span><span class="p">(</span><span class="n">k_below</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="c1">// use binary heap (max heap) and sort by max z (inverted) to make</span>
        <span class="c1">// sure we process bricks layer by layer</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">queue</span> <span class="o">=</span> <span class="nn">BinaryHeap</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">falling</span> <span class="o">=</span> <span class="nn">HashSet</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">sum_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">for</span> <span class="n">k_root</span> <span class="k">in</span> <span class="mi">0</span><span class="o">..</span><span class="k">self</span><span class="py">.bricks</span><span class="nf">.len</span><span class="p">()</span> <span class="p">{</span>
            <span class="n">falling</span><span class="nf">.insert</span><span class="p">(</span><span class="n">k_root</span><span class="p">);</span>
            <span class="n">queue</span><span class="nf">.push</span><span class="p">((</span><span class="o">!</span><span class="k">self</span><span class="py">.bricks</span><span class="p">[</span><span class="n">k_root</span><span class="p">]</span><span class="nf">.top_z</span><span class="p">(),</span> <span class="n">k_root</span><span class="p">));</span>
            <span class="k">while</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">((</span><span class="n">_</span><span class="p">,</span> <span class="n">k_below</span><span class="p">))</span> <span class="o">=</span> <span class="n">queue</span><span class="nf">.pop</span><span class="p">()</span> <span class="p">{</span>
                <span class="k">for</span> <span class="o">&amp;</span><span class="n">k_above</span> <span class="k">in</span> <span class="n">supported</span><span class="p">[</span><span class="n">k_below</span><span class="p">]</span><span class="nf">.iter</span><span class="p">()</span> <span class="p">{</span>
                    <span class="k">if</span> <span class="n">supporting</span><span class="p">[</span><span class="n">k_above</span><span class="p">]</span><span class="nf">.iter</span><span class="p">()</span><span class="nf">.all</span><span class="p">(|</span><span class="n">k</span><span class="p">|</span> <span class="n">falling</span><span class="nf">.contains</span><span class="p">(</span><span class="n">k</span><span class="p">))</span>
                        <span class="o">&amp;&amp;</span> <span class="n">falling</span><span class="nf">.insert</span><span class="p">(</span><span class="n">k_above</span><span class="p">)</span>
                    <span class="p">{</span>
                        <span class="n">queue</span><span class="nf">.push</span><span class="p">((</span><span class="o">!</span><span class="k">self</span><span class="py">.bricks</span><span class="p">[</span><span class="n">k_above</span><span class="p">]</span><span class="nf">.top_z</span><span class="p">(),</span> <span class="n">k_above</span><span class="p">));</span>
                    <span class="p">}</span>
                <span class="p">}</span>
            <span class="p">}</span>
            <span class="n">sum_count</span> <span class="o">+=</span> <span class="n">falling</span><span class="nf">.len</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// do not count self</span>
            <span class="n">falling</span><span class="nf">.clear</span><span class="p">();</span>
        <span class="p">}</span>

        <span class="n">sum_count</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">pub</span> <span class="k">fn</span> <span class="nf">star_1_and_2</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">PuzzleData</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="p">(</span><span class="nb">usize</span><span class="p">,</span> <span class="nb">usize</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">universe</span> <span class="o">=</span> <span class="nn">SandStack</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>
    <span class="n">universe</span><span class="nf">.settle</span><span class="p">();</span>
    <span class="p">(</span>
        <span class="n">universe</span><span class="nf">.count_disintegrateable</span><span class="p">(),</span>
        <span class="n">universe</span><span class="nf">.sum_count_falling</span><span class="p">(),</span>
    <span class="p">)</span>
        <span class="nf">.into</span><span class="p">()</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_tests_21">Tests</h3>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
</pre></td><td class="code"><pre><span class="nd">#[cfg(test)]</span>
<span class="k">mod</span> <span class="n">tests</span> <span class="p">{</span>
    <span class="k">use</span> <span class="k">super</span><span class="p">::</span><span class="o">*</span><span class="p">;</span>

    <span class="k">const</span> <span class="n">CONTENT</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span> <span class="o">=</span> <span class="s">r#"1,0,1~1,2,1
0,0,2~2,0,2
0,2,3~2,2,3
0,0,4~0,2,4
2,0,5~2,2,5
0,1,6~2,1,6
1,1,8~1,1,9
"#</span><span class="p">;</span>

    <span class="nd">#[test]</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">test_from</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">data</span> <span class="o">=</span> <span class="nn">PuzzleData</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="n">CONTENT</span><span class="p">);</span>

        <span class="k">let</span> <span class="n">exp</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[</span>
            <span class="nf">Brick</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span><span class="nf">.into</span><span class="p">(),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span><span class="nf">.into</span><span class="p">()),</span>
            <span class="nf">Brick</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span><span class="nf">.into</span><span class="p">(),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span><span class="nf">.into</span><span class="p">()),</span>
            <span class="nf">Brick</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span><span class="nf">.into</span><span class="p">(),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span><span class="nf">.into</span><span class="p">()),</span>
            <span class="nf">Brick</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span><span class="nf">.into</span><span class="p">(),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span><span class="nf">.into</span><span class="p">()),</span>
            <span class="nf">Brick</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span><span class="nf">.into</span><span class="p">(),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span><span class="nf">.into</span><span class="p">()),</span>
            <span class="nf">Brick</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span><span class="nf">.into</span><span class="p">(),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span><span class="nf">.into</span><span class="p">()),</span>
            <span class="nf">Brick</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span><span class="nf">.into</span><span class="p">(),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">9</span><span class="p">)</span><span class="nf">.into</span><span class="p">()),</span>
        <span class="p">];</span>

        <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">exp</span><span class="p">,</span> <span class="n">data</span><span class="na">.0</span><span class="p">);</span>

        <span class="nd">println!</span><span class="p">(</span><span class="s">"{data:?}"</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="nd">#[test]</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">test_star_1_and_2</span><span class="p">()</span> <span class="p">{</span>
        <span class="nd">assert_eq!</span><span class="p">((</span><span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">),</span> <span class="nf">star_1_and_2</span><span class="p">(</span><span class="o">&amp;</span><span class="n">CONTENT</span><span class="nf">.into</span><span class="p">())</span><span class="nf">.into</span><span class="p">());</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p><a href="#top">Top</a></p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="sol-rust-23">Rust | Day 23: A Long Walk</h2>
<div class="sectionbody">
<div class="paragraph">
<p><a href="https://rust-lang.org">Rust</a> solution to <a href="https://adventofcode.com/2023/day/23">AoC|2023|23</a>.</p>
</div>
<div class="sect2">
<h3 id="_input_18">Input</h3>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
</pre></td><td class="code"><pre><span class="k">pub</span> <span class="k">mod</span> <span class="n">input</span> <span class="p">{</span>
    <span class="nd">#[derive(Debug)]</span>
    <span class="k">pub</span> <span class="k">struct</span> <span class="n">PuzzleData</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="k">pub</span> <span class="n">data</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="p">[</span><span class="nb">u8</span><span class="p">],</span>
        <span class="k">pub</span> <span class="n">w</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
        <span class="k">pub</span> <span class="n">h</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
    <span class="p">}</span>

    <span class="k">impl</span><span class="o">&lt;</span><span class="nv">'a</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="nb">From</span><span class="o">&lt;&amp;</span><span class="nv">'a</span> <span class="n">T</span><span class="o">&gt;</span> <span class="k">for</span> <span class="n">PuzzleData</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span>
    <span class="k">where</span>
        <span class="n">T</span><span class="p">:</span> <span class="nb">AsRef</span><span class="o">&lt;</span><span class="p">[</span><span class="nb">u8</span><span class="p">]</span><span class="o">&gt;</span> <span class="o">+</span> <span class="nv">'a</span> <span class="o">+</span> <span class="o">?</span><span class="nb">Sized</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="k">fn</span> <span class="nf">from</span><span class="p">(</span><span class="n">s</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="n">T</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">data</span> <span class="o">=</span> <span class="n">s</span><span class="nf">.as_ref</span><span class="p">();</span>
            <span class="k">let</span> <span class="n">w</span> <span class="o">=</span> <span class="n">data</span><span class="nf">.iter</span><span class="p">()</span><span class="nf">.position</span><span class="p">(|</span><span class="o">&amp;</span><span class="n">b</span><span class="p">|</span> <span class="n">b</span> <span class="o">==</span> <span class="sc">b'\n'</span><span class="p">)</span><span class="nf">.unwrap_or</span><span class="p">(</span><span class="n">data</span><span class="nf">.len</span><span class="p">());</span>
            <span class="k">let</span> <span class="n">h</span> <span class="o">=</span> <span class="p">(</span><span class="n">data</span><span class="nf">.len</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">w</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
            <span class="k">Self</span> <span class="p">{</span> <span class="n">data</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">h</span> <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_star_1_22">Star 1</h3>
<div class="paragraph">
<p>Shortest path - easy. But how do I get the longest path? Well, just try all of them&#8230;&#8203;</p>
</div>
<div class="paragraph">
<p>The only interesting points in the grid are the start, the target and any coordinates, where there is actually a choice to make. So I build a grid that contains exactly those nodes with the unique distances to the neighbors as weights.</p>
</div>
<div class="paragraph">
<p>These are few enough for the problem to be solvable and to store the information which nodes have been seen in the bits of a <code>u64</code>.</p>
</div>
<div class="paragraph">
<p>The second part is the same as the first part. Just remove special treatment of slopes. This increases the number of edges in the graph and hence it runs a little longer.</p>
</div>
<div class="paragraph">
<p>Optimizations since initial version:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Modify graph: from the unique node from which the target is reachable, the only relevant adjacent is the target (idea from <a href="https://www.reddit.com/user/MattieShoes/">MattieShoes</a>): from ~330ms to ~170ms</p>
</li>
<li>
<p>Prune nodes from where the target is not reachable using a graph traversal based on bit manipulations with a <code>u64</code> as 'queue' (I especially like how adjacents are filtered and 'pushed to the queue' at once using bitwise operators): from ~170ms to ~150ms</p>
</li>
<li>
<p>Prune nodes from where I have been before with the same set of reachable nodes but a longer distance walked (idea from <a href="https://www.reddit.com/user/boombulerDev/">boombulerDev</a>): from ~150ms to ~40ms</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno">  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16
 17
 18
 19
 20
 21
 22
 23
 24
 25
 26
 27
 28
 29
 30
 31
 32
 33
 34
 35
 36
 37
 38
 39
 40
 41
 42
 43
 44
 45
 46
 47
 48
 49
 50
 51
 52
 53
 54
 55
 56
 57
 58
 59
 60
 61
 62
 63
 64
 65
 66
 67
 68
 69
 70
 71
 72
 73
 74
 75
 76
 77
 78
 79
 80
 81
 82
 83
 84
 85
 86
 87
 88
 89
 90
 91
 92
 93
 94
 95
 96
 97
 98
 99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
</pre></td><td class="code"><pre><span class="k">impl</span> <span class="n">PuzzleData</span><span class="o">&lt;</span><span class="nv">'_</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">const</span> <span class="n">D</span><span class="p">:</span> <span class="p">[(</span><span class="nb">isize</span><span class="p">,</span> <span class="nb">isize</span><span class="p">,</span> <span class="nb">u8</span><span class="p">);</span> <span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">b'&gt;'</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="sc">b'^'</span><span class="p">),</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="sc">b'&lt;'</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="sc">b'v'</span><span class="p">)];</span>

    <span class="k">fn</span> <span class="nf">is_branch_point</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="n">row</span><span class="p">):</span> <span class="p">(</span><span class="nb">usize</span><span class="p">,</span> <span class="nb">usize</span><span class="p">))</span> <span class="k">-&gt;</span> <span class="nb">bool</span> <span class="p">{</span>
        <span class="k">Self</span><span class="p">::</span><span class="n">D</span>
            <span class="nf">.iter</span><span class="p">()</span>
            <span class="nf">.map</span><span class="p">(|(</span><span class="n">dc</span><span class="p">,</span> <span class="n">dr</span><span class="p">,</span> <span class="n">_</span><span class="p">)|</span> <span class="p">(</span><span class="n">col</span><span class="nf">.wrapping_add_signed</span><span class="p">(</span><span class="o">*</span><span class="n">dc</span><span class="p">),</span> <span class="n">row</span><span class="nf">.wrapping_add_signed</span><span class="p">(</span><span class="o">*</span><span class="n">dr</span><span class="p">)))</span>
            <span class="nf">.filter</span><span class="p">(|</span><span class="o">&amp;</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="n">row</span><span class="p">)|</span> <span class="p">{</span>
                <span class="n">col</span> <span class="o">&lt;</span> <span class="k">self</span><span class="py">.w</span> <span class="o">&amp;&amp;</span> <span class="n">row</span> <span class="o">&lt;</span> <span class="k">self</span><span class="py">.h</span> <span class="o">&amp;&amp;</span> <span class="k">self</span><span class="py">.data</span><span class="p">[</span><span class="n">col</span> <span class="o">+</span> <span class="n">row</span> <span class="o">*</span> <span class="p">(</span><span class="k">self</span><span class="py">.w</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span> <span class="o">!=</span> <span class="sc">b'#'</span>
            <span class="p">})</span>
            <span class="nf">.count</span><span class="p">()</span>
            <span class="o">&gt;</span> <span class="mi">2</span>
    <span class="p">}</span>

    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">branch_points</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="p">(</span><span class="nb">usize</span><span class="p">,</span> <span class="nb">usize</span><span class="p">)</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="p">(</span><span class="mi">0</span><span class="o">..</span><span class="k">self</span><span class="py">.w</span> <span class="o">*</span> <span class="k">self</span><span class="py">.h</span><span class="p">)</span>
            <span class="nf">.map</span><span class="p">(|</span><span class="n">pos</span><span class="p">|</span> <span class="p">(</span><span class="n">pos</span> <span class="o">%</span> <span class="k">self</span><span class="py">.w</span><span class="p">,</span> <span class="n">pos</span> <span class="o">/</span> <span class="k">self</span><span class="py">.w</span><span class="p">))</span>
            <span class="nf">.filter</span><span class="p">(|</span><span class="o">&amp;</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="n">row</span><span class="p">)|</span> <span class="p">{</span>
                <span class="k">self</span><span class="py">.data</span><span class="p">[</span><span class="n">col</span> <span class="o">+</span> <span class="n">row</span> <span class="o">*</span> <span class="p">(</span><span class="k">self</span><span class="py">.w</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span> <span class="o">!=</span> <span class="sc">b'#'</span>
                    <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">row</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">||</span> <span class="n">row</span> <span class="o">==</span> <span class="k">self</span><span class="py">.h</span> <span class="o">-</span> <span class="mi">1</span> <span class="p">||</span> <span class="k">self</span><span class="nf">.is_branch_point</span><span class="p">((</span><span class="n">col</span><span class="p">,</span> <span class="n">row</span><span class="p">)))</span>
            <span class="p">})</span>
            <span class="py">.collect</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="n">_</span><span class="o">&gt;&gt;</span><span class="p">()</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="nf">adj_iter</span><span class="p">(</span>
        <span class="o">&amp;</span><span class="k">self</span><span class="p">,</span>
        <span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="n">row</span><span class="p">):</span> <span class="p">(</span><span class="nb">usize</span><span class="p">,</span> <span class="nb">usize</span><span class="p">),</span>
        <span class="n">ignore_slopes</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
    <span class="p">)</span> <span class="k">-&gt;</span> <span class="k">impl</span> <span class="nb">Iterator</span><span class="o">&lt;</span><span class="n">Item</span> <span class="o">=</span> <span class="p">(</span><span class="nb">usize</span><span class="p">,</span> <span class="nb">usize</span><span class="p">)</span><span class="o">&gt;</span> <span class="o">+</span> <span class="nv">'_</span> <span class="p">{</span>
        <span class="k">Self</span><span class="p">::</span><span class="n">D</span>
            <span class="nf">.iter</span><span class="p">()</span>
            <span class="nf">.map</span><span class="p">(</span><span class="k">move</span> <span class="p">|</span><span class="o">&amp;</span><span class="p">(</span><span class="n">dc</span><span class="p">,</span> <span class="n">dr</span><span class="p">,</span> <span class="n">ok</span><span class="p">)|</span> <span class="p">{</span>
                <span class="p">(</span><span class="n">col</span><span class="nf">.wrapping_add_signed</span><span class="p">(</span><span class="n">dc</span><span class="p">),</span> <span class="n">row</span><span class="nf">.wrapping_add_signed</span><span class="p">(</span><span class="n">dr</span><span class="p">),</span> <span class="n">ok</span><span class="p">)</span>
            <span class="p">})</span>
            <span class="nf">.filter</span><span class="p">(</span><span class="k">move</span> <span class="p">|</span><span class="o">&amp;</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="n">row</span><span class="p">,</span> <span class="n">ok</span><span class="p">)|</span> <span class="p">{</span>
                <span class="n">col</span> <span class="o">&lt;</span> <span class="k">self</span><span class="py">.w</span>
                    <span class="o">&amp;&amp;</span> <span class="n">row</span> <span class="o">&lt;</span> <span class="k">self</span><span class="py">.h</span>
                    <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">ignore_slopes</span> <span class="o">&amp;&amp;</span> <span class="k">self</span><span class="py">.data</span><span class="p">[</span><span class="n">col</span> <span class="o">+</span> <span class="n">row</span> <span class="o">*</span> <span class="p">(</span><span class="k">self</span><span class="py">.w</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span> <span class="o">!=</span> <span class="sc">b'#'</span>
                        <span class="p">||</span> <span class="p">[</span><span class="sc">b'.'</span><span class="p">,</span> <span class="n">ok</span><span class="p">]</span><span class="nf">.contains</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="py">.data</span><span class="p">[</span><span class="n">col</span> <span class="o">+</span> <span class="n">row</span> <span class="o">*</span> <span class="p">(</span><span class="k">self</span><span class="py">.w</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]))</span>
            <span class="p">})</span>
            <span class="nf">.map</span><span class="p">(|(</span><span class="n">col</span><span class="p">,</span> <span class="n">row</span><span class="p">,</span> <span class="n">_</span><span class="p">)|</span> <span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="n">row</span><span class="p">))</span>
    <span class="p">}</span>

    <span class="cd">/// nodes are branch points and start (first) / target (last)</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">make_graph</span><span class="p">(</span>
        <span class="o">&amp;</span><span class="k">self</span><span class="p">,</span>
        <span class="n">ignore_slopes</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span>
    <span class="p">)</span> <span class="k">-&gt;</span> <span class="p">(</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="p">(</span><span class="nb">usize</span><span class="p">,</span> <span class="nb">usize</span><span class="p">)</span><span class="o">&gt;</span><span class="p">,</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="p">(</span><span class="nb">usize</span><span class="p">,</span> <span class="nb">usize</span><span class="p">)</span><span class="o">&gt;&gt;</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">nodes</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.branch_points</span><span class="p">();</span>

        <span class="c1">// calculate length of (unique) paths between all nodes</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">adjacents</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[</span><span class="nn">Vec</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span> <span class="n">nodes</span><span class="nf">.len</span><span class="p">()];</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">k0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">start</span><span class="p">)</span> <span class="k">in</span> <span class="n">nodes</span><span class="nf">.iter</span><span class="p">()</span><span class="nf">.enumerate</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">let</span> <span class="k">mut</span> <span class="n">queue</span> <span class="o">=</span> <span class="nn">Vec</span><span class="p">::</span><span class="nf">from</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="nb">None</span><span class="p">)]);</span>
            <span class="k">while</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">((</span><span class="n">steps</span><span class="p">,</span> <span class="n">cur</span><span class="p">,</span> <span class="n">prev</span><span class="p">))</span> <span class="o">=</span> <span class="n">queue</span><span class="nf">.pop</span><span class="p">()</span> <span class="p">{</span>
                <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">k1</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="n">cur</span> <span class="o">!=</span> <span class="n">start</span><span class="p">)</span>
                    <span class="nf">.then_some</span><span class="p">(())</span>
                    <span class="nf">.and_then</span><span class="p">(|</span><span class="n">_</span><span class="p">|</span> <span class="n">nodes</span><span class="nf">.iter</span><span class="p">()</span><span class="nf">.position</span><span class="p">(|</span><span class="o">&amp;</span><span class="n">coord</span><span class="p">|</span> <span class="n">coord</span> <span class="o">==</span> <span class="n">cur</span><span class="p">))</span>
                <span class="p">{</span>
                    <span class="n">adjacents</span><span class="p">[</span><span class="n">k0</span><span class="p">]</span><span class="nf">.push</span><span class="p">((</span><span class="n">k1</span><span class="p">,</span> <span class="n">steps</span><span class="p">));</span>
                    <span class="k">continue</span><span class="p">;</span>
                <span class="p">}</span>

                <span class="n">queue</span><span class="nf">.extend</span><span class="p">(</span>
                    <span class="k">self</span><span class="nf">.adj_iter</span><span class="p">(</span><span class="n">cur</span><span class="p">,</span> <span class="n">ignore_slopes</span><span class="p">)</span>
                        <span class="nf">.filter</span><span class="p">(|</span><span class="o">&amp;</span><span class="n">adj</span><span class="p">|</span> <span class="nf">Some</span><span class="p">(</span><span class="n">adj</span><span class="p">)</span> <span class="o">!=</span> <span class="n">prev</span><span class="p">)</span>
                        <span class="nf">.map</span><span class="p">(|</span><span class="n">adj</span><span class="p">|</span> <span class="p">(</span><span class="n">steps</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">adj</span><span class="p">,</span> <span class="nf">Some</span><span class="p">(</span><span class="n">cur</span><span class="p">))),</span>
                <span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="p">(</span><span class="n">nodes</span><span class="p">,</span> <span class="n">adjacents</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">pub</span> <span class="k">fn</span> <span class="nf">reachable</span><span class="p">(</span><span class="n">adj_masks</span><span class="p">:</span> <span class="o">&amp;</span><span class="p">[</span><span class="nb">u64</span><span class="p">],</span> <span class="n">idx</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span> <span class="n">seen</span><span class="p">:</span> <span class="nb">u64</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">u64</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">queue</span> <span class="o">=</span> <span class="mi">1u64</span> <span class="o">&lt;&lt;</span> <span class="n">idx</span><span class="p">;</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">reached</span> <span class="o">=</span> <span class="n">seen</span> <span class="p">|</span> <span class="n">queue</span><span class="p">;</span>
    <span class="k">while</span> <span class="n">queue</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">cur</span> <span class="o">=</span> <span class="n">queue</span><span class="nf">.trailing_zeros</span><span class="p">();</span>
        <span class="n">queue</span> <span class="o">&amp;=</span> <span class="o">!</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">cur</span><span class="p">);</span>

        <span class="k">let</span> <span class="n">mask</span> <span class="o">=</span> <span class="n">adj_masks</span><span class="p">[</span><span class="n">cur</span> <span class="k">as</span> <span class="nb">usize</span><span class="p">];</span>
        <span class="n">queue</span> <span class="p">|</span><span class="o">=</span> <span class="n">mask</span> <span class="o">&amp;</span> <span class="o">!</span><span class="n">reached</span><span class="p">;</span>
        <span class="n">reached</span> <span class="p">|</span><span class="o">=</span> <span class="n">mask</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">reached</span> <span class="o">&amp;</span> <span class="o">!</span><span class="n">seen</span>
<span class="p">}</span>

<span class="k">pub</span> <span class="k">fn</span> <span class="nf">star</span><span class="p">(</span><span class="n">grid</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">PuzzleData</span><span class="p">,</span> <span class="n">ignore_slopes</span><span class="p">:</span> <span class="nb">bool</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
    <span class="k">let</span> <span class="p">(</span><span class="n">nodes</span><span class="p">,</span> <span class="k">mut</span> <span class="n">adjacents</span><span class="p">)</span> <span class="o">=</span> <span class="n">grid</span><span class="nf">.make_graph</span><span class="p">(</span><span class="n">ignore_slopes</span><span class="p">);</span>

    <span class="c1">// seen information is stored in bits of u64</span>
    <span class="nd">assert!</span><span class="p">(</span><span class="n">nodes</span><span class="nf">.len</span><span class="p">()</span> <span class="o">&lt;=</span> <span class="mi">64</span><span class="p">);</span>

    <span class="k">let</span> <span class="n">target</span> <span class="o">=</span> <span class="n">nodes</span><span class="nf">.len</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">if</span> <span class="n">ignore_slopes</span> <span class="p">{</span>
        <span class="c1">// Idea taken from https://www.reddit.com/user/MattieShoes/</span>
        <span class="c1">// At the last crossing before the target, we must go for the target</span>
        <span class="k">let</span> <span class="p">(</span><span class="n">last_before_target</span><span class="p">,</span> <span class="n">cost</span><span class="p">)</span> <span class="o">=</span> <span class="n">adjacents</span><span class="p">[</span><span class="n">target</span><span class="p">][</span><span class="mi">0</span><span class="p">];</span>
        <span class="n">adjacents</span><span class="p">[</span><span class="n">last_before_target</span><span class="p">]</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[(</span><span class="n">target</span><span class="p">,</span> <span class="n">cost</span><span class="p">)];</span>
    <span class="p">}</span>

    <span class="k">let</span> <span class="n">adj_masks</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">u64</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">adjacents</span>
        <span class="nf">.iter</span><span class="p">()</span>
        <span class="nf">.map</span><span class="p">(|</span><span class="n">adjacents</span><span class="p">|</span> <span class="n">adjacents</span><span class="nf">.iter</span><span class="p">()</span><span class="nf">.fold</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="p">|</span><span class="n">mask</span><span class="p">,</span> <span class="p">(</span><span class="n">adj</span><span class="p">,</span> <span class="n">_</span><span class="p">)|</span> <span class="n">mask</span> <span class="p">|</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">adj</span><span class="p">)))</span>
        <span class="nf">.collect</span><span class="p">();</span>

    <span class="k">let</span> <span class="k">mut</span> <span class="n">bests</span> <span class="o">=</span> <span class="nn">HashMap</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>

    <span class="c1">// find maximum</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">queue</span> <span class="o">=</span> <span class="nn">Vec</span><span class="p">::</span><span class="nf">from</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1u64</span><span class="p">)]);</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">max</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">while</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">((</span><span class="n">cost</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">seen</span><span class="p">))</span> <span class="o">=</span> <span class="n">queue</span><span class="nf">.pop</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">if</span> <span class="n">idx</span> <span class="o">==</span> <span class="n">target</span> <span class="o">&amp;&amp;</span> <span class="n">cost</span> <span class="o">&gt;</span> <span class="n">max</span> <span class="p">{</span>
            <span class="n">max</span> <span class="o">=</span> <span class="n">cost</span><span class="p">;</span>
            <span class="k">continue</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="c1">// Efficient BFS to get reachable nodes</span>
        <span class="k">let</span> <span class="n">reachable</span> <span class="o">=</span> <span class="nf">reachable</span><span class="p">(</span><span class="o">&amp;</span><span class="n">adj_masks</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">seen</span><span class="p">);</span>
        <span class="k">if</span> <span class="n">reachable</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">target</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
            <span class="c1">// Target is not reachable</span>
            <span class="k">continue</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="c1">// Idea taken from https://www.reddit.com/user/boombulerDev/</span>
        <span class="c1">// If I have been here with the same set of reachable nodes, only expand node</span>
        <span class="c1">// if it has a higher cost</span>
        <span class="k">match</span> <span class="n">bests</span><span class="nf">.entry</span><span class="p">((</span><span class="n">idx</span><span class="p">,</span> <span class="n">reachable</span><span class="p">))</span> <span class="p">{</span>
            <span class="nn">Entry</span><span class="p">::</span><span class="nf">Occupied</span><span class="p">(</span><span class="n">o</span><span class="p">)</span> <span class="k">if</span> <span class="n">cost</span> <span class="o">&lt;=</span> <span class="o">*</span><span class="n">o</span><span class="nf">.get</span><span class="p">()</span> <span class="k">=&gt;</span> <span class="k">continue</span><span class="p">,</span>
            <span class="nn">Entry</span><span class="p">::</span><span class="nf">Occupied</span><span class="p">(</span><span class="k">mut</span> <span class="n">o</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="o">*</span><span class="n">o</span><span class="nf">.get_mut</span><span class="p">()</span> <span class="o">=</span> <span class="n">cost</span><span class="p">,</span>
            <span class="nn">Entry</span><span class="p">::</span><span class="nf">Vacant</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="n">_</span> <span class="o">=</span> <span class="n">v</span><span class="nf">.insert</span><span class="p">(</span><span class="n">cost</span><span class="p">),</span>
        <span class="p">}</span>

        <span class="n">queue</span><span class="nf">.extend</span><span class="p">(</span>
            <span class="n">adjacents</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
                <span class="nf">.iter</span><span class="p">()</span>
                <span class="nf">.filter</span><span class="p">(|(</span><span class="n">adj</span><span class="p">,</span> <span class="n">_</span><span class="p">)|</span> <span class="n">seen</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">adj</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
                <span class="nf">.map</span><span class="p">(|</span><span class="o">&amp;</span><span class="p">(</span><span class="n">adj</span><span class="p">,</span> <span class="n">weight</span><span class="p">)|</span> <span class="p">(</span><span class="n">cost</span> <span class="o">+</span> <span class="n">weight</span><span class="p">,</span> <span class="n">adj</span><span class="p">,</span> <span class="n">seen</span> <span class="p">|</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">adj</span><span class="p">)),</span>
        <span class="p">);</span>
    <span class="p">}</span>
    <span class="n">max</span>
<span class="p">}</span>

<span class="k">pub</span> <span class="k">fn</span> <span class="nf">star_1</span><span class="p">(</span><span class="n">grid</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">PuzzleData</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
    <span class="nf">star</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="k">false</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">pub</span> <span class="k">fn</span> <span class="nf">star_2</span><span class="p">(</span><span class="n">grid</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">PuzzleData</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
    <span class="nf">star</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="k">true</span><span class="p">)</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_tests_22">Tests</h3>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
</pre></td><td class="code"><pre><span class="nd">#[cfg(test)]</span>
<span class="k">mod</span> <span class="n">tests</span> <span class="p">{</span>
    <span class="k">use</span> <span class="k">super</span><span class="p">::</span><span class="o">*</span><span class="p">;</span>

    <span class="k">const</span> <span class="n">CONTENT</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span> <span class="o">=</span> <span class="s">r#"#.#####################
#.......#########...###
#######.#########.#.###
###.....#.&gt;.&gt;.###.#.###
###v#####.#v#.###.#.###
###.&gt;...#.#.#.....#...#
###v###.#.#.#########.#
###...#.#.#.......#...#
#####.#.#.#######.#.###
#.....#.#.#.......#...#
#.#####.#.#.#########v#
#.#...#...#...###...&gt;.#
#.#.#v#######v###.###v#
#...#.&gt;.#...&gt;.&gt;.#.###.#
#####v#.#.###v#.#.###.#
#.....#...#...#.#.#...#
#.#########.###.#.#.###
#...###...#...#...#.###
###.###.#.###v#####v###
#...#...#.#.&gt;.&gt;.#.&gt;.###
#.###.###.#.###.#.#v###
#.....###...###...#...#
#####################.#
"#</span><span class="p">;</span>

    <span class="nd">#[test]</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">test_from</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">data</span> <span class="o">=</span> <span class="nn">PuzzleData</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="n">CONTENT</span><span class="p">);</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"{data:?}"</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="nd">#[test]</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">test_is_interesting</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">data</span> <span class="o">=</span> <span class="nn">PuzzleData</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="n">CONTENT</span><span class="p">);</span>
        <span class="nd">assert_eq!</span><span class="p">(</span><span class="kc">true</span><span class="p">,</span> <span class="n">data</span><span class="nf">.is_branch_point</span><span class="p">((</span><span class="mi">11</span><span class="p">,</span> <span class="mi">3</span><span class="p">)));</span>
        <span class="nd">assert_eq!</span><span class="p">(</span><span class="kc">false</span><span class="p">,</span> <span class="n">data</span><span class="nf">.is_branch_point</span><span class="p">((</span><span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">)));</span>
    <span class="p">}</span>

    <span class="nd">#[test]</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">test_star_1</span><span class="p">()</span> <span class="p">{</span>
        <span class="nd">assert_eq!</span><span class="p">(</span><span class="mi">94</span><span class="p">,</span> <span class="nf">star_1</span><span class="p">(</span><span class="o">&amp;</span><span class="n">CONTENT</span><span class="nf">.into</span><span class="p">()));</span>
    <span class="p">}</span>

    <span class="nd">#[test]</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">test_star_2</span><span class="p">()</span> <span class="p">{</span>
        <span class="nd">assert_eq!</span><span class="p">(</span><span class="mi">154</span><span class="p">,</span> <span class="nf">star_2</span><span class="p">(</span><span class="o">&amp;</span><span class="n">CONTENT</span><span class="nf">.into</span><span class="p">()));</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p><a href="#top">Top</a></p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="sol-rust-24">Rust | Day 24: Never Tell Me The Odds</h2>
<div class="sectionbody">
<div class="paragraph">
<p><a href="https://rust-lang.org">Rust</a> solution to <a href="https://adventofcode.com/2023/day/24">AoC|2023|24</a>.</p>
</div>
<div class="sect2">
<h3 id="_input_19">Input</h3>
<div class="paragraph">
<p>The hail-stones are represented as an array of pairs of position and velocity. Each array element represents one dimension.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
</pre></td><td class="code"><pre><span class="k">pub</span> <span class="k">type</span> <span class="n">Coord</span> <span class="o">=</span> <span class="nb">i64</span><span class="p">;</span>
<span class="k">pub</span> <span class="k">type</span> <span class="n">CoordE</span> <span class="o">=</span> <span class="nb">i128</span><span class="p">;</span>
<span class="nd">#[derive(Default,</span> <span class="nd">Debug,</span> <span class="nd">PartialEq,</span> <span class="nd">Eq,</span> <span class="nd">Clone,</span> <span class="nd">Copy)]</span>
<span class="k">pub</span> <span class="k">struct</span> <span class="n">PAndV</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="n">p</span><span class="p">:</span> <span class="n">T</span><span class="p">,</span>
    <span class="n">v</span><span class="p">:</span> <span class="n">T</span><span class="p">,</span>
<span class="p">}</span>
<span class="k">pub</span> <span class="k">type</span> <span class="n">Hail</span> <span class="o">=</span> <span class="p">[</span><span class="n">PAndV</span><span class="o">&lt;</span><span class="n">Coord</span><span class="o">&gt;</span><span class="p">;</span> <span class="mi">3</span><span class="p">];</span>

<span class="k">pub</span> <span class="k">mod</span> <span class="n">input</span> <span class="p">{</span>
    <span class="k">use</span> <span class="k">crate</span><span class="p">::</span><span class="n">Hail</span><span class="p">;</span>

    <span class="nd">#[derive(Debug)]</span>
    <span class="k">pub</span> <span class="k">struct</span> <span class="nf">PuzzleData</span><span class="p">(</span><span class="k">pub</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">Hail</span><span class="o">&gt;</span><span class="p">);</span>

    <span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="nb">From</span><span class="o">&lt;&amp;</span><span class="n">T</span><span class="o">&gt;</span> <span class="k">for</span> <span class="n">PuzzleData</span>
    <span class="k">where</span>
        <span class="n">T</span><span class="p">:</span> <span class="nb">AsRef</span><span class="o">&lt;</span><span class="nb">str</span><span class="o">&gt;</span> <span class="o">+</span> <span class="o">?</span><span class="nb">Sized</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="k">fn</span> <span class="nf">from</span><span class="p">(</span><span class="n">s</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">T</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
            <span class="k">Self</span><span class="p">(</span>
                <span class="n">s</span><span class="nf">.as_ref</span><span class="p">()</span>
                    <span class="nf">.lines</span><span class="p">()</span>
                    <span class="nf">.map</span><span class="p">(|</span><span class="n">line</span><span class="p">|</span> <span class="p">{</span>
                        <span class="n">line</span><span class="nf">.split</span><span class="p">(</span><span class="o">&amp;</span><span class="p">[</span><span class="sc">','</span><span class="p">,</span> <span class="sc">'@'</span><span class="p">])</span>
                            <span class="nf">.map</span><span class="p">(</span><span class="nn">str</span><span class="p">::</span><span class="n">trim</span><span class="p">)</span>
                            <span class="nf">.map</span><span class="p">(</span><span class="nn">str</span><span class="p">::</span><span class="n">parse</span><span class="p">)</span>
                            <span class="nf">.map</span><span class="p">(</span><span class="nn">Result</span><span class="p">::</span><span class="n">unwrap</span><span class="p">)</span>
                            <span class="nf">.enumerate</span><span class="p">()</span>
                            <span class="nf">.fold</span><span class="p">(</span><span class="nn">Hail</span><span class="p">::</span><span class="nf">default</span><span class="p">(),</span> <span class="p">|</span><span class="k">mut</span> <span class="n">h</span><span class="p">,</span> <span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">v</span><span class="p">)|</span> <span class="p">{</span>
                                <span class="o">*</span><span class="k">match</span> <span class="n">p</span> <span class="p">{</span>
                                    <span class="mi">0</span><span class="o">..=</span><span class="mi">2</span> <span class="k">=&gt;</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">h</span><span class="p">[</span><span class="n">p</span><span class="p">]</span><span class="py">.p</span><span class="p">,</span>
                                    <span class="mi">3</span><span class="o">..=</span><span class="mi">5</span> <span class="k">=&gt;</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">h</span><span class="p">[</span><span class="n">p</span> <span class="o">-</span> <span class="mi">3</span><span class="p">]</span><span class="py">.v</span><span class="p">,</span>
                                    <span class="n">_</span> <span class="k">=&gt;</span> <span class="nd">panic!</span><span class="p">(),</span>
                                <span class="p">}</span> <span class="o">=</span> <span class="n">v</span><span class="p">;</span>
                                <span class="n">h</span>
                            <span class="p">})</span>
                    <span class="p">})</span>
                    <span class="nf">.collect</span><span class="p">(),</span>
            <span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_star_1_23">Star 1</h3>
<div class="paragraph">
<p>Part 1 is quite straight-forward. I calculate intersection points as rational numbers with numerator and denominator to avoid dealing with floating point numbers.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
</pre></td><td class="code"><pre><span class="k">const</span> <span class="n">X</span><span class="p">:</span> <span class="nb">usize</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">const</span> <span class="n">Y</span><span class="p">:</span> <span class="nb">usize</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="k">const</span> <span class="n">Z</span><span class="p">:</span> <span class="nb">usize</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>

<span class="k">pub</span> <span class="k">fn</span> <span class="nf">intersect_2d</span><span class="p">(</span>
    <span class="n">h1</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Hail</span><span class="p">,</span>
    <span class="n">h2</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Hail</span><span class="p">,</span>
    <span class="n">x_range</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">RangeInclusive</span><span class="o">&lt;</span><span class="n">Coord</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="n">y_range</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">RangeInclusive</span><span class="o">&lt;</span><span class="n">Coord</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">bool</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">h1</span> <span class="o">=</span> <span class="n">h1</span><span class="nf">.map</span><span class="p">(|</span><span class="n">PAndV</span> <span class="p">{</span> <span class="n">p</span><span class="p">,</span> <span class="n">v</span> <span class="p">}|</span> <span class="n">PAndV</span> <span class="p">{</span>
        <span class="n">p</span><span class="p">:</span> <span class="n">p</span> <span class="k">as</span> <span class="n">CoordE</span><span class="p">,</span>
        <span class="n">v</span><span class="p">:</span> <span class="n">v</span> <span class="k">as</span> <span class="n">CoordE</span><span class="p">,</span>
    <span class="p">});</span>
    <span class="k">let</span> <span class="n">h2</span> <span class="o">=</span> <span class="n">h2</span><span class="nf">.map</span><span class="p">(|</span><span class="n">PAndV</span> <span class="p">{</span> <span class="n">p</span><span class="p">,</span> <span class="n">v</span> <span class="p">}|</span> <span class="n">PAndV</span> <span class="p">{</span>
        <span class="n">p</span><span class="p">:</span> <span class="n">p</span> <span class="k">as</span> <span class="n">CoordE</span><span class="p">,</span>
        <span class="n">v</span><span class="p">:</span> <span class="n">v</span> <span class="k">as</span> <span class="n">CoordE</span><span class="p">,</span>
    <span class="p">});</span>

    <span class="k">let</span> <span class="n">d</span> <span class="o">=</span> <span class="n">h2</span><span class="p">[</span><span class="n">X</span><span class="p">]</span><span class="py">.v</span> <span class="o">*</span> <span class="n">h1</span><span class="p">[</span><span class="n">Y</span><span class="p">]</span><span class="py">.v</span> <span class="o">-</span> <span class="n">h1</span><span class="p">[</span><span class="n">X</span><span class="p">]</span><span class="py">.v</span> <span class="o">*</span> <span class="n">h2</span><span class="p">[</span><span class="n">Y</span><span class="p">]</span><span class="py">.v</span><span class="p">;</span>
    <span class="k">if</span> <span class="n">d</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
        <span class="c1">// parallel</span>
        <span class="n">h1</span><span class="p">[</span><span class="n">X</span><span class="p">]</span><span class="py">.p</span> <span class="o">==</span> <span class="n">h2</span><span class="p">[</span><span class="n">X</span><span class="p">]</span><span class="py">.p</span> <span class="o">&amp;&amp;</span> <span class="n">h1</span><span class="p">[</span><span class="n">Y</span><span class="p">]</span><span class="py">.p</span> <span class="o">==</span> <span class="n">h2</span><span class="p">[</span><span class="n">Y</span><span class="p">]</span><span class="py">.p</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">n1</span> <span class="o">=</span> <span class="p">(</span><span class="n">h2</span><span class="p">[</span><span class="n">X</span><span class="p">]</span><span class="py">.v</span> <span class="o">*</span> <span class="p">(</span><span class="n">h2</span><span class="p">[</span><span class="n">Y</span><span class="p">]</span><span class="py">.p</span> <span class="o">-</span> <span class="n">h1</span><span class="p">[</span><span class="n">Y</span><span class="p">]</span><span class="py">.p</span><span class="p">)</span> <span class="o">-</span> <span class="n">h2</span><span class="p">[</span><span class="n">Y</span><span class="p">]</span><span class="py">.v</span> <span class="o">*</span> <span class="p">(</span><span class="n">h2</span><span class="p">[</span><span class="n">X</span><span class="p">]</span><span class="py">.p</span> <span class="o">-</span> <span class="n">h1</span><span class="p">[</span><span class="n">X</span><span class="p">]</span><span class="py">.p</span><span class="p">))</span> <span class="o">*</span> <span class="n">d</span><span class="nf">.signum</span><span class="p">();</span>
        <span class="k">let</span> <span class="n">n2</span> <span class="o">=</span> <span class="p">(</span><span class="n">h1</span><span class="p">[</span><span class="n">X</span><span class="p">]</span><span class="py">.v</span> <span class="o">*</span> <span class="p">(</span><span class="n">h2</span><span class="p">[</span><span class="n">Y</span><span class="p">]</span><span class="py">.p</span> <span class="o">-</span> <span class="n">h1</span><span class="p">[</span><span class="n">Y</span><span class="p">]</span><span class="py">.p</span><span class="p">)</span> <span class="o">-</span> <span class="n">h1</span><span class="p">[</span><span class="n">Y</span><span class="p">]</span><span class="py">.v</span> <span class="o">*</span> <span class="p">(</span><span class="n">h2</span><span class="p">[</span><span class="n">X</span><span class="p">]</span><span class="py">.p</span> <span class="o">-</span> <span class="n">h1</span><span class="p">[</span><span class="n">X</span><span class="p">]</span><span class="py">.p</span><span class="p">))</span> <span class="o">*</span> <span class="n">d</span><span class="nf">.signum</span><span class="p">();</span>
        <span class="k">let</span> <span class="n">d</span> <span class="o">=</span> <span class="n">d</span><span class="nf">.abs</span><span class="p">();</span>

        <span class="nd">debug_assert_eq!</span><span class="p">(</span><span class="n">h1</span><span class="p">[</span><span class="n">X</span><span class="p">]</span><span class="py">.p</span> <span class="o">*</span> <span class="n">d</span> <span class="o">+</span> <span class="n">h1</span><span class="p">[</span><span class="n">X</span><span class="p">]</span><span class="py">.v</span> <span class="o">*</span> <span class="n">n1</span><span class="p">,</span> <span class="n">h2</span><span class="p">[</span><span class="n">X</span><span class="p">]</span><span class="py">.p</span> <span class="o">*</span> <span class="n">d</span> <span class="o">+</span> <span class="n">h2</span><span class="p">[</span><span class="n">X</span><span class="p">]</span><span class="py">.v</span> <span class="o">*</span> <span class="n">n2</span><span class="p">);</span>
        <span class="nd">debug_assert_eq!</span><span class="p">(</span><span class="n">h1</span><span class="p">[</span><span class="n">Y</span><span class="p">]</span><span class="py">.p</span> <span class="o">*</span> <span class="n">d</span> <span class="o">+</span> <span class="n">h1</span><span class="p">[</span><span class="n">Y</span><span class="p">]</span><span class="py">.v</span> <span class="o">*</span> <span class="n">n1</span><span class="p">,</span> <span class="n">h2</span><span class="p">[</span><span class="n">Y</span><span class="p">]</span><span class="py">.p</span> <span class="o">*</span> <span class="n">d</span> <span class="o">+</span> <span class="n">h2</span><span class="p">[</span><span class="n">Y</span><span class="p">]</span><span class="py">.v</span> <span class="o">*</span> <span class="n">n2</span><span class="p">);</span>

        <span class="k">if</span> <span class="n">n1</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="p">||</span> <span class="n">n2</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="p">{</span>
            <span class="k">false</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="p">(</span><span class="o">*</span><span class="n">x_range</span><span class="nf">.start</span><span class="p">()</span> <span class="k">as</span> <span class="n">CoordE</span> <span class="o">*</span> <span class="n">d</span><span class="o">..=*</span><span class="n">x_range</span><span class="nf">.end</span><span class="p">()</span> <span class="k">as</span> <span class="n">CoordE</span> <span class="o">*</span> <span class="n">d</span><span class="p">)</span>
                <span class="nf">.contains</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">h1</span><span class="p">[</span><span class="n">X</span><span class="p">]</span><span class="py">.p</span> <span class="o">*</span> <span class="n">d</span> <span class="o">+</span> <span class="n">h1</span><span class="p">[</span><span class="n">X</span><span class="p">]</span><span class="py">.v</span> <span class="o">*</span> <span class="n">n1</span><span class="p">))</span>
                <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="o">*</span><span class="n">y_range</span><span class="nf">.start</span><span class="p">()</span> <span class="k">as</span> <span class="n">CoordE</span> <span class="o">*</span> <span class="n">d</span><span class="o">..=*</span><span class="n">y_range</span><span class="nf">.end</span><span class="p">()</span> <span class="k">as</span> <span class="n">CoordE</span> <span class="o">*</span> <span class="n">d</span><span class="p">)</span>
                    <span class="nf">.contains</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">h1</span><span class="p">[</span><span class="n">Y</span><span class="p">]</span><span class="py">.p</span> <span class="o">*</span> <span class="n">d</span> <span class="o">+</span> <span class="n">h1</span><span class="p">[</span><span class="n">Y</span><span class="p">]</span><span class="py">.v</span> <span class="o">*</span> <span class="n">n1</span><span class="p">))</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">pub</span> <span class="k">fn</span> <span class="nf">count_intersections_2d</span><span class="p">(</span>
    <span class="n">hails</span><span class="p">:</span> <span class="o">&amp;</span><span class="p">[</span><span class="n">Hail</span><span class="p">],</span>
    <span class="n">x_range</span><span class="p">:</span> <span class="n">RangeInclusive</span><span class="o">&lt;</span><span class="n">Coord</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="n">y_range</span><span class="p">:</span> <span class="n">RangeInclusive</span><span class="o">&lt;</span><span class="n">Coord</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
    <span class="n">hails</span>
        <span class="nf">.iter</span><span class="p">()</span>
        <span class="nf">.enumerate</span><span class="p">()</span>
        <span class="nf">.map</span><span class="p">(|(</span><span class="n">k</span><span class="p">,</span> <span class="n">h1</span><span class="p">)|</span> <span class="p">{</span>
            <span class="n">hails</span><span class="p">[</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="o">..</span><span class="p">]</span>
                <span class="nf">.iter</span><span class="p">()</span>
                <span class="nf">.filter</span><span class="p">(|</span><span class="o">&amp;</span><span class="n">h2</span><span class="p">|</span> <span class="nf">intersect_2d</span><span class="p">(</span><span class="n">h1</span><span class="p">,</span> <span class="n">h2</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">x_range</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">y_range</span><span class="p">))</span>
                <span class="nf">.count</span><span class="p">()</span>
        <span class="p">})</span>
        <span class="nf">.sum</span><span class="p">()</span>
<span class="p">}</span>

<span class="k">pub</span> <span class="k">fn</span> <span class="nf">star_1</span><span class="p">(</span><span class="nf">PuzzleData</span><span class="p">(</span><span class="n">hails</span><span class="p">):</span> <span class="o">&amp;</span><span class="n">PuzzleData</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
    <span class="k">const</span> <span class="n">RANGE</span><span class="p">:</span> <span class="n">RangeInclusive</span><span class="o">&lt;</span><span class="n">Coord</span><span class="o">&gt;</span> <span class="o">=</span> <span class="mi">200_000_000_000_000</span><span class="o">..=</span><span class="mi">400_000_000_000_000</span><span class="p">;</span>
    <span class="nf">count_intersections_2d</span><span class="p">(</span><span class="n">hails</span><span class="p">,</span> <span class="n">RANGE</span><span class="p">,</span> <span class="n">RANGE</span><span class="p">)</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_star_2_22">Star 2</h3>
<div class="paragraph">
<p>It took a long while until I figured that one out (and in the end, I needed a little hint from Reddit).</p>
</div>
<div class="paragraph">
<p>I still think, there is some beauty in the locus of potential solutions in a position-velocity plane for a single dimension. For a given rock velocity, we can even use the Chinese remainder theorem to find the rock position so that there will be a collision with every hail-stone. But all this did not lead anywhere&#8230;&#8203;</p>
</div>
<div class="paragraph">
<p>Yet, because it looks nice: in the picture below, 'X' marks the position (horizontal axis, left to right) and velocity (vertical axis, bottom to top) of a hail-stone and each '#' marks position and velocity of a rock that collides at some positive time.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code>#.........#..............................
..#........#.............................
....#.......#............................
......#......#...........................
..#.....#.....#..........................
#....#....#....#.........................
#...#...#...#...#........................
..#..#..#..#..#..#.......................
#.#.#.#.#.#.#.#.#.#......................
####################.....................
....................X....................
.....................####################
......................#.#.#.#.#.#.#.#.#.#
.......................#..#..#..#..#..#..
........................#...#...#...#...#
.........................#....#....#....#
..........................#.....#.....#..
...........................#......#......
............................#.......#....
.............................#........#..
..............................#.........#</code></pre>
</div>
</div>
<div class="paragraph">
<p>The key insight was: if there is a unique solution, six equations should be enough to find it and we don&#8217;t need to take care to look at integer solutions only. In theory, any hail-stone adds one unknown (the time of collision) and contributes three equations (one for every dimension), so three hail-stones should be enough to come up with the 6 equations.</p>
</div>
<div class="paragraph">
<p>Unfortunately, those equations are non-linear. But if we look at pairs of hail-stones, we can get rid of the non-linear terms. So four hail-stones or three pairs result in 6 linear equations, that I solve with Gaussian elimination. See the comments in the code for details.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno">  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16
 17
 18
 19
 20
 21
 22
 23
 24
 25
 26
 27
 28
 29
 30
 31
 32
 33
 34
 35
 36
 37
 38
 39
 40
 41
 42
 43
 44
 45
 46
 47
 48
 49
 50
 51
 52
 53
 54
 55
 56
 57
 58
 59
 60
 61
 62
 63
 64
 65
 66
 67
 68
 69
 70
 71
 72
 73
 74
 75
 76
 77
 78
 79
 80
 81
 82
 83
 84
 85
 86
 87
 88
 89
 90
 91
 92
 93
 94
 95
 96
 97
 98
 99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
</pre></td><td class="code"><pre><span class="k">pub</span> <span class="k">fn</span> <span class="n">solve</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">N</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span> <span class="k">const</span> <span class="n">M</span><span class="p">:</span> <span class="nb">usize</span><span class="o">&gt;</span><span class="p">(</span><span class="k">mut</span> <span class="n">mat</span><span class="p">:</span> <span class="p">[[</span><span class="nb">f64</span><span class="p">;</span> <span class="n">M</span><span class="p">];</span> <span class="n">N</span><span class="p">])</span> <span class="k">-&gt;</span> <span class="p">[</span><span class="nb">f64</span><span class="p">;</span> <span class="n">N</span><span class="p">]</span> <span class="p">{</span>
    <span class="nd">assert!</span><span class="p">(</span><span class="n">M</span> <span class="o">==</span> <span class="n">N</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="s">"M == N + 1 expected"</span><span class="p">);</span>

    <span class="k">let</span> <span class="k">mut</span> <span class="n">h</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="c1">// gaussian eliminate</span>
    <span class="k">while</span> <span class="n">h</span> <span class="o">&lt;</span> <span class="n">N</span> <span class="o">&amp;&amp;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">M</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">i_max</span> <span class="o">=</span> <span class="p">(</span><span class="n">h</span><span class="o">..</span><span class="n">N</span><span class="p">)</span>
            <span class="nf">.map</span><span class="p">(|</span><span class="n">i</span><span class="p">|</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">mat</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">k</span><span class="p">]</span><span class="nf">.abs</span><span class="p">()))</span>
            <span class="nf">.max_by</span><span class="p">(|(</span><span class="n">_</span><span class="p">,</span> <span class="n">v1</span><span class="p">),</span> <span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="n">v2</span><span class="p">)|</span> <span class="n">v1</span><span class="nf">.partial_cmp</span><span class="p">(</span><span class="n">v2</span><span class="p">)</span><span class="nf">.unwrap_or</span><span class="p">(</span><span class="nn">Ordering</span><span class="p">::</span><span class="n">Equal</span><span class="p">))</span>
            <span class="nf">.map</span><span class="p">(|(</span><span class="n">row</span><span class="p">,</span> <span class="n">_</span><span class="p">)|</span> <span class="n">row</span><span class="p">)</span>
            <span class="nf">.unwrap</span><span class="p">();</span>
        <span class="k">if</span> <span class="n">mat</span><span class="p">[</span><span class="n">i_max</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">==</span> <span class="mf">0.0</span> <span class="p">{</span>
            <span class="n">k</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="p">(</span><span class="n">mat</span><span class="p">[</span><span class="n">i_max</span><span class="p">],</span> <span class="n">mat</span><span class="p">[</span><span class="n">h</span><span class="p">])</span> <span class="o">=</span> <span class="p">(</span><span class="n">mat</span><span class="p">[</span><span class="n">h</span><span class="p">],</span> <span class="n">mat</span><span class="p">[</span><span class="n">i_max</span><span class="p">]);</span>
            <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="n">h</span> <span class="o">+</span> <span class="mi">1</span><span class="o">..</span><span class="n">N</span> <span class="p">{</span>
                <span class="k">let</span> <span class="n">f</span> <span class="o">=</span> <span class="n">mat</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">/</span> <span class="n">mat</span><span class="p">[</span><span class="n">h</span><span class="p">][</span><span class="n">k</span><span class="p">];</span>
                <span class="n">mat</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span>
                <span class="k">for</span> <span class="n">j</span> <span class="k">in</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="o">..</span><span class="n">M</span> <span class="p">{</span>
                    <span class="n">mat</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">-=</span> <span class="n">mat</span><span class="p">[</span><span class="n">h</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">*</span> <span class="n">f</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">}</span>
            <span class="n">h</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
            <span class="n">k</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">// calculate solution</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">r</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">;</span> <span class="n">N</span><span class="p">];</span>
    <span class="k">for</span> <span class="n">k</span> <span class="k">in</span> <span class="p">(</span><span class="mi">0</span><span class="o">..</span><span class="n">N</span><span class="p">)</span><span class="nf">.rev</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">r</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">mat</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">M</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="n">mat</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">k</span><span class="p">];</span>
        <span class="k">for</span> <span class="n">row</span> <span class="k">in</span> <span class="n">mat</span><span class="p">[</span><span class="mi">0</span><span class="o">..</span><span class="n">k</span><span class="p">]</span><span class="nf">.iter_mut</span><span class="p">()</span> <span class="p">{</span>
            <span class="n">row</span><span class="p">[</span><span class="n">M</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-=</span> <span class="n">row</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">*</span> <span class="n">r</span><span class="p">[</span><span class="n">k</span><span class="p">];</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">r</span>
<span class="p">}</span>

<span class="k">pub</span> <span class="k">fn</span> <span class="nf">star_2</span><span class="p">(</span><span class="nf">PuzzleData</span><span class="p">(</span><span class="n">hails</span><span class="p">):</span> <span class="o">&amp;</span><span class="n">PuzzleData</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Coord</span> <span class="p">{</span>
    <span class="c1">// number of dimensions</span>
    <span class="k">const</span> <span class="n">N</span><span class="p">:</span> <span class="nb">usize</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>

    <span class="c1">// Base equations</span>
    <span class="c1">//   x[i] + t[i] vx[i] = xr + t[i] vxr</span>
    <span class="c1">//   y[i] + t[i] vy[i] = yr + t[i] vyr</span>
    <span class="c1">//</span>
    <span class="c1">// Eliminate t[i]</span>
    <span class="c1">//   (x[i] - xr) / (vxr - vx[i]) = (y[i] - yr) / (vyr - vy[i])</span>
    <span class="c1">//   (x[i] - xr) (vyr - vy[i]) - (y[i] - yr) (vxr - vx[i]) = 0</span>
    <span class="c1">// This step creates additional solutions vxr = vx[i] and vyr = vy[i] with arbitrary</span>
    <span class="c1">// x[i], y[i] and xr = x[i] and yr = y[i] with arbitrary vx[i], vy[i].</span>
    <span class="c1">//</span>
    <span class="c1">// Expanding and re-arranging terms yields</span>
    <span class="c1">//   vyr xr - vxr yr = vy[i] xr - vx[i] yr - y[i] vxr + x[i] vyr + (vx[i] y[i] - vy[i] x[i])</span>
    <span class="c1">//   ----LHS_xy-----   ------------------------------RHS_xy[i]------------------------------</span>
    <span class="c1">// where all nonlinear terms are on the left (LHS_xy), independent of i.</span>
    <span class="c1">//</span>
    <span class="c1">// RHS_xy[i] - RHS_xy[j] = 0 finally yields a linear equation in the unknowns</span>
    <span class="c1">// xr, yr, vxr, vyr. Using four hailstones, we can construct 6 equations using</span>
    <span class="c1">// RHS_xy[i] and RHS_yz[i] for 6 unknowns.</span>
    <span class="c1">//</span>
    <span class="c1">// What about the additional solutions introduced above by potentially multiplying by 0?</span>
    <span class="c1">// - The problem has a unique solution</span>
    <span class="c1">// - Any solution satisfies the equations (we do not remove solutions by multiplying by 0)</span>
    <span class="c1">// =&gt; If the equations have a unique solution, it is the one we are looking for</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">mat</span> <span class="o">=</span> <span class="p">[[</span><span class="mf">0.0</span><span class="p">;</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">N</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">N</span><span class="p">];</span>
    <span class="k">for</span> <span class="n">k</span> <span class="k">in</span> <span class="mi">0</span><span class="o">..</span><span class="n">N</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">l</span> <span class="o">=</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
        <span class="n">mat</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span>
            <span class="p">(</span><span class="n">hails</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">Y</span><span class="p">]</span><span class="py">.v</span> <span class="o">-</span> <span class="n">hails</span><span class="p">[</span><span class="n">l</span><span class="p">][</span><span class="n">Y</span><span class="p">]</span><span class="py">.v</span><span class="p">)</span> <span class="k">as</span> <span class="n">_</span><span class="p">,</span>
            <span class="p">(</span><span class="n">hails</span><span class="p">[</span><span class="n">l</span><span class="p">][</span><span class="n">Y</span><span class="p">]</span><span class="py">.p</span> <span class="o">-</span> <span class="n">hails</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">Y</span><span class="p">]</span><span class="py">.p</span><span class="p">)</span> <span class="k">as</span> <span class="n">_</span><span class="p">,</span>
            <span class="p">(</span><span class="n">hails</span><span class="p">[</span><span class="n">l</span><span class="p">][</span><span class="n">X</span><span class="p">]</span><span class="py">.v</span> <span class="o">-</span> <span class="n">hails</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">X</span><span class="p">]</span><span class="py">.v</span><span class="p">)</span> <span class="k">as</span> <span class="n">_</span><span class="p">,</span>
            <span class="p">(</span><span class="n">hails</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">X</span><span class="p">]</span><span class="py">.p</span> <span class="o">-</span> <span class="n">hails</span><span class="p">[</span><span class="n">l</span><span class="p">][</span><span class="n">X</span><span class="p">]</span><span class="py">.p</span><span class="p">)</span> <span class="k">as</span> <span class="n">_</span><span class="p">,</span>
            <span class="mf">0.0</span><span class="p">,</span>
            <span class="mf">0.0</span><span class="p">,</span>
            <span class="p">((</span><span class="n">hails</span><span class="p">[</span><span class="n">l</span><span class="p">][</span><span class="n">X</span><span class="p">]</span><span class="py">.v</span> <span class="o">*</span> <span class="n">hails</span><span class="p">[</span><span class="n">l</span><span class="p">][</span><span class="n">Y</span><span class="p">]</span><span class="py">.p</span> <span class="o">-</span> <span class="n">hails</span><span class="p">[</span><span class="n">l</span><span class="p">][</span><span class="n">Y</span><span class="p">]</span><span class="py">.v</span> <span class="o">*</span> <span class="n">hails</span><span class="p">[</span><span class="n">l</span><span class="p">][</span><span class="n">X</span><span class="p">]</span><span class="py">.p</span><span class="p">)</span>
                <span class="o">-</span> <span class="p">(</span><span class="n">hails</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">X</span><span class="p">]</span><span class="py">.v</span> <span class="o">*</span> <span class="n">hails</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">Y</span><span class="p">]</span><span class="py">.p</span> <span class="o">-</span> <span class="n">hails</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">Y</span><span class="p">]</span><span class="py">.v</span> <span class="o">*</span> <span class="n">hails</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">X</span><span class="p">]</span><span class="py">.p</span><span class="p">))</span> <span class="k">as</span> <span class="n">_</span><span class="p">,</span>
        <span class="p">];</span>
        <span class="n">mat</span><span class="p">[</span><span class="n">N</span> <span class="o">+</span> <span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span>
            <span class="mf">0.0</span><span class="p">,</span>
            <span class="mf">0.0</span><span class="p">,</span>
            <span class="p">(</span><span class="n">hails</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">Z</span><span class="p">]</span><span class="py">.v</span> <span class="o">-</span> <span class="n">hails</span><span class="p">[</span><span class="n">l</span><span class="p">][</span><span class="n">Z</span><span class="p">]</span><span class="py">.v</span><span class="p">)</span> <span class="k">as</span> <span class="n">_</span><span class="p">,</span>
            <span class="p">(</span><span class="n">hails</span><span class="p">[</span><span class="n">l</span><span class="p">][</span><span class="n">Z</span><span class="p">]</span><span class="py">.p</span> <span class="o">-</span> <span class="n">hails</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">Z</span><span class="p">]</span><span class="py">.p</span><span class="p">)</span> <span class="k">as</span> <span class="n">_</span><span class="p">,</span>
            <span class="p">(</span><span class="n">hails</span><span class="p">[</span><span class="n">l</span><span class="p">][</span><span class="n">Y</span><span class="p">]</span><span class="py">.v</span> <span class="o">-</span> <span class="n">hails</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">Y</span><span class="p">]</span><span class="py">.v</span><span class="p">)</span> <span class="k">as</span> <span class="n">_</span><span class="p">,</span>
            <span class="p">(</span><span class="n">hails</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">Y</span><span class="p">]</span><span class="py">.p</span> <span class="o">-</span> <span class="n">hails</span><span class="p">[</span><span class="n">l</span><span class="p">][</span><span class="n">Y</span><span class="p">]</span><span class="py">.p</span><span class="p">)</span> <span class="k">as</span> <span class="n">_</span><span class="p">,</span>
            <span class="p">((</span><span class="n">hails</span><span class="p">[</span><span class="n">l</span><span class="p">][</span><span class="n">Y</span><span class="p">]</span><span class="py">.v</span> <span class="o">*</span> <span class="n">hails</span><span class="p">[</span><span class="n">l</span><span class="p">][</span><span class="n">Z</span><span class="p">]</span><span class="py">.p</span> <span class="o">-</span> <span class="n">hails</span><span class="p">[</span><span class="n">l</span><span class="p">][</span><span class="n">Z</span><span class="p">]</span><span class="py">.v</span> <span class="o">*</span> <span class="n">hails</span><span class="p">[</span><span class="n">l</span><span class="p">][</span><span class="n">Y</span><span class="p">]</span><span class="py">.p</span><span class="p">)</span>
                <span class="o">-</span> <span class="p">(</span><span class="n">hails</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">Y</span><span class="p">]</span><span class="py">.v</span> <span class="o">*</span> <span class="n">hails</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">Z</span><span class="p">]</span><span class="py">.p</span> <span class="o">-</span> <span class="n">hails</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">Z</span><span class="p">]</span><span class="py">.v</span> <span class="o">*</span> <span class="n">hails</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">Y</span><span class="p">]</span><span class="py">.p</span><span class="p">))</span> <span class="k">as</span> <span class="n">_</span><span class="p">,</span>
        <span class="p">];</span>
    <span class="p">}</span>

    <span class="c1">// solve the linear equations and transform to hail</span>
    <span class="k">let</span> <span class="n">sol</span> <span class="o">=</span> <span class="nf">solve</span><span class="p">(</span><span class="n">mat</span><span class="p">)</span><span class="nf">.map</span><span class="p">(|</span><span class="n">r</span><span class="p">|</span> <span class="n">r</span><span class="nf">.round</span><span class="p">()</span> <span class="k">as</span> <span class="n">Coord</span><span class="p">);</span>
    <span class="k">let</span> <span class="n">r</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">PAndV</span> <span class="p">{</span>
            <span class="n">p</span><span class="p">:</span> <span class="n">sol</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
            <span class="n">v</span><span class="p">:</span> <span class="n">sol</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
        <span class="p">},</span>
        <span class="n">PAndV</span> <span class="p">{</span>
            <span class="n">p</span><span class="p">:</span> <span class="n">sol</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span>
            <span class="n">v</span><span class="p">:</span> <span class="n">sol</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span>
        <span class="p">},</span>
        <span class="n">PAndV</span> <span class="p">{</span>
            <span class="n">p</span><span class="p">:</span> <span class="n">sol</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span>
            <span class="n">v</span><span class="p">:</span> <span class="n">sol</span><span class="p">[</span><span class="mi">5</span><span class="p">],</span>
        <span class="p">},</span>
    <span class="p">];</span>

    <span class="c1">// check solution on all points</span>
    <span class="nd">debug_assert_eq!</span><span class="p">(</span>
        <span class="nb">None</span><span class="p">,</span>
        <span class="n">hails</span>
            <span class="nf">.iter</span><span class="p">()</span>
            <span class="nf">.map</span><span class="p">(|</span><span class="o">&amp;</span><span class="n">h</span><span class="p">|</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span><span class="nf">.map</span><span class="p">(|</span><span class="n">k</span><span class="p">|</span> <span class="p">(</span><span class="n">h</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="py">.p</span> <span class="o">-</span> <span class="n">r</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="py">.p</span><span class="p">,</span> <span class="n">r</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="py">.v</span> <span class="o">-</span> <span class="n">h</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="py">.v</span><span class="p">)))</span>
            <span class="nf">.position</span><span class="p">(|</span><span class="n">deltas</span><span class="p">|</span> <span class="p">{</span>
                <span class="c1">// check t is the same for all coordinates with non-zero velocity delta</span>
                <span class="k">let</span> <span class="p">(</span><span class="n">chk_1</span><span class="p">,</span> <span class="n">_</span><span class="p">)</span> <span class="o">=</span> <span class="n">deltas</span>
                    <span class="nf">.into_iter</span><span class="p">()</span>
                    <span class="nf">.filter</span><span class="p">(|(</span><span class="n">_</span><span class="p">,</span> <span class="n">v</span><span class="p">)|</span> <span class="o">*</span><span class="n">v</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
                    <span class="nf">.map</span><span class="p">(|(</span><span class="n">p</span><span class="p">,</span> <span class="n">v</span><span class="p">)|</span> <span class="n">p</span> <span class="o">/</span> <span class="n">v</span><span class="p">)</span>
                    <span class="nf">.fold</span><span class="p">((</span><span class="kc">true</span><span class="p">,</span> <span class="nb">None</span><span class="p">),</span> <span class="p">|(</span><span class="n">ok</span><span class="p">,</span> <span class="n">cur_t</span><span class="p">),</span> <span class="n">t</span><span class="p">|</span> <span class="k">match</span> <span class="p">(</span><span class="n">ok</span><span class="p">,</span> <span class="n">cur_t</span><span class="p">)</span> <span class="p">{</span>
                        <span class="p">(</span><span class="kc">false</span><span class="p">,</span> <span class="n">_</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">(</span><span class="kc">false</span><span class="p">,</span> <span class="nb">None</span><span class="p">),</span>
                        <span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="nb">None</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">(</span><span class="n">t</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="n">t</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span><span class="nf">.then_some</span><span class="p">(</span><span class="n">t</span><span class="p">)),</span>
                        <span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="nf">Some</span><span class="p">(</span><span class="n">cur_t</span><span class="p">))</span> <span class="k">=&gt;</span> <span class="p">(</span><span class="n">cur_t</span> <span class="o">==</span> <span class="n">t</span><span class="p">,</span> <span class="p">(</span><span class="n">cur_t</span> <span class="o">==</span> <span class="n">t</span><span class="p">)</span><span class="nf">.then_some</span><span class="p">(</span><span class="n">cur_t</span><span class="p">)),</span>
                    <span class="p">});</span>
                <span class="c1">// ... and coordinate deltas are multiples of velocity deltas</span>
                <span class="k">let</span> <span class="n">chk_2</span> <span class="o">=</span> <span class="n">deltas</span>
                    <span class="nf">.into_iter</span><span class="p">()</span>
                    <span class="nf">.all</span><span class="p">(|(</span><span class="n">p</span><span class="p">,</span> <span class="n">v</span><span class="p">)|</span> <span class="n">v</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">p</span> <span class="o">%</span> <span class="n">v</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">||</span> <span class="n">v</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">p</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
                <span class="o">!</span><span class="p">(</span><span class="n">chk_1</span> <span class="o">&amp;&amp;</span> <span class="n">chk_2</span><span class="p">)</span>
            <span class="p">})</span>
            <span class="nf">.map</span><span class="p">(|</span><span class="n">idx</span><span class="p">|</span> <span class="n">hails</span><span class="p">[</span><span class="n">idx</span><span class="p">]),</span>
        <span class="s">"Inconsistent solution"</span>
    <span class="p">);</span>

    <span class="n">r</span><span class="nf">.into_iter</span><span class="p">()</span><span class="nf">.map</span><span class="p">(|</span><span class="n">c</span><span class="p">|</span> <span class="n">c</span><span class="py">.p</span><span class="p">)</span><span class="nf">.sum</span><span class="p">()</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_tests_23">Tests</h3>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
</pre></td><td class="code"><pre><span class="nd">#[cfg(test)]</span>
<span class="k">mod</span> <span class="n">tests</span> <span class="p">{</span>
    <span class="k">use</span> <span class="k">super</span><span class="p">::</span><span class="o">*</span><span class="p">;</span>

    <span class="k">const</span> <span class="n">CONTENT</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span> <span class="o">=</span> <span class="s">r#"19, 13, 30 @ -2,  1, -2
18, 19, 22 @ -1, -1, -2
20, 25, 34 @ -2, -2, -4
12, 31, 28 @ -1, -2, -1
20, 19, 15 @  1, -5, -3
"#</span><span class="p">;</span>

    <span class="nd">#[test]</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">test_from</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">let</span> <span class="nf">PuzzleData</span><span class="p">(</span><span class="n">hails</span><span class="p">)</span> <span class="o">=</span> <span class="nn">PuzzleData</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="n">CONTENT</span><span class="p">);</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"{hails:?}"</span><span class="p">);</span>
        <span class="nd">assert_eq!</span><span class="p">(</span>
            <span class="nd">vec!</span><span class="p">[</span>
                <span class="p">[</span>
                    <span class="n">PAndV</span> <span class="p">{</span> <span class="n">p</span><span class="p">:</span> <span class="mi">19</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="o">-</span><span class="mi">2</span> <span class="p">},</span>
                    <span class="n">PAndV</span> <span class="p">{</span> <span class="n">p</span><span class="p">:</span> <span class="mi">13</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="mi">1</span> <span class="p">},</span>
                    <span class="n">PAndV</span> <span class="p">{</span> <span class="n">p</span><span class="p">:</span> <span class="mi">30</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="o">-</span><span class="mi">2</span> <span class="p">}</span>
                <span class="p">],</span>
                <span class="p">[</span>
                    <span class="n">PAndV</span> <span class="p">{</span> <span class="n">p</span><span class="p">:</span> <span class="mi">18</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="o">-</span><span class="mi">1</span> <span class="p">},</span>
                    <span class="n">PAndV</span> <span class="p">{</span> <span class="n">p</span><span class="p">:</span> <span class="mi">19</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="o">-</span><span class="mi">1</span> <span class="p">},</span>
                    <span class="n">PAndV</span> <span class="p">{</span> <span class="n">p</span><span class="p">:</span> <span class="mi">22</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="o">-</span><span class="mi">2</span> <span class="p">}</span>
                <span class="p">],</span>
                <span class="p">[</span>
                    <span class="n">PAndV</span> <span class="p">{</span> <span class="n">p</span><span class="p">:</span> <span class="mi">20</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="o">-</span><span class="mi">2</span> <span class="p">},</span>
                    <span class="n">PAndV</span> <span class="p">{</span> <span class="n">p</span><span class="p">:</span> <span class="mi">25</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="o">-</span><span class="mi">2</span> <span class="p">},</span>
                    <span class="n">PAndV</span> <span class="p">{</span> <span class="n">p</span><span class="p">:</span> <span class="mi">34</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="o">-</span><span class="mi">4</span> <span class="p">}</span>
                <span class="p">],</span>
                <span class="p">[</span>
                    <span class="n">PAndV</span> <span class="p">{</span> <span class="n">p</span><span class="p">:</span> <span class="mi">12</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="o">-</span><span class="mi">1</span> <span class="p">},</span>
                    <span class="n">PAndV</span> <span class="p">{</span> <span class="n">p</span><span class="p">:</span> <span class="mi">31</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="o">-</span><span class="mi">2</span> <span class="p">},</span>
                    <span class="n">PAndV</span> <span class="p">{</span> <span class="n">p</span><span class="p">:</span> <span class="mi">28</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="o">-</span><span class="mi">1</span> <span class="p">}</span>
                <span class="p">],</span>
                <span class="p">[</span>
                    <span class="n">PAndV</span> <span class="p">{</span> <span class="n">p</span><span class="p">:</span> <span class="mi">20</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="mi">1</span> <span class="p">},</span>
                    <span class="n">PAndV</span> <span class="p">{</span> <span class="n">p</span><span class="p">:</span> <span class="mi">19</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="o">-</span><span class="mi">5</span> <span class="p">},</span>
                    <span class="n">PAndV</span> <span class="p">{</span> <span class="n">p</span><span class="p">:</span> <span class="mi">15</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="o">-</span><span class="mi">3</span> <span class="p">}</span>
                <span class="p">]</span>
            <span class="p">],</span>
            <span class="n">hails</span>
        <span class="p">);</span>
    <span class="p">}</span>

    <span class="nd">#[test]</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">test_star_1</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">const</span> <span class="n">RANGE</span><span class="p">:</span> <span class="n">RangeInclusive</span><span class="o">&lt;</span><span class="n">Coord</span><span class="o">&gt;</span> <span class="o">=</span> <span class="mi">7</span><span class="o">..=</span><span class="mi">27</span><span class="p">;</span>
        <span class="k">let</span> <span class="nf">PuzzleData</span><span class="p">(</span><span class="n">hails</span><span class="p">)</span> <span class="o">=</span> <span class="n">CONTENT</span><span class="nf">.into</span><span class="p">();</span>
        <span class="nd">assert_eq!</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="nf">count_intersections_2d</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hails</span><span class="p">,</span> <span class="n">RANGE</span><span class="p">,</span> <span class="n">RANGE</span><span class="p">));</span>
    <span class="p">}</span>

    <span class="nd">#[test]</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">test_star_2</span><span class="p">()</span> <span class="p">{</span>
        <span class="nd">assert_eq!</span><span class="p">(</span><span class="mi">47</span><span class="p">,</span> <span class="nf">star_2</span><span class="p">(</span><span class="o">&amp;</span><span class="n">CONTENT</span><span class="nf">.into</span><span class="p">()));</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p><a href="#top">Top</a></p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="sol-rust-25">Rust | Day 25: Snowverload</h2>
<div class="sectionbody">
<div class="paragraph">
<p><a href="https://rust-lang.org">Rust</a> solution to <a href="https://adventofcode.com/2023/day/25">AoC|2023|25</a>.</p>
</div>
<div class="sect2">
<h3 id="_input_20">Input</h3>
<div class="paragraph">
<p>Process the input into a <code>Vec</code> of <code>Vec</code> of adjacents (identified by index).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
</pre></td><td class="code"><pre><span class="k">mod</span> <span class="n">input</span> <span class="p">{</span>
    <span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">collections</span><span class="p">::</span><span class="n">HashMap</span><span class="p">;</span>

    <span class="k">pub</span> <span class="k">struct</span> <span class="nf">PuzzleData</span><span class="p">(</span><span class="k">pub</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;&gt;</span><span class="p">);</span>

    <span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="p">:</span> <span class="nb">AsRef</span><span class="o">&lt;</span><span class="nb">str</span><span class="o">&gt;</span> <span class="o">+</span> <span class="o">?</span><span class="nb">Sized</span><span class="o">&gt;</span> <span class="nb">From</span><span class="o">&lt;&amp;</span><span class="n">T</span><span class="o">&gt;</span> <span class="k">for</span> <span class="n">PuzzleData</span> <span class="p">{</span>
        <span class="k">fn</span> <span class="nf">from</span><span class="p">(</span><span class="n">value</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">T</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
            <span class="k">let</span> <span class="k">mut</span> <span class="n">adjacents</span> <span class="o">=</span> <span class="nn">Vec</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;&gt;</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
            <span class="k">let</span> <span class="k">mut</span> <span class="n">indices</span> <span class="o">=</span> <span class="nn">HashMap</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
            <span class="k">for</span> <span class="n">line</span> <span class="k">in</span> <span class="n">value</span><span class="nf">.as_ref</span><span class="p">()</span><span class="nf">.lines</span><span class="p">()</span> <span class="p">{</span>
                <span class="k">let</span> <span class="k">mut</span> <span class="n">parts</span> <span class="o">=</span> <span class="n">line</span>
                    <span class="py">.split</span><span class="p">::</span><span class="o">&lt;&amp;</span><span class="p">[</span><span class="nb">char</span><span class="p">]</span><span class="o">&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="p">[</span><span class="sc">' '</span><span class="p">,</span> <span class="sc">':'</span><span class="p">])</span>
                    <span class="nf">.map</span><span class="p">(</span><span class="nn">str</span><span class="p">::</span><span class="n">trim</span><span class="p">)</span>
                    <span class="nf">.filter</span><span class="p">(|</span><span class="n">v</span><span class="p">|</span> <span class="n">v</span><span class="nf">.len</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
                    <span class="nf">.map</span><span class="p">(|</span><span class="n">key</span><span class="p">|</span> <span class="p">{</span>
                        <span class="k">let</span> <span class="n">idx</span> <span class="o">=</span> <span class="n">indices</span><span class="nf">.len</span><span class="p">();</span>
                        <span class="o">*</span><span class="n">indices</span><span class="nf">.entry</span><span class="p">(</span><span class="n">key</span><span class="p">)</span><span class="nf">.or_insert</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
                    <span class="p">});</span>
                <span class="k">let</span> <span class="n">key</span> <span class="o">=</span> <span class="n">parts</span><span class="nf">.next</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">();</span>
                <span class="k">for</span> <span class="n">value</span> <span class="k">in</span> <span class="n">parts</span> <span class="p">{</span>
                    <span class="n">adjacents</span><span class="nf">.resize</span><span class="p">(</span><span class="n">adjacents</span><span class="nf">.len</span><span class="p">()</span><span class="nf">.max</span><span class="p">(</span><span class="n">key</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span><span class="nf">.max</span><span class="p">(</span><span class="n">value</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="nn">Vec</span><span class="p">::</span><span class="nf">new</span><span class="p">());</span>
                    <span class="n">adjacents</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="nf">.push</span><span class="p">(</span><span class="n">value</span><span class="p">);</span>
                    <span class="n">adjacents</span><span class="p">[</span><span class="n">value</span><span class="p">]</span><span class="nf">.push</span><span class="p">(</span><span class="n">key</span><span class="p">);</span>
                <span class="p">}</span>
            <span class="p">}</span>

            <span class="k">Self</span><span class="p">(</span><span class="n">adjacents</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_star_1_24">Star 1</h3>
<div class="paragraph">
<p>My first attempt was to implement the <a href="https://en.wikipedia.org/wiki/Stoer%E2%80%93Wagner_algorithm">Stoer-Wagner algorithm</a> to find a minimum cut of the graph. It worked but only spew out a solution after 10 minutes! But the solution was quite generic. It did not need any knowledge on how many edges need to be removed, it just found the smallest number of edges so that their removal splits the graph in two parts.</p>
</div>
<div class="paragraph">
<p>My new solution uses the knowledge about the minimum number of edges to be removed.</p>
</div>
<div class="paragraph">
<p>We start by choosing an arbitrary start node (node at index <code>0</code>).</p>
</div>
<div class="paragraph">
<p>Then we search a target node for which we can find exactly three disjoint paths from the start node. This target node and the start node will end up in distinct parts of the graph once split in two.</p>
</div>
<div class="paragraph">
<p>Each of the three disjoint paths between start and target will contain exactly one of the links whose removal will disconnect the graph. So we iterate over all combinations and find the one whose removal which makes the target unreachable from the start.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno">  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16
 17
 18
 19
 20
 21
 22
 23
 24
 25
 26
 27
 28
 29
 30
 31
 32
 33
 34
 35
 36
 37
 38
 39
 40
 41
 42
 43
 44
 45
 46
 47
 48
 49
 50
 51
 52
 53
 54
 55
 56
 57
 58
 59
 60
 61
 62
 63
 64
 65
 66
 67
 68
 69
 70
 71
 72
 73
 74
 75
 76
 77
 78
 79
 80
 81
 82
 83
 84
 85
 86
 87
 88
 89
 90
 91
 92
 93
 94
 95
 96
 97
 98
 99
100
101
102
</pre></td><td class="code"><pre><span class="k">pub</span> <span class="k">fn</span> <span class="nf">get_shortest_path</span><span class="p">(</span>
    <span class="n">adjacents</span><span class="p">:</span> <span class="o">&amp;</span><span class="p">[</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span><span class="p">],</span>
    <span class="n">forbidden</span><span class="p">:</span> <span class="o">&amp;</span><span class="p">[</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="p">(</span><span class="nb">usize</span><span class="p">,</span> <span class="nb">usize</span><span class="p">)</span><span class="o">&gt;</span><span class="p">],</span>
    <span class="n">start</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
    <span class="n">target</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
<span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">HashMap</span><span class="o">&lt;</span><span class="nb">usize</span><span class="p">,</span> <span class="nb">usize</span><span class="o">&gt;&gt;</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">seen</span> <span class="o">=</span> <span class="nn">HashSet</span><span class="p">::</span><span class="nf">from</span><span class="p">([</span><span class="n">start</span><span class="p">]);</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">queue</span> <span class="o">=</span> <span class="nn">VecDeque</span><span class="p">::</span><span class="nf">from</span><span class="p">([</span><span class="n">start</span><span class="p">]);</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">parents</span> <span class="o">=</span> <span class="nn">HashMap</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
    <span class="k">while</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span> <span class="o">=</span> <span class="n">queue</span><span class="nf">.pop_front</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">if</span> <span class="n">idx</span> <span class="o">==</span> <span class="n">target</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nf">Some</span><span class="p">(</span><span class="n">parents</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="k">for</span> <span class="o">&amp;</span><span class="n">adj</span> <span class="k">in</span> <span class="n">adjacents</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="nf">.iter</span><span class="p">()</span><span class="nf">.filter</span><span class="p">(|</span><span class="o">&amp;&amp;</span><span class="n">adj</span><span class="p">|</span> <span class="p">{</span>
            <span class="o">!</span><span class="n">forbidden</span>
                <span class="nf">.iter</span><span class="p">()</span>
                <span class="nf">.any</span><span class="p">(|</span><span class="n">forbidden</span><span class="p">|</span> <span class="n">forbidden</span><span class="nf">.contains</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">adj</span><span class="nf">.min</span><span class="p">(</span><span class="n">idx</span><span class="p">),</span> <span class="n">adj</span><span class="nf">.max</span><span class="p">(</span><span class="n">idx</span><span class="p">))))</span>
        <span class="p">})</span> <span class="p">{</span>
            <span class="k">if</span> <span class="n">seen</span><span class="nf">.insert</span><span class="p">(</span><span class="n">adj</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">queue</span><span class="nf">.push_back</span><span class="p">(</span><span class="n">adj</span><span class="p">);</span>
                <span class="n">parents</span><span class="nf">.insert</span><span class="p">(</span><span class="n">adj</span><span class="p">,</span> <span class="n">idx</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="nb">None</span>
<span class="p">}</span>

<span class="k">pub</span> <span class="k">fn</span> <span class="nf">get_target_with_three_paths</span><span class="p">(</span>
    <span class="n">adjacents</span><span class="p">:</span> <span class="o">&amp;</span><span class="p">[</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span><span class="p">],</span>
    <span class="n">start</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
<span class="p">)</span> <span class="k">-&gt;</span> <span class="p">(</span><span class="nb">usize</span><span class="p">,</span> <span class="p">[</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="p">(</span><span class="nb">usize</span><span class="p">,</span> <span class="nb">usize</span><span class="p">)</span><span class="o">&gt;</span><span class="p">;</span> <span class="mi">3</span><span class="p">])</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">paths</span> <span class="o">=</span> <span class="p">[</span><span class="nn">Vec</span><span class="p">::</span><span class="nf">new</span><span class="p">(),</span> <span class="nn">Vec</span><span class="p">::</span><span class="nf">new</span><span class="p">(),</span> <span class="nn">Vec</span><span class="p">::</span><span class="nf">new</span><span class="p">()];</span>
    <span class="k">for</span> <span class="n">target</span> <span class="k">in</span> <span class="mi">1</span><span class="o">..</span><span class="n">adjacents</span><span class="nf">.len</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span> <span class="p">{</span>
        <span class="c1">// find three disjoint paths</span>
        <span class="k">for</span> <span class="n">k</span> <span class="k">in</span> <span class="mi">0</span><span class="o">..</span><span class="mi">3</span> <span class="p">{</span>
            <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">parents</span><span class="p">)</span> <span class="o">=</span> <span class="nf">get_shortest_path</span><span class="p">(</span><span class="n">adjacents</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">paths</span><span class="p">[</span><span class="mi">0</span><span class="o">..</span><span class="n">k</span><span class="p">],</span> <span class="n">start</span><span class="p">,</span> <span class="n">target</span><span class="p">)</span> <span class="k">else</span> <span class="p">{</span>
                <span class="nd">panic!</span><span class="p">(</span><span class="s">"Less than three paths from {} to {}!"</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">target</span><span class="p">);</span>
            <span class="p">};</span>
            <span class="n">paths</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="nf">.clear</span><span class="p">();</span>
            <span class="k">let</span> <span class="k">mut</span> <span class="n">cur</span> <span class="o">=</span> <span class="n">target</span><span class="p">;</span>
            <span class="k">while</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="o">&amp;</span><span class="n">parent</span><span class="p">)</span> <span class="o">=</span> <span class="n">parents</span><span class="nf">.get</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cur</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">let</span> <span class="n">link</span> <span class="o">=</span> <span class="p">(</span><span class="n">cur</span><span class="nf">.min</span><span class="p">(</span><span class="n">parent</span><span class="p">),</span> <span class="n">cur</span><span class="nf">.max</span><span class="p">(</span><span class="n">parent</span><span class="p">));</span>
                <span class="n">paths</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="nf">.push</span><span class="p">(</span><span class="n">link</span><span class="p">);</span>
                <span class="n">cur</span> <span class="o">=</span> <span class="n">parent</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="c1">// check that there is no fourth path</span>
        <span class="k">if</span> <span class="nf">get_shortest_path</span><span class="p">(</span><span class="n">adjacents</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">paths</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">target</span><span class="p">)</span><span class="nf">.is_none</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">paths</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="nd">panic!</span><span class="p">(</span><span class="s">"No solution"</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">pub</span> <span class="k">fn</span> <span class="nf">count_reachable_without_target</span><span class="p">(</span>
    <span class="n">adjacents</span><span class="p">:</span> <span class="o">&amp;</span><span class="p">[</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span><span class="p">],</span>
    <span class="n">forbidden</span><span class="p">:</span> <span class="o">&amp;</span><span class="p">[(</span><span class="nb">usize</span><span class="p">,</span> <span class="nb">usize</span><span class="p">)],</span>
    <span class="n">start</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
    <span class="n">target</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span>
<span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">queue</span> <span class="o">=</span> <span class="nn">Vec</span><span class="p">::</span><span class="nf">from</span><span class="p">([</span><span class="n">start</span><span class="p">]);</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">seen</span> <span class="o">=</span> <span class="nn">HashSet</span><span class="p">::</span><span class="nf">from</span><span class="p">([</span><span class="n">start</span><span class="p">]);</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">reached</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">while</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span> <span class="o">=</span> <span class="n">queue</span><span class="nf">.pop</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">reached</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="k">if</span> <span class="n">idx</span> <span class="o">==</span> <span class="n">target</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nb">None</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">for</span> <span class="o">&amp;</span><span class="n">adj</span> <span class="k">in</span> <span class="o">&amp;</span><span class="n">adjacents</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="p">{</span>
            <span class="k">if</span> <span class="o">!</span><span class="n">forbidden</span><span class="nf">.contains</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">adj</span><span class="nf">.min</span><span class="p">(</span><span class="n">idx</span><span class="p">),</span> <span class="n">adj</span><span class="nf">.max</span><span class="p">(</span><span class="n">idx</span><span class="p">)))</span> <span class="o">&amp;&amp;</span> <span class="n">seen</span><span class="nf">.insert</span><span class="p">(</span><span class="n">adj</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">queue</span><span class="nf">.push</span><span class="p">(</span><span class="n">adj</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="nf">Some</span><span class="p">(</span><span class="n">reached</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">pub</span> <span class="k">fn</span> <span class="nf">star_1</span><span class="p">(</span><span class="nf">PuzzleData</span><span class="p">(</span><span class="n">adjacents</span><span class="p">):</span> <span class="o">&amp;</span><span class="n">PuzzleData</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
    <span class="c1">// get a target in other part of graph with three disjoint paths</span>
    <span class="k">let</span> <span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">paths</span><span class="p">)</span> <span class="o">=</span> <span class="nf">get_target_with_three_paths</span><span class="p">(</span><span class="n">adjacents</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

    <span class="c1">// find a triple of links, one from every path, so that removal of those</span>
    <span class="c1">// links splits the graph in two</span>
    <span class="k">let</span> <span class="n">reachable</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="o">..</span><span class="n">paths</span><span class="nf">.iter</span><span class="p">()</span><span class="nf">.map</span><span class="p">(</span><span class="nn">Vec</span><span class="p">::</span><span class="n">len</span><span class="p">)</span><span class="nf">.product</span><span class="p">())</span>
        <span class="nf">.map</span><span class="p">(|</span><span class="n">k</span><span class="p">|</span> <span class="p">{</span>
            <span class="p">[</span>
                <span class="n">paths</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">k</span> <span class="o">%</span> <span class="n">paths</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="nf">.len</span><span class="p">()],</span>
                <span class="n">paths</span><span class="p">[</span><span class="mi">1</span><span class="p">][(</span><span class="n">k</span> <span class="o">/</span> <span class="n">paths</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="nf">.len</span><span class="p">())</span> <span class="o">%</span> <span class="n">paths</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="nf">.len</span><span class="p">()],</span>
                <span class="n">paths</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="n">k</span> <span class="o">/</span> <span class="p">(</span><span class="n">paths</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="nf">.len</span><span class="p">()</span> <span class="o">*</span> <span class="n">paths</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="nf">.len</span><span class="p">())],</span>
            <span class="p">]</span>
        <span class="p">})</span>
        <span class="nf">.find_map</span><span class="p">(|</span><span class="n">forbidden</span><span class="p">|</span> <span class="nf">count_reachable_without_target</span><span class="p">(</span><span class="n">adjacents</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">forbidden</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">target</span><span class="p">))</span>
        <span class="nf">.expect</span><span class="p">(</span><span class="s">"No solution!"</span><span class="p">);</span>

    <span class="c1">// return product of sizes of two disconnected parts of graph</span>
    <span class="n">reachable</span> <span class="o">*</span> <span class="p">(</span><span class="n">adjacents</span><span class="nf">.len</span><span class="p">()</span> <span class="o">-</span> <span class="n">reachable</span><span class="p">)</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_tests_24">Tests</h3>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
</pre></td><td class="code"><pre><span class="nd">#[cfg(test)]</span>
<span class="k">mod</span> <span class="n">tests</span> <span class="p">{</span>
    <span class="k">use</span> <span class="k">super</span><span class="p">::</span><span class="o">*</span><span class="p">;</span>

    <span class="k">const</span> <span class="n">CONTENT</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span> <span class="o">=</span> <span class="s">r#"jqt: rhn xhk nvd
rsh: frs pzl lsr
xhk: hfx
cmg: qnr nvd lhk bvb
rhn: xhk bvb hfx
bvb: xhk hfx
pzl: lsr hfx nvd
qnr: nvd
ntq: jqt hfx bvb xhk
nvd: lhk
lsr: lhk
rzs: qnr cmg lsr rsh
frs: qnr lhk lsr
"#</span><span class="p">;</span>

    <span class="nd">#[test]</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">test_star_1</span><span class="p">()</span> <span class="p">{</span>
        <span class="nd">assert_eq!</span><span class="p">(</span><span class="mi">54</span><span class="p">,</span> <span class="nf">star_1</span><span class="p">(</span><span class="o">&amp;</span><span class="n">CONTENT</span><span class="nf">.into</span><span class="p">()));</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p><a href="#top">Top</a></p>
</div>
</div>
</div>
</div>
</div>
<div id="footer">
    <div id="footer-text">
        Generated from <a href="https://github.com/mr-kaffee/aoc-2023/">github.com/mr-kaffee/aoc-2023/</a> on 2023-12-30 15:19:27 UTC
        with <a href="https://asciidoctor.org">asciidoctor</a>.
    </div>
</div>
</body>
</html>