<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.16">
<title>Solutions by peter</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700">
<link rel="stylesheet" href="./asciidoctor.css">
<link rel="stylesheet" href="./rouge-github.css">
</head>
<body id="top" class="article toc2 toc-right">
<div style="width:100%;margin:0 auto;max-width:62.5em;*zoom:1;position:relative;padding-left:.9375em;padding-right:.9375em">
    <div class="paragraph">
        <a href="/index.html">AoC 2023 Solutions</a>
        &bull; <a href="https://github.com/mr-kaffee/aoc-2023/">GitHub Repository</a>
        &bull; <a href="https://adventofcode.com/2023/">Advent of Code</a>
    </div>
</div>
<div id="header">
<h1>Solutions by peter</h1>
<div id="toc" class="toc2">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#sol-cpp-0">C++ | Day 0: Hello World</a>
<ul class="sectlevel2">
<li><a href="#_the_code">The code</a></li>
<li><a href="#_run_it_with_cmake">Run it with CMake</a></li>
</ul>
</li>
<li><a href="#sol-kotlin-0">Kotlin | Day 0: Hello World</a>
<ul class="sectlevel2">
<li><a href="#_the_code_2">The code</a></li>
<li><a href="#_run_it">Run it</a></li>
</ul>
</li>
<li><a href="#sol-rust-0">Rust | Day 0: Hello Ferris</a>
<ul class="sectlevel2">
<li><a href="#_general_solution_structure">General solution structure</a></li>
<li><a href="#_hello_world_implementation">Hello World implementation</a></li>
<li><a href="#_hello_world_tests">Hello World tests</a></li>
</ul>
</li>
<li><a href="#sol-haskell-1">Haskell | Day 1: Trebuchet?!</a>
<ul class="sectlevel2">
<li><a href="#_star_1">Star 1</a></li>
<li><a href="#_star_2">Star 2</a></li>
</ul>
</li>
<li><a href="#sol-rust-1">Rust | Day 1: Trebuchet?!</a>
<ul class="sectlevel2">
<li><a href="#_input">Input</a></li>
<li><a href="#_star_1_2">Star 1</a></li>
<li><a href="#_star_2_2">Star 2</a></li>
<li><a href="#_tests">Tests</a></li>
</ul>
</li>
<li><a href="#sol-haskell-2">Haskell | Day 2: Cube Conundrum</a>
<ul class="sectlevel2">
<li><a href="#_star_1_3">Star 1</a></li>
<li><a href="#_star_2_3">Star 2</a></li>
</ul>
</li>
<li><a href="#sol-rust-2">Rust | Day 2: Cube Conundrum</a>
<ul class="sectlevel2">
<li><a href="#_input_2">Input</a></li>
<li><a href="#_star_1_4">Star 1</a></li>
<li><a href="#_star_2_4">Star 2</a></li>
<li><a href="#_tests_2">Tests</a></li>
</ul>
</li>
<li><a href="#sol-rust-3">Rust | Day 3: Gear Ratios</a>
<ul class="sectlevel2">
<li><a href="#_input_3">Input</a></li>
<li><a href="#_star_1_5">Star 1</a></li>
<li><a href="#_star_2_5">Star 2</a></li>
<li><a href="#_tests_3">Tests</a></li>
</ul>
</li>
<li><a href="#sol-rust-4">Rust | Day 4: Scratchcards</a>
<ul class="sectlevel2">
<li><a href="#_input_4">Input</a></li>
<li><a href="#_star_1_6">Star 1</a></li>
<li><a href="#_star_2_6">Star 2</a></li>
<li><a href="#_tests_4">Tests</a></li>
</ul>
</li>
<li><a href="#sol-rust-5">Rust | Day 5: If You Give A Seed A Fertilizer</a>
<ul class="sectlevel2">
<li><a href="#_input_5">Input</a></li>
<li><a href="#_star_1_7">Star 1</a></li>
<li><a href="#_star_2_7">Star 2</a></li>
<li><a href="#_tests_5">Tests</a></li>
</ul>
</li>
<li><a href="#sol-rust-6">Rust | Day 6: Wait For It</a>
<ul class="sectlevel2">
<li><a href="#_star_1_8">Star 1</a></li>
<li><a href="#_star_2_8">Star 2</a></li>
<li><a href="#_benchmarks">Benchmarks</a></li>
<li><a href="#_tests_6">Tests</a></li>
</ul>
</li>
<li><a href="#sol-rust-7">Rust | Day 7: Camel Cards</a>
<ul class="sectlevel2">
<li><a href="#_input_6">Input</a></li>
<li><a href="#_star_1_9">Star 1</a></li>
<li><a href="#_star_2_9">Star 2</a></li>
<li><a href="#_tests_7">Tests</a></li>
</ul>
</li>
<li><a href="#sol-rust-8">Rust | Day 8: Haunted Wasteland</a>
<ul class="sectlevel2">
<li><a href="#_input_7">Input</a></li>
<li><a href="#_star_1_10">Star 1</a></li>
<li><a href="#_star_2_10">Star 2</a></li>
<li><a href="#_tests_8">Tests</a></li>
</ul>
</li>
<li><a href="#sol-rust-9">Rust | Day 9: Mirage Maintenance</a>
<ul class="sectlevel2">
<li><a href="#_input_8">Input</a></li>
<li><a href="#_star_1_11">Star 1</a></li>
<li><a href="#_star_2_11">Star 2</a></li>
<li><a href="#_tests_9">Tests</a></li>
</ul>
</li>
<li><a href="#sol-rust-10">Rust | Day 10: Pipe Maze</a>
<ul class="sectlevel2">
<li><a href="#_input_9">Input</a></li>
<li><a href="#_star_1_12">Star 1</a></li>
<li><a href="#_star_2_12">Star 2</a></li>
<li><a href="#_tests_10">Tests</a></li>
</ul>
</li>
<li><a href="#sol-rust-11">Day 11: Cosmic Expansion</a>
<ul class="sectlevel2">
<li><a href="#_input_10">Input</a></li>
<li><a href="#_star_1_13">Star 1</a></li>
<li><a href="#_star_2_13">Star 2</a></li>
<li><a href="#_tests_11">Tests</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="content">
<div class="sect1">
<h2 id="sol-cpp-0">C++ | Day 0: Hello World</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_the_code">The code</h3>
<div class="paragraph">
<p>This is a simple C++ template.</p>
</div>
<div class="paragraph">
<p>It reads the input in a list of lines using a <code>FileHandler</code> class implementing <em>RAII</em>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
</pre></td><td class="code"><pre><span class="k">class</span> <span class="nc">FileHandler</span> <span class="p">{</span>
<span class="nl">public:</span>
  <span class="n">FileHandler</span><span class="p">(</span><span class="n">string</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">filename</span><span class="p">)</span> <span class="o">:</span> <span class="n">_file</span><span class="p">{</span><span class="n">filename</span><span class="p">}</span> <span class="p">{}</span>
  <span class="o">~</span><span class="n">FileHandler</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">_file</span><span class="p">.</span><span class="n">is_open</span><span class="p">())</span> <span class="p">{</span>
      <span class="n">_file</span><span class="p">.</span><span class="n">close</span><span class="p">();</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">readLines</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">lines</span><span class="p">{};</span>
    <span class="n">string</span> <span class="n">line</span><span class="p">{};</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">getline</span><span class="p">(</span><span class="n">_file</span><span class="p">,</span> <span class="n">line</span><span class="p">))</span> <span class="p">{</span>
      <span class="n">lines</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">line</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">lines</span><span class="p">;</span>
  <span class="p">}</span>

<span class="nl">private:</span>
  <span class="n">ifstream</span> <span class="n">_file</span><span class="p">;</span>
<span class="p">};</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>And it does something incredibly meaningful with the input:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cpp"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
</pre></td><td class="code"><pre><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">auto</span> <span class="n">start</span> <span class="o">=</span> <span class="n">Clock</span><span class="o">::</span><span class="n">now</span><span class="p">();</span>

  <span class="k">auto</span> <span class="n">lines</span> <span class="o">=</span> <span class="n">FileHandler</span><span class="p">{</span><span class="s">"input00"</span><span class="p">}.</span><span class="n">readLines</span><span class="p">();</span>
  <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="k">const</span> <span class="o">&amp;</span><span class="n">line</span> <span class="o">:</span> <span class="n">lines</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">line</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="n">Duration</span> <span class="n">d</span> <span class="o">=</span> <span class="n">Clock</span><span class="o">::</span><span class="n">now</span><span class="p">()</span> <span class="o">-</span> <span class="n">start</span><span class="p">;</span>
  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Solved puzzle in "</span> <span class="o">&lt;&lt;</span> <span class="n">d</span><span class="p">.</span><span class="n">count</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">DURATION_UNIT</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_run_it_with_cmake">Run it with CMake</h3>
<div class="paragraph">
<p>I use CMake and its integration in VS Code to build (<code>F7</code>) and run (<code>Shift+F5</code>) the solution with this simple <code>CMakeLists.txt</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="cmake"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
</pre></td><td class="code"><pre><span class="nb">cmake_minimum_required</span><span class="p">(</span>VERSION 3.12<span class="p">)</span>

<span class="nb">set</span><span class="p">(</span>AOC_DAY <span class="s2">"00"</span><span class="p">)</span>

<span class="nb">project</span><span class="p">(</span>peter_day<span class="si">${</span><span class="nv">AOC_DAY</span><span class="si">}</span> VERSION 0.1.0<span class="p">)</span>

<span class="nb">set</span><span class="p">(</span>CMAKE_CXX_STANDARD 20<span class="p">)</span>
<span class="nb">set</span><span class="p">(</span>CMAKE_CXX_STANDARD_REQUIRED True<span class="p">)</span>

<span class="c1"># copy input to build folder</span>
<span class="nb">file</span><span class="p">(</span>COPY <span class="s2">"../../../inputs/input</span><span class="si">${</span><span class="nv">AOC_DAY</span><span class="si">}</span><span class="s2">"</span> DESTINATION <span class="s2">"</span><span class="si">${</span><span class="nv">CMAKE_BINARY_DIR</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>

<span class="nb">add_executable</span><span class="p">(</span>solution solution.cpp<span class="p">)</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p><a href="#top">Top</a></p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="sol-kotlin-0">Kotlin | Day 0: Hello World</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_the_code_2">The code</h3>
<div class="paragraph">
<p>This is a simple Kotlin template.</p>
</div>
<div class="paragraph">
<p>It reads the input in a list of lines:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="kotlin"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno">1
2
3
</pre></td><td class="code"><pre><span class="k">fun</span> <span class="nf">readLines</span><span class="p">():</span> <span class="nc">List</span><span class="p">&lt;</span><span class="nc">String</span><span class="p">&gt;</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nc">File</span><span class="p">(</span><span class="s">"../../../inputs/input00"</span><span class="p">).</span><span class="nf">useLines</span><span class="p">()</span> <span class="p">{</span> <span class="n">it</span><span class="p">.</span><span class="nf">toList</span><span class="p">()</span> <span class="p">}</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>And it does something incredibly meaningful with the input:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="kotlin"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
</pre></td><td class="code"><pre><span class="k">fun</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">val</span> <span class="py">start</span> <span class="p">=</span> <span class="nc">System</span><span class="p">.</span><span class="nf">currentTimeMillis</span><span class="p">()</span>

    <span class="kd">val</span> <span class="py">lines</span> <span class="p">=</span> <span class="nf">readLines</span><span class="p">()</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">line</span> <span class="k">in</span> <span class="n">lines</span><span class="p">)</span> <span class="p">{</span>
        <span class="nf">println</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="kd">val</span> <span class="py">elapsed</span> <span class="p">=</span> <span class="nc">System</span><span class="p">.</span><span class="nf">currentTimeMillis</span><span class="p">()</span> <span class="p">-</span> <span class="n">start</span>
    <span class="nf">println</span><span class="p">(</span><span class="s">"Solved puzzle in ${elapsed}ms."</span><span class="p">)</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_run_it">Run it</h3>
<div class="paragraph">
<p>The solutions can be run out of VS Code using the <a href="https://marketplace.visualstudio.com/items?itemName=formulahendry.code-runner">Code Runner</a> extension via the <code>Ctrl+Alt+N</code> shortcut or in the terminal using <code>kotlinc solution.kt -include-runtime -d solution.jar &amp;&amp; java -jar solution.jar</code>.</p>
</div>
<div class="paragraph">
<p><a href="#top">Top</a></p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="sol-rust-0">Rust | Day 0: Hello Ferris</h2>
<div class="sectionbody">
<div class="paragraph">
<p><a href="https://rust-lang.org">Rust</a> <strong>Hello World</strong>, <a href="https://adventofcode.com/2023/">AoC|2023</a> starts.</p>
</div>
<div class="paragraph">
<p>It will be another year of Rust solutions for me. It is just so much fun, that I am not tempted to try another language.</p>
</div>
<div class="paragraph">
<p>I will again try to not use any external dependencies and create fast solutions.</p>
</div>
<div class="sect2">
<h3 id="_general_solution_structure">General solution structure</h3>
<div class="paragraph">
<p>The general structure of my solutions will be as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code>+- src
|  +- lib.rs    // the actual implementation
|  +- main.rs   // the code to run the solution
+- Cargo.toml   // cargo manifest
+- README.adoc  // documentation of the solution</code></pre>
</div>
</div>
<div class="paragraph">
<p>The solution is run using <code>cargo run</code> or <code>cargo run --release</code>. Sometimes there will be features for solution variants, that will be run with <code>cargo run --features [some feature] --release</code>.</p>
</div>
<div class="paragraph">
<p>Typically, there will also be tests which can be executed using <code>cargo test</code> or <code>cargo test --release</code></p>
</div>
</div>
<div class="sect2">
<h3 id="_hello_world_implementation">Hello World implementation</h3>
<div class="paragraph">
<p>The implementation will typically consist of the parts detailed below.</p>
</div>
<div class="paragraph">
<p>Some meta and type information:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno">1
2
3
4
</pre></td><td class="code"><pre><span class="k">pub</span> <span class="k">const</span> <span class="n">IDENTIFIER</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span> <span class="o">=</span> <span class="s">"2023/00"</span><span class="p">;</span>

<span class="k">pub</span> <span class="k">type</span> <span class="n">InputType</span> <span class="o">=</span> <span class="nb">str</span><span class="p">;</span>
<span class="k">pub</span> <span class="k">type</span> <span class="n">Sol1Type</span> <span class="o">=</span> <span class="nb">usize</span><span class="p">;</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>Some code to parse the input (in this example, this also includes a simple <code>doctest</code>):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
</pre></td><td class="code"><pre><span class="k">pub</span> <span class="k">const</span> <span class="n">FERRIS</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span> <span class="o">=</span> <span class="s">r"    _~^~^~_
\) /  o o  \ (/
  '_   Â¬   _'
  \ '-----' /"</span><span class="p">;</span>

<span class="cd">/// Parse the puzzle input.</span>
<span class="cd">///</span>
<span class="cd">/// # Examples</span>
<span class="cd">/// ```</span>
<span class="cd">/// # use mr_kaffee_2023_00::*;</span>
<span class="cd">/// let input = parse_input();</span>
<span class="cd">/// assert_eq!(FERRIS, input, "Expect input to be ferris");</span>
<span class="cd">/// ```</span>
<span class="k">pub</span> <span class="k">fn</span> <span class="nf">parse_input</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="o">&amp;</span><span class="k">'static</span> <span class="nb">str</span> <span class="p">{</span>
    <span class="n">FERRIS</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>The implementation of the solution functions <code>star_1</code> (and for most days <code>star_2</code>):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno">1
2
3
4
</pre></td><td class="code"><pre><span class="k">pub</span> <span class="k">fn</span> <span class="n">star_1</span><span class="o">&lt;</span><span class="n">T</span><span class="p">:</span> <span class="nb">AsRef</span><span class="o">&lt;</span><span class="n">InputType</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">input</span><span class="p">:</span> <span class="n">T</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Sol1Type</span> <span class="p">{</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="n">input</span><span class="nf">.as_ref</span><span class="p">());</span>
    <span class="mi">0</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_hello_world_tests">Hello World tests</h3>
<div class="paragraph">
<p>And there are typically some tests (mostly based on the example data given in the puzzle inputs):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
</pre></td><td class="code"><pre><span class="nd">#[cfg(test)]</span>
<span class="k">mod</span> <span class="n">tests</span> <span class="p">{</span>
    <span class="k">use</span> <span class="k">super</span><span class="p">::</span><span class="o">*</span><span class="p">;</span>

    <span class="nd">#[test]</span>
    <span class="cd">/// This is a repetition of the doctest for the [`parse_input`] function.</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">test_parse_input</span><span class="p">()</span> <span class="p">{</span>
        <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">FERRIS</span><span class="p">,</span> <span class="nf">parse_input</span><span class="p">());</span>
    <span class="p">}</span>

    <span class="nd">#[test]</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">test_star_1</span><span class="p">()</span> <span class="p">{</span>
        <span class="c1">// the function star_1 can be called with a String ...</span>
        <span class="nd">assert_eq!</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nf">star_1</span><span class="p">(</span><span class="s">"owned"</span><span class="nf">.to_string</span><span class="p">()));</span>
        <span class="c1">// ... or with a &amp;str argument</span>
        <span class="nd">assert_eq!</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nf">star_1</span><span class="p">(</span><span class="s">"reference"</span><span class="p">));</span>
    <span class="p">}</span>

    <span class="nd">#[should_panic]</span>
    <span class="nd">#[test]</span>
    <span class="cd">/// This is an arbitrary test which is expected to panic.</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">test_panic</span><span class="p">()</span> <span class="p">{</span>
        <span class="nd">panic!</span><span class="p">(</span><span class="s">"This will panic!"</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p><a href="#top">Top</a></p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="sol-haskell-1">Haskell | Day 1: Trebuchet?!</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The solution is run with <code>runhaskell solution.hs</code> (or alternatively compiled with <code>ghc solution.hs</code> which creates an binary <code>solution</code>).</p>
</div>
<div class="sect2">
<h3 id="_star_1">Star 1</h3>
<div class="paragraph">
<p>The solution consists in summing the scores for every line.</p>
</div>
<div class="paragraph">
<p>The scores for a line are calculated in the <code>score1</code> function</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="haskell"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
</pre></td><td class="code"><pre><span class="c1">-- solution for both stars, use score1 or score2 as first argument</span>
<span class="n">star</span> <span class="o">::</span> <span class="p">(</span><span class="kt">String</span> <span class="o">-&gt;</span> <span class="kt">Int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">String</span> <span class="o">-&gt;</span> <span class="kt">Int</span>
<span class="n">star</span> <span class="n">f</span> <span class="o">=</span> <span class="n">sum</span> <span class="o">.</span> <span class="n">map</span> <span class="n">f</span> <span class="o">.</span> <span class="n">lines</span>

<span class="c1">-- scoring function for star1</span>
<span class="n">score1</span> <span class="o">::</span> <span class="kt">String</span> <span class="o">-&gt;</span> <span class="kt">Int</span>
<span class="n">score1</span> <span class="n">xs</span> <span class="o">=</span> <span class="mi">10</span> <span class="o">*</span> <span class="n">score1'</span> <span class="n">xs</span> <span class="o">+</span> <span class="n">score1'</span> <span class="p">(</span><span class="n">reverse</span> <span class="n">xs</span><span class="p">)</span>
  <span class="kr">where</span>
    <span class="n">score1'</span> <span class="o">::</span> <span class="kt">String</span> <span class="o">-&gt;</span> <span class="kt">Int</span>
    <span class="n">score1'</span> <span class="p">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">xs</span><span class="p">)</span>
      <span class="o">|</span> <span class="n">isDigit</span> <span class="n">x</span> <span class="o">=</span> <span class="n">ord</span> <span class="n">x</span> <span class="o">-</span> <span class="n">ord</span> <span class="sc">'0'</span>
      <span class="o">|</span> <span class="n">otherwise</span> <span class="o">=</span> <span class="n">score1'</span> <span class="n">xs</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_star_2">Star 2</h3>
<div class="paragraph">
<p>The solution for the second star uses a <code>score2</code> function which looks for digits spelled out in addition to simple digits.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="haskell"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
</pre></td><td class="code"><pre><span class="c1">-- scoring function for star2</span>
<span class="n">score2</span> <span class="o">::</span> <span class="kt">String</span> <span class="o">-&gt;</span> <span class="kt">Int</span>
<span class="n">score2</span> <span class="n">xs</span> <span class="o">=</span> <span class="mi">10</span> <span class="o">*</span> <span class="n">score2'</span> <span class="n">id</span> <span class="n">xs</span> <span class="o">+</span> <span class="n">score2'</span> <span class="n">reverse</span> <span class="p">(</span><span class="n">reverse</span> <span class="n">xs</span><span class="p">)</span>
  <span class="kr">where</span>
    <span class="n">score2'</span> <span class="o">::</span> <span class="p">(</span><span class="kt">String</span> <span class="o">-&gt;</span> <span class="kt">String</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">String</span> <span class="o">-&gt;</span> <span class="kt">Int</span>
    <span class="n">score2'</span> <span class="n">f</span> <span class="p">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">xs</span><span class="p">)</span>
      <span class="o">|</span> <span class="n">isDigit</span> <span class="n">x</span> <span class="o">=</span> <span class="n">ord</span> <span class="n">x</span> <span class="o">-</span> <span class="n">ord</span> <span class="sc">'0'</span>
      <span class="o">|</span> <span class="n">otherwise</span> <span class="o">=</span> <span class="kr">case</span> <span class="n">findIndex</span> <span class="p">((`</span><span class="n">isPrefixOf</span><span class="p">`</span> <span class="p">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">xs</span><span class="p">))</span> <span class="o">.</span> <span class="n">f</span><span class="p">)</span> <span class="n">digits</span> <span class="kr">of</span>
          <span class="kt">Just</span> <span class="n">digit</span> <span class="o">-&gt;</span> <span class="n">digit</span>
          <span class="kt">Nothing</span> <span class="o">-&gt;</span> <span class="n">score2'</span> <span class="n">f</span> <span class="n">xs</span>
      <span class="kr">where</span>
        <span class="n">digits</span> <span class="o">=</span> <span class="p">[</span><span class="s">"zero"</span><span class="p">,</span> <span class="s">"one"</span><span class="p">,</span> <span class="s">"two"</span><span class="p">,</span> <span class="s">"three"</span><span class="p">,</span> <span class="s">"four"</span><span class="p">,</span> <span class="s">"five"</span><span class="p">,</span> <span class="s">"six"</span><span class="p">,</span> <span class="s">"seven"</span><span class="p">,</span> <span class="s">"eight"</span><span class="p">,</span> <span class="s">"nine"</span><span class="p">]</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p><a href="#top">Top</a></p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="sol-rust-1">Rust | Day 1: Trebuchet?!</h2>
<div class="sectionbody">
<div class="paragraph">
<p><a href="https://rust-lang.org">Rust</a> solution to <a href="https://adventofcode.com/2023/day/1">AoC|2023|1</a>.</p>
</div>
<div class="sect2">
<h3 id="_input">Input</h3>
<div class="paragraph">
<p>No separate input processing today. Just operate on the raw character data.</p>
</div>
</div>
<div class="sect2">
<h3 id="_star_1_2">Star 1</h3>
<div class="paragraph">
<p>The solution consists of two parts:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>A <code>map_1</code> function, that returns for any <code>&amp;str</code> the value of the digit at its head wrapped in an <code>Option</code> or <code>None</code> if there is no digit.</p>
</li>
<li>
<p>A <code>score</code> function which calculates the score for a line by finding the first and last digit. The <code>map_1</code> function is passed as an argument.</p>
</li>
<li>
<p>A <code>star</code> function which calculates the solution by summing over the scores for each line. This function takes as well <code>map_1</code> as an argument.</p>
</li>
</ol>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
</pre></td><td class="code"><pre><span class="k">pub</span> <span class="k">fn</span> <span class="nf">map_1</span><span class="p">(</span><span class="n">line</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">SolT</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">b</span> <span class="o">=</span> <span class="n">line</span><span class="nf">.as_bytes</span><span class="p">()[</span><span class="mi">0</span><span class="p">];</span>
    <span class="k">match</span> <span class="n">b</span> <span class="p">{</span>
        <span class="sc">b'0'</span><span class="o">..=</span><span class="sc">b'9'</span> <span class="k">=&gt;</span> <span class="nf">Some</span><span class="p">((</span><span class="n">b</span> <span class="o">-</span> <span class="sc">b'0'</span><span class="p">)</span> <span class="k">as</span> <span class="n">_</span><span class="p">),</span>
        <span class="n">_</span> <span class="k">=&gt;</span> <span class="nb">None</span><span class="p">,</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="n">score</span><span class="o">&lt;</span><span class="n">F</span><span class="p">:</span> <span class="nf">Fn</span><span class="p">(</span><span class="o">&amp;</span><span class="nb">str</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">SolT</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">l</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">,</span> <span class="n">f</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">F</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">SolT</span> <span class="p">{</span>
    <span class="p">(</span><span class="mi">0</span><span class="o">..</span><span class="n">l</span><span class="nf">.len</span><span class="p">())</span><span class="nf">.map</span><span class="p">(|</span><span class="n">k</span><span class="p">|</span> <span class="o">&amp;</span><span class="n">l</span><span class="p">[</span><span class="n">k</span><span class="o">..</span><span class="p">])</span><span class="nf">.find_map</span><span class="p">(</span><span class="n">f</span><span class="p">)</span><span class="nf">.unwrap</span><span class="p">()</span> <span class="o">*</span> <span class="mi">10</span>
        <span class="o">+</span> <span class="p">(</span><span class="mi">0</span><span class="o">..</span><span class="n">l</span><span class="nf">.len</span><span class="p">())</span><span class="nf">.rev</span><span class="p">()</span><span class="nf">.map</span><span class="p">(|</span><span class="n">k</span><span class="p">|</span> <span class="o">&amp;</span><span class="n">l</span><span class="p">[</span><span class="n">k</span><span class="o">..</span><span class="p">])</span><span class="nf">.find_map</span><span class="p">(</span><span class="n">f</span><span class="p">)</span><span class="nf">.unwrap</span><span class="p">()</span>
<span class="p">}</span>

<span class="k">pub</span> <span class="k">fn</span> <span class="n">star</span><span class="o">&lt;</span><span class="n">F</span><span class="p">:</span> <span class="nf">Fn</span><span class="p">(</span><span class="o">&amp;</span><span class="nb">str</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">SolT</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">,</span> <span class="n">map</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">F</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">SolT</span> <span class="p">{</span>
    <span class="n">data</span><span class="nf">.lines</span><span class="p">()</span><span class="nf">.map</span><span class="p">(|</span><span class="n">line</span><span class="p">|</span> <span class="nf">score</span><span class="p">(</span><span class="n">line</span><span class="p">,</span> <span class="n">map</span><span class="p">))</span><span class="nf">.sum</span><span class="p">()</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>Catches for the 1st star:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>There may be lines with only one digit. In that case, it is the first and the last digit.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_star_2_2">Star 2</h3>
<div class="paragraph">
<p>All that is needed for the second star is to extend <code>map_1</code> function to <code>map_2</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno">1
2
3
4
5
6
7
</pre></td><td class="code"><pre><span class="k">const</span> <span class="n">DIGITS</span><span class="p">:</span> <span class="o">&amp;</span><span class="p">[</span><span class="o">&amp;</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">[</span>
    <span class="s">"zero"</span><span class="p">,</span> <span class="s">"one"</span><span class="p">,</span> <span class="s">"two"</span><span class="p">,</span> <span class="s">"three"</span><span class="p">,</span> <span class="s">"four"</span><span class="p">,</span> <span class="s">"five"</span><span class="p">,</span> <span class="s">"six"</span><span class="p">,</span> <span class="s">"seven"</span><span class="p">,</span> <span class="s">"eight"</span><span class="p">,</span> <span class="s">"nine"</span><span class="p">,</span>
<span class="p">];</span>

<span class="k">pub</span> <span class="k">fn</span> <span class="nf">map_2</span><span class="p">(</span><span class="n">line</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">SolT</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="nf">map_1</span><span class="p">(</span><span class="n">line</span><span class="p">)</span><span class="nf">.or_else</span><span class="p">(||</span> <span class="p">(</span><span class="mi">0</span><span class="o">..</span><span class="n">DIGITS</span><span class="nf">.len</span><span class="p">())</span><span class="nf">.find</span><span class="p">(|</span><span class="o">&amp;</span><span class="n">digit</span><span class="p">|</span> <span class="n">line</span><span class="nf">.starts_with</span><span class="p">(</span><span class="n">DIGITS</span><span class="p">[</span><span class="n">digit</span><span class="p">])))</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>Catches for the 2nd star:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Textual representation of digits may overlap like in <strong>oneight</strong> (this is not an issue when searching from the end of the string, my initial solution just searched for all digits in a line and skipped characters belonging to one digit for the next step)</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_tests">Tests</h3>
<div class="paragraph">
<p>Just check the scores for the sample data.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
</pre></td><td class="code"><pre><span class="nd">#[cfg(test)]</span>
<span class="k">mod</span> <span class="n">tests</span> <span class="p">{</span>
    <span class="k">use</span> <span class="k">super</span><span class="p">::</span><span class="o">*</span><span class="p">;</span>

    <span class="k">const</span> <span class="n">CONTENT_1</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span> <span class="o">=</span> <span class="s">r#"1abc2
pqr3stu8vwx
a1b2c3d4e5f
treb7uchet
"#</span><span class="p">;</span>

    <span class="nd">#[test]</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">test_star_1</span><span class="p">()</span> <span class="p">{</span>
        <span class="nd">assert_eq!</span><span class="p">(</span><span class="mi">142</span><span class="p">,</span> <span class="nf">star</span><span class="p">(</span><span class="n">CONTENT_1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">map_1</span><span class="p">));</span>
    <span class="p">}</span>

    <span class="k">const</span> <span class="n">CONTENT_2</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span> <span class="o">=</span> <span class="s">r#"two1nine
eightwothree
abcone2threexyz
xtwone3four
4nineeightseven2
zoneight234
7pqrstsixteen
"#</span><span class="p">;</span>

    <span class="nd">#[test]</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">test_star_2</span><span class="p">()</span> <span class="p">{</span>
        <span class="nd">assert_eq!</span><span class="p">(</span><span class="mi">281</span><span class="p">,</span> <span class="nf">star</span><span class="p">(</span><span class="n">CONTENT_2</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">map_2</span><span class="p">));</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p><a href="#top">Top</a></p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="sol-haskell-2">Haskell | Day 2: Cube Conundrum</h2>
<div class="sectionbody">
<div class="paragraph">
<p>I struggled a bit parsing the input.</p>
</div>
<div class="paragraph">
<p>What eventually helped was to realize, that every pair of a count and a color can be considered independently. There is no need to group them to draws with cubes of different colors. In other words: the colors can be considered independently.</p>
</div>
<div class="sect2">
<h3 id="_star_1_3">Star 1</h3>
<div class="paragraph">
<p>I have two helper functions to separate the ID from the draws and to choose one argument out of three given a color string:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="haskell"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
</pre></td><td class="code"><pre><span class="c1">-- extract Game id: ...draws... into (id, ...draws...)</span>
<span class="n">splitId</span> <span class="o">::</span> <span class="kt">String</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="kt">Int</span><span class="p">,</span> <span class="kt">String</span><span class="p">)</span>
<span class="n">splitId</span> <span class="n">line</span><span class="o">@</span><span class="p">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">xs</span><span class="p">)</span>
  <span class="o">|</span> <span class="n">isDigit</span> <span class="n">x</span> <span class="o">=</span> <span class="n">splitId'</span> <span class="mi">0</span> <span class="n">line</span>
  <span class="o">|</span> <span class="n">otherwise</span> <span class="o">=</span> <span class="n">splitId</span> <span class="n">xs</span>
  <span class="kr">where</span>
    <span class="n">splitId'</span> <span class="o">::</span> <span class="kt">Int</span> <span class="o">-&gt;</span> <span class="kt">String</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="kt">Int</span><span class="p">,</span> <span class="kt">String</span><span class="p">)</span>
    <span class="n">splitId'</span> <span class="n">id</span> <span class="p">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">xs</span><span class="p">)</span>
      <span class="o">|</span> <span class="n">isDigit</span> <span class="n">x</span> <span class="o">=</span> <span class="n">splitId'</span> <span class="p">(</span><span class="mi">10</span> <span class="o">*</span> <span class="n">id</span> <span class="o">+</span> <span class="p">(</span><span class="n">ord</span> <span class="n">x</span> <span class="o">-</span> <span class="n">ord</span> <span class="sc">'0'</span><span class="p">))</span> <span class="n">xs</span>
    <span class="n">splitId'</span> <span class="n">id</span> <span class="p">(</span><span class="sc">':'</span> <span class="o">:</span> <span class="sc">' '</span> <span class="o">:</span> <span class="n">xs</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="n">id</span><span class="p">,</span> <span class="n">xs</span><span class="p">)</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>With this, the solution to star1 looks as follows (see explanation in the comments):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="haskell"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
</pre></td><td class="code"><pre><span class="c1">-- sum over ids of all lines which respect the limits</span>
<span class="n">star1</span> <span class="o">::</span> <span class="kt">String</span> <span class="o">-&gt;</span> <span class="kt">Int</span>
<span class="n">star1</span> <span class="o">=</span> <span class="n">sum</span> <span class="o">.</span> <span class="n">map</span> <span class="n">fst</span> <span class="o">.</span> <span class="n">filter</span> <span class="p">(</span><span class="n">allSmaller</span> <span class="mi">12</span> <span class="mi">13</span> <span class="mi">14</span> <span class="o">.</span> <span class="n">words</span> <span class="o">.</span> <span class="n">snd</span><span class="p">)</span> <span class="o">.</span> <span class="n">map</span> <span class="n">splitId</span> <span class="o">.</span> <span class="n">lines</span>
  <span class="kr">where</span>
    <span class="c1">-- essentially a foldl which consumes two elements (count and color) at once</span>
    <span class="n">allSmaller</span> <span class="o">::</span> <span class="kt">Int</span> <span class="o">-&gt;</span> <span class="kt">Int</span> <span class="o">-&gt;</span> <span class="kt">Int</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="kt">String</span><span class="p">]</span> <span class="o">-&gt;</span> <span class="kt">Bool</span>
    <span class="n">allSmaller</span> <span class="kr">_</span> <span class="kr">_</span> <span class="kr">_</span> <span class="kt">[]</span> <span class="o">=</span> <span class="kt">True</span>
    <span class="n">allSmaller</span> <span class="n">r</span> <span class="n">g</span> <span class="n">b</span> <span class="p">(</span><span class="n">n</span> <span class="o">:</span> <span class="p">(</span><span class="n">c</span> <span class="o">:</span> <span class="kr">_</span><span class="p">)</span> <span class="o">:</span> <span class="n">xs</span><span class="p">)</span>
      <span class="o">|</span> <span class="n">read</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="n">v</span> <span class="o">=</span> <span class="kt">False</span>
      <span class="o">|</span> <span class="n">otherwise</span> <span class="o">=</span> <span class="n">allSmaller</span> <span class="n">r</span> <span class="n">g</span> <span class="n">b</span> <span class="n">xs</span>
      <span class="kr">where</span>
        <span class="n">v</span> <span class="o">=</span> <span class="kr">case</span> <span class="n">c</span> <span class="kr">of</span>
          <span class="sc">'r'</span> <span class="o">-&gt;</span> <span class="n">r</span>
          <span class="sc">'g'</span> <span class="o">-&gt;</span> <span class="n">g</span>
          <span class="sc">'b'</span> <span class="o">-&gt;</span> <span class="n">b</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_star_2_3">Star 2</h3>
<div class="paragraph">
<p>Star 2 is quite similar besides there is just mapping, no filtering:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="haskell"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
</pre></td><td class="code"><pre><span class="c1">-- sum of product of maximum for every color for every line</span>
<span class="n">star2</span> <span class="o">::</span> <span class="kt">String</span> <span class="o">-&gt;</span> <span class="kt">Int</span>
<span class="n">star2</span> <span class="o">=</span> <span class="n">sum</span> <span class="o">.</span> <span class="n">map</span> <span class="p">(</span><span class="n">prod'</span> <span class="o">.</span> <span class="n">maxByColor</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">.</span> <span class="n">words</span> <span class="o">.</span> <span class="n">snd</span> <span class="o">.</span> <span class="n">splitId</span><span class="p">)</span> <span class="o">.</span> <span class="n">lines</span>
  <span class="kr">where</span>
    <span class="n">prod'</span> <span class="o">::</span> <span class="p">(</span><span class="kt">Int</span><span class="p">,</span> <span class="kt">Int</span><span class="p">,</span> <span class="kt">Int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Int</span>
    <span class="n">prod'</span> <span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="o">=</span> <span class="n">r</span> <span class="o">*</span> <span class="n">g</span> <span class="o">*</span> <span class="n">b</span>
    <span class="c1">-- essentially a foldl which consumes two elements (count and color) at once</span>
    <span class="n">maxByColor</span> <span class="o">::</span> <span class="p">(</span><span class="kt">Int</span><span class="p">,</span> <span class="kt">Int</span><span class="p">,</span> <span class="kt">Int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="kt">String</span><span class="p">]</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="kt">Int</span><span class="p">,</span> <span class="kt">Int</span><span class="p">,</span> <span class="kt">Int</span><span class="p">)</span>
    <span class="n">maxByColor</span> <span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="kt">[]</span> <span class="o">=</span> <span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
    <span class="n">maxByColor</span> <span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="p">(</span><span class="n">n'</span> <span class="o">:</span> <span class="p">(</span><span class="n">c</span> <span class="o">:</span> <span class="kr">_</span><span class="p">)</span> <span class="o">:</span> <span class="n">xs</span><span class="p">)</span>
      <span class="o">|</span> <span class="n">c</span> <span class="o">==</span> <span class="sc">'r'</span> <span class="o">=</span> <span class="n">maxByColor</span> <span class="p">(</span><span class="n">max</span> <span class="n">r</span> <span class="n">n</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="n">xs</span>
      <span class="o">|</span> <span class="n">c</span> <span class="o">==</span> <span class="sc">'g'</span> <span class="o">=</span> <span class="n">maxByColor</span> <span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">max</span> <span class="n">g</span> <span class="n">n</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="n">xs</span>
      <span class="o">|</span> <span class="n">c</span> <span class="o">==</span> <span class="sc">'b'</span> <span class="o">=</span> <span class="n">maxByColor</span> <span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">max</span> <span class="n">b</span> <span class="n">n</span><span class="p">)</span> <span class="n">xs</span>
      <span class="kr">where</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">read</span> <span class="n">n'</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p><a href="#top">Top</a></p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="sol-rust-2">Rust | Day 2: Cube Conundrum</h2>
<div class="sectionbody">
<div class="paragraph">
<p><a href="https://rust-lang.org">Rust</a> solution to <a href="https://adventofcode.com/2023/day/2">AoC|2023|2</a>.</p>
</div>
<div class="sect2">
<h3 id="_input_2">Input</h3>
<div class="paragraph">
<p>As it is the case quite often, parsing the input was the biggest part of today&#8217;s puzzle. Maybe I should stop separate parsing the input and solving the challenge and just do it in one pass?</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
</pre></td><td class="code"><pre><span class="k">pub</span> <span class="k">mod</span> <span class="n">input</span> <span class="p">{</span>
    <span class="k">use</span> <span class="k">crate</span><span class="p">::</span><span class="n">SolT</span><span class="p">;</span>

    <span class="nd">#[derive(Debug)]</span>
    <span class="k">pub</span> <span class="k">struct</span> <span class="nf">PuzzleData</span><span class="p">(</span><span class="k">pub</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="p">[</span><span class="n">SolT</span><span class="p">;</span> <span class="mi">3</span><span class="p">]</span><span class="o">&gt;&gt;</span><span class="p">);</span>

    <span class="k">fn</span> <span class="nf">parse_draw</span><span class="p">(</span><span class="n">line</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="p">[</span><span class="n">SolT</span><span class="p">;</span> <span class="mi">3</span><span class="p">]</span> <span class="p">{</span>
        <span class="n">line</span><span class="nf">.split</span><span class="p">(</span><span class="s">", "</span><span class="p">)</span><span class="nf">.fold</span><span class="p">([</span><span class="mi">0</span><span class="p">;</span> <span class="mi">3</span><span class="p">],</span> <span class="p">|[</span><span class="n">r</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">b</span><span class="p">],</span> <span class="n">color</span><span class="p">|</span> <span class="p">{</span>
            <span class="k">match</span> <span class="n">color</span>
                <span class="nf">.split_once</span><span class="p">(</span><span class="sc">' '</span><span class="p">)</span>
                <span class="nf">.map</span><span class="p">(|(</span><span class="n">n</span><span class="p">,</span> <span class="n">c</span><span class="p">)|</span> <span class="p">(</span><span class="n">n</span><span class="py">.parse</span><span class="p">::</span><span class="o">&lt;</span><span class="n">SolT</span><span class="o">&gt;</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">(),</span> <span class="n">c</span><span class="p">))</span>
            <span class="p">{</span>
                <span class="nf">Some</span><span class="p">((</span><span class="n">n</span><span class="p">,</span> <span class="s">"red"</span><span class="p">))</span> <span class="k">=&gt;</span> <span class="p">[</span><span class="n">r</span> <span class="o">+</span> <span class="n">n</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">b</span><span class="p">],</span>
                <span class="nf">Some</span><span class="p">((</span><span class="n">n</span><span class="p">,</span> <span class="s">"green"</span><span class="p">))</span> <span class="k">=&gt;</span> <span class="p">[</span><span class="n">r</span><span class="p">,</span> <span class="n">g</span> <span class="o">+</span> <span class="n">n</span><span class="p">,</span> <span class="n">b</span><span class="p">],</span>
                <span class="nf">Some</span><span class="p">((</span><span class="n">n</span><span class="p">,</span> <span class="s">"blue"</span><span class="p">))</span> <span class="k">=&gt;</span> <span class="p">[</span><span class="n">r</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">b</span> <span class="o">+</span> <span class="n">n</span><span class="p">],</span>
                <span class="n">_</span> <span class="k">=&gt;</span> <span class="nd">panic!</span><span class="p">(</span><span class="s">"Unexpected draw."</span><span class="p">),</span>
            <span class="p">}</span>
        <span class="p">})</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="nf">parse_game</span><span class="p">(</span><span class="n">line</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="p">[</span><span class="n">SolT</span><span class="p">;</span> <span class="mi">3</span><span class="p">]</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="n">line</span><span class="nf">.split_once</span><span class="p">(</span><span class="s">": "</span><span class="p">)</span>
            <span class="nf">.unwrap</span><span class="p">()</span>
            <span class="na">.1</span>
            <span class="nf">.split</span><span class="p">(</span><span class="s">"; "</span><span class="p">)</span>
            <span class="nf">.map</span><span class="p">(</span><span class="n">parse_draw</span><span class="p">)</span>
            <span class="nf">.collect</span><span class="p">()</span>
    <span class="p">}</span>

    <span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="p">:</span> <span class="nb">AsRef</span><span class="o">&lt;</span><span class="nb">str</span><span class="o">&gt;&gt;</span> <span class="nb">From</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="k">for</span> <span class="n">PuzzleData</span> <span class="p">{</span>
        <span class="k">fn</span> <span class="nf">from</span><span class="p">(</span><span class="n">s</span><span class="p">:</span> <span class="n">T</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
            <span class="nf">PuzzleData</span><span class="p">(</span><span class="n">s</span><span class="nf">.as_ref</span><span class="p">()</span><span class="nf">.lines</span><span class="p">()</span><span class="nf">.map</span><span class="p">(</span><span class="n">parse_game</span><span class="p">)</span><span class="nf">.collect</span><span class="p">())</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_star_1_4">Star 1</h3>
<div class="paragraph">
<p>iter (enumerated) &#8230;&#8203; filter &#8230;&#8203; map &#8230;&#8203; sum</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
</pre></td><td class="code"><pre><span class="k">pub</span> <span class="k">fn</span> <span class="nf">star_1</span><span class="p">(</span><span class="nf">PuzzleData</span><span class="p">(</span><span class="n">games</span><span class="p">):</span> <span class="o">&amp;</span><span class="n">PuzzleData</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">SolT</span> <span class="p">{</span>
    <span class="n">games</span>
        <span class="nf">.iter</span><span class="p">()</span>
        <span class="nf">.enumerate</span><span class="p">()</span>
        <span class="nf">.filter</span><span class="p">(|(</span><span class="n">_</span><span class="p">,</span> <span class="n">game</span><span class="p">)|</span> <span class="p">{</span>
            <span class="n">game</span><span class="nf">.iter</span><span class="p">()</span>
                <span class="nf">.all</span><span class="p">(|[</span><span class="n">r</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">b</span><span class="p">]|</span> <span class="o">*</span><span class="n">r</span> <span class="o">&lt;=</span> <span class="mi">12</span> <span class="o">&amp;&amp;</span> <span class="o">*</span><span class="n">g</span> <span class="o">&lt;=</span> <span class="mi">13</span> <span class="o">&amp;&amp;</span> <span class="o">*</span><span class="n">b</span> <span class="o">&lt;=</span> <span class="mi">14</span><span class="p">)</span>
        <span class="p">})</span>
        <span class="nf">.map</span><span class="p">(|(</span><span class="n">pos</span><span class="p">,</span> <span class="n">_</span><span class="p">)|</span> <span class="n">pos</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="nf">.sum</span><span class="p">()</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_star_2_4">Star 2</h3>
<div class="paragraph">
<p>iter &#8230;&#8203; map (nested iter &#8230;&#8203; fold) &#8230;&#8203; map &#8230;&#8203; sum</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
</pre></td><td class="code"><pre><span class="k">pub</span> <span class="k">fn</span> <span class="nf">star_2</span><span class="p">(</span><span class="nf">PuzzleData</span><span class="p">(</span><span class="n">games</span><span class="p">):</span> <span class="o">&amp;</span><span class="n">PuzzleData</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">SolT</span> <span class="p">{</span>
    <span class="n">games</span>
        <span class="nf">.iter</span><span class="p">()</span>
        <span class="nf">.map</span><span class="p">(|</span><span class="n">game</span><span class="p">|</span> <span class="p">{</span>
            <span class="n">game</span><span class="nf">.iter</span><span class="p">()</span>
                <span class="nf">.fold</span><span class="p">([</span><span class="mi">0</span><span class="p">;</span> <span class="mi">3</span><span class="p">],</span> <span class="p">|[</span><span class="n">r_max</span><span class="p">,</span> <span class="n">g_max</span><span class="p">,</span> <span class="n">b_max</span><span class="p">],</span> <span class="p">[</span><span class="n">r</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">b</span><span class="p">]|</span> <span class="p">{</span>
                    <span class="p">[</span><span class="n">r_max</span><span class="nf">.max</span><span class="p">(</span><span class="o">*</span><span class="n">r</span><span class="p">),</span> <span class="n">g_max</span><span class="nf">.max</span><span class="p">(</span><span class="o">*</span><span class="n">g</span><span class="p">),</span> <span class="n">b_max</span><span class="nf">.max</span><span class="p">(</span><span class="o">*</span><span class="n">b</span><span class="p">)]</span>
                <span class="p">})</span>
        <span class="p">})</span>
        <span class="nf">.map</span><span class="p">(|[</span><span class="n">r</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">b</span><span class="p">]|</span> <span class="n">r</span> <span class="o">*</span> <span class="n">g</span> <span class="o">*</span> <span class="n">b</span><span class="p">)</span>
        <span class="nf">.sum</span><span class="p">()</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_tests_2">Tests</h3>
<div class="paragraph">
<p>I proudly announce: all tests passed the first time I executed (normally, I never miss any occasion to do stupid mistakes)</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
</pre></td><td class="code"><pre><span class="nd">#[cfg(test)]</span>
<span class="k">mod</span> <span class="n">tests</span> <span class="p">{</span>
    <span class="k">use</span> <span class="k">super</span><span class="p">::</span><span class="o">*</span><span class="p">;</span>

    <span class="k">const</span> <span class="n">CONTENT</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span> <span class="o">=</span> <span class="s">r#"Game 1: 3 blue, 4 red; 1 red, 2 green, 6 blue; 2 green
Game 2: 1 blue, 2 green; 3 green, 4 blue, 1 red; 1 green, 1 blue
Game 3: 8 green, 6 blue, 20 red; 5 blue, 4 red, 13 green; 5 green, 1 red
Game 4: 1 green, 3 red, 6 blue; 3 green, 6 red; 3 green, 15 blue, 14 red
Game 5: 6 red, 1 blue, 3 green; 2 blue, 1 red, 2 green
"#</span><span class="p">;</span>

    <span class="nd">#[test]</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">test_from</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">expected</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="p">[</span><span class="n">SolT</span><span class="p">;</span> <span class="mi">3</span><span class="p">]</span><span class="o">&gt;&gt;</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[</span>
            <span class="nd">vec!</span><span class="p">[[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">]],</span>
            <span class="nd">vec!</span><span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]],</span>
            <span class="nd">vec!</span><span class="p">[[</span><span class="mi">20</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">13</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">0</span><span class="p">]],</span>
            <span class="nd">vec!</span><span class="p">[[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span> <span class="p">[</span><span class="mi">6</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">14</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">15</span><span class="p">]],</span>
            <span class="nd">vec!</span><span class="p">[[</span><span class="mi">6</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]],</span>
        <span class="p">];</span>
        <span class="k">let</span> <span class="nf">PuzzleData</span><span class="p">(</span><span class="n">games</span><span class="p">)</span> <span class="o">=</span> <span class="nn">PuzzleData</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="n">CONTENT</span><span class="p">);</span>
        <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">expected</span><span class="p">,</span> <span class="n">games</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="nd">#[test]</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">test_star_1</span><span class="p">()</span> <span class="p">{</span>
        <span class="nd">assert_eq!</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="nf">star_1</span><span class="p">(</span><span class="o">&amp;</span><span class="n">CONTENT</span><span class="nf">.into</span><span class="p">()));</span>
    <span class="p">}</span>

    <span class="nd">#[test]</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">test_star_2</span><span class="p">()</span> <span class="p">{</span>
        <span class="nd">assert_eq!</span><span class="p">(</span><span class="mi">2286</span><span class="p">,</span> <span class="nf">star_2</span><span class="p">(</span><span class="o">&amp;</span><span class="n">CONTENT</span><span class="nf">.into</span><span class="p">()));</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p><a href="#top">Top</a></p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="sol-rust-3">Rust | Day 3: Gear Ratios</h2>
<div class="sectionbody">
<div class="paragraph">
<p><a href="https://rust-lang.org">Rust</a> solution to <a href="https://adventofcode.com/2023/day/3">AoC|2023|3</a>.</p>
</div>
<div class="sect2">
<h3 id="_input_3">Input</h3>
<div class="paragraph">
<p>I just read the input into a grid. To simplify handling at the boundary, a layer of empty space (<code>'.'</code>) is added around the original data.</p>
</div>
</div>
<div class="sect2">
<h3 id="_star_1_5">Star 1</h3>
<div class="paragraph">
<p>I created a helper function <code>numbers</code> that returns an iterator over all numbers in the input data with the help of the <code>next_number</code> function. Actually, the iterator returns a tuple with the number&#8217;s value, its position in the grid, and its length (number of digits).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
</pre></td><td class="code"><pre><span class="k">pub</span> <span class="k">fn</span> <span class="nf">numbers</span><span class="p">(</span><span class="n">grid</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Grid</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">impl</span> <span class="nb">Iterator</span><span class="o">&lt;</span><span class="n">Item</span> <span class="o">=</span> <span class="p">(</span><span class="n">SolT</span><span class="p">,</span> <span class="nb">usize</span><span class="p">,</span> <span class="nb">usize</span><span class="p">)</span><span class="o">&gt;</span> <span class="o">+</span> <span class="nv">'_</span> <span class="p">{</span>
    <span class="nf">successors</span><span class="p">(</span><span class="nf">next_number</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">|(</span><span class="n">_</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">len</span><span class="p">)|</span> <span class="p">{</span>
        <span class="nf">next_number</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">pos</span> <span class="o">+</span> <span class="n">len</span><span class="p">)</span>
    <span class="p">})</span>
<span class="p">}</span>

<span class="k">pub</span> <span class="k">fn</span> <span class="nf">next_number</span><span class="p">(</span><span class="n">grid</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Grid</span><span class="p">,</span> <span class="n">offset</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="p">(</span><span class="n">SolT</span><span class="p">,</span> <span class="nb">usize</span><span class="p">,</span> <span class="nb">usize</span><span class="p">)</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="n">grid</span><span class="nf">.data</span><span class="p">()[</span><span class="n">offset</span><span class="o">..</span><span class="p">]</span>
        <span class="nf">.iter</span><span class="p">()</span>
        <span class="nf">.position</span><span class="p">(|</span><span class="n">b</span><span class="p">|</span> <span class="p">(</span><span class="sc">b'0'</span><span class="o">..=</span><span class="sc">b'9'</span><span class="p">)</span><span class="nf">.contains</span><span class="p">(</span><span class="n">b</span><span class="p">))</span>
        <span class="nf">.map</span><span class="p">(|</span><span class="n">pos</span><span class="p">|</span> <span class="p">{</span>
            <span class="n">grid</span><span class="nf">.data</span><span class="p">()[</span><span class="n">offset</span> <span class="o">+</span> <span class="n">pos</span><span class="o">..</span><span class="p">]</span>
                <span class="nf">.iter</span><span class="p">()</span>
                <span class="nf">.take_while</span><span class="p">(|</span><span class="n">b</span><span class="p">|</span> <span class="p">(</span><span class="sc">b'0'</span><span class="o">..=</span><span class="sc">b'9'</span><span class="p">)</span><span class="nf">.contains</span><span class="p">(</span><span class="n">b</span><span class="p">))</span>
                <span class="nf">.fold</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="n">offset</span> <span class="o">+</span> <span class="n">pos</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">|(</span><span class="n">val</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">len</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">|</span> <span class="p">{</span>
                    <span class="p">(</span><span class="mi">10</span> <span class="o">*</span> <span class="n">val</span> <span class="o">+</span> <span class="p">(</span><span class="n">b</span> <span class="o">-</span> <span class="sc">b'0'</span><span class="p">)</span> <span class="k">as</span> <span class="n">SolT</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">len</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
                <span class="p">})</span>
        <span class="p">})</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>For every number, we need to check all adjacent positions in the input data, so I created another helper function <code>run_around</code>, which iterates over all adjacent positions (by chaining iterators looking above, to the right, below, and to the left):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
</pre></td><td class="code"><pre><span class="k">pub</span> <span class="k">fn</span> <span class="nf">run_around</span><span class="p">((</span><span class="n">col</span><span class="p">,</span> <span class="n">row</span><span class="p">):</span> <span class="p">(</span><span class="nb">usize</span><span class="p">,</span> <span class="nb">usize</span><span class="p">),</span> <span class="n">len</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">impl</span> <span class="nb">Iterator</span><span class="o">&lt;</span><span class="n">Item</span> <span class="o">=</span> <span class="p">(</span><span class="nb">usize</span><span class="p">,</span> <span class="nb">usize</span><span class="p">)</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="p">(</span><span class="n">col</span> <span class="o">-</span> <span class="mi">1</span><span class="o">..</span><span class="n">col</span> <span class="o">+</span> <span class="n">len</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="nf">.map</span><span class="p">(</span><span class="k">move</span> <span class="p">|</span><span class="n">col</span><span class="p">|</span> <span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="n">row</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
        <span class="nf">.chain</span><span class="p">(</span><span class="nf">once</span><span class="p">((</span><span class="n">col</span> <span class="o">+</span> <span class="n">len</span><span class="p">,</span> <span class="n">row</span><span class="p">)))</span>
        <span class="nf">.chain</span><span class="p">(</span>
            <span class="p">(</span><span class="n">col</span> <span class="o">-</span> <span class="mi">1</span><span class="o">..</span><span class="n">col</span> <span class="o">+</span> <span class="n">len</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
                <span class="nf">.rev</span><span class="p">()</span>
                <span class="nf">.map</span><span class="p">(</span><span class="k">move</span> <span class="p">|</span><span class="n">col</span><span class="p">|</span> <span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="n">row</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)),</span>
        <span class="p">)</span>
        <span class="nf">.chain</span><span class="p">(</span><span class="nf">once</span><span class="p">((</span><span class="n">col</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">row</span><span class="p">)))</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>With those helpers in place, the solution for the first star is obtained by filtering out all numbers that are not adjacent to a symbol and summing their values:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
</pre></td><td class="code"><pre><span class="k">pub</span> <span class="k">fn</span> <span class="nf">star_1</span><span class="p">(</span><span class="nf">PuzzleData</span><span class="p">(</span><span class="n">grid</span><span class="p">):</span> <span class="o">&amp;</span><span class="n">PuzzleData</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">SolT</span> <span class="p">{</span>
    <span class="nf">numbers</span><span class="p">(</span><span class="n">grid</span><span class="p">)</span>
        <span class="nf">.filter</span><span class="p">(|(</span><span class="n">_</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">len</span><span class="p">)|</span> <span class="p">{</span>
            <span class="nf">run_around</span><span class="p">(</span><span class="n">grid</span><span class="nf">.to_col_row</span><span class="p">(</span><span class="o">*</span><span class="n">pos</span><span class="p">),</span> <span class="o">*</span><span class="n">len</span><span class="p">)</span>
                <span class="nf">.map</span><span class="p">(|</span><span class="n">pos</span><span class="p">|</span> <span class="n">grid</span><span class="p">[</span><span class="n">pos</span><span class="p">])</span>
                <span class="nf">.any</span><span class="p">(|</span><span class="n">b</span><span class="p">:</span> <span class="nb">u8</span><span class="p">|</span> <span class="n">b</span> <span class="o">!=</span> <span class="sc">b'.'</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="sc">b'0'</span><span class="o">..=</span><span class="sc">b'9'</span><span class="p">)</span><span class="nf">.contains</span><span class="p">(</span><span class="o">&amp;</span><span class="n">b</span><span class="p">))</span>
        <span class="p">})</span>
        <span class="nf">.map</span><span class="p">(|(</span><span class="n">value</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">)|</span> <span class="n">value</span><span class="p">)</span>
        <span class="nf">.sum</span><span class="p">()</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_star_2_5">Star 2</h3>
<div class="paragraph">
<p>The second star makes use of the same helper functions as the first star. I first iterate through all the numbers to create a map of the positions of the gear ratio symbols '*' to lists of adjacent numbers. Then I iterate through this map, filter out all entries that do not have exactly two numbers in the list, map to the product of those two numbers, and take the sum.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
</pre></td><td class="code"><pre><span class="k">pub</span> <span class="k">fn</span> <span class="nf">star_2</span><span class="p">(</span><span class="nf">PuzzleData</span><span class="p">(</span><span class="n">grid</span><span class="p">):</span> <span class="o">&amp;</span><span class="n">PuzzleData</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">SolT</span> <span class="p">{</span>
    <span class="nf">numbers</span><span class="p">(</span><span class="n">grid</span><span class="p">)</span>
        <span class="nf">.fold</span><span class="p">(</span><span class="nn">HashMap</span><span class="p">::</span><span class="nf">new</span><span class="p">(),</span> <span class="p">|</span><span class="n">map</span><span class="p">,</span> <span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">len</span><span class="p">)|</span> <span class="p">{</span>
            <span class="nf">run_around</span><span class="p">(</span><span class="n">grid</span><span class="nf">.to_col_row</span><span class="p">(</span><span class="n">pos</span><span class="p">),</span> <span class="n">len</span><span class="p">)</span>
                <span class="nf">.filter</span><span class="p">(|</span><span class="o">&amp;</span><span class="n">pos</span><span class="p">|</span> <span class="n">grid</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span> <span class="o">==</span> <span class="sc">b'*'</span><span class="p">)</span>
                <span class="nf">.fold</span><span class="p">(</span><span class="n">map</span><span class="p">,</span> <span class="p">|</span><span class="k">mut</span> <span class="n">map</span><span class="p">,</span> <span class="n">pos</span><span class="p">|</span> <span class="p">{</span>
                    <span class="n">map</span><span class="nf">.entry</span><span class="p">(</span><span class="n">pos</span><span class="p">)</span><span class="nf">.or_insert</span><span class="p">(</span><span class="nn">Vec</span><span class="p">::</span><span class="nf">new</span><span class="p">())</span><span class="nf">.push</span><span class="p">(</span><span class="n">value</span><span class="p">);</span>
                    <span class="n">map</span>
                <span class="p">})</span>
        <span class="p">})</span>
        <span class="nf">.values</span><span class="p">()</span>
        <span class="nf">.filter</span><span class="p">(|</span><span class="n">values</span><span class="p">|</span> <span class="n">values</span><span class="nf">.len</span><span class="p">()</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span>
        <span class="nf">.map</span><span class="p">(|</span><span class="n">values</span><span class="p">|</span> <span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">values</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="nf">.sum</span><span class="p">()</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_tests_3">Tests</h3>
<div class="paragraph">
<p>As usual.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
</pre></td><td class="code"><pre><span class="nd">#[cfg(test)]</span>
<span class="k">mod</span> <span class="n">tests</span> <span class="p">{</span>
    <span class="k">use</span> <span class="k">super</span><span class="p">::</span><span class="o">*</span><span class="p">;</span>

    <span class="k">const</span> <span class="n">CONTENT</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span> <span class="o">=</span> <span class="s">r#"467..114..
...*......
..35..633.
......#...
617*......
.....+.58.
..592.....
......755.
...$.*....
.664.598..
"#</span><span class="p">;</span>

    <span class="k">const</span> <span class="n">WIDTH_0</span><span class="p">:</span> <span class="nb">usize</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
    <span class="k">const</span> <span class="n">HEIGHT_0</span><span class="p">:</span> <span class="nb">usize</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
    <span class="k">const</span> <span class="n">WIDTH_EXT</span><span class="p">:</span> <span class="nb">usize</span> <span class="o">=</span> <span class="n">WIDTH_0</span> <span class="o">+</span> <span class="mi">2</span><span class="p">;</span>
    <span class="k">const</span> <span class="n">HEIGHT_EXT</span><span class="p">:</span> <span class="nb">usize</span> <span class="o">=</span> <span class="n">HEIGHT_0</span> <span class="o">+</span> <span class="mi">2</span><span class="p">;</span>

    <span class="nd">#[test]</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">test_from</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">let</span> <span class="nf">PuzzleData</span><span class="p">(</span><span class="n">grid</span><span class="p">)</span> <span class="o">=</span> <span class="nn">PuzzleData</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="n">CONTENT</span><span class="p">);</span>
        <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">WIDTH_EXT</span><span class="p">,</span> <span class="n">grid</span><span class="nf">.width</span><span class="p">());</span>
        <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">HEIGHT_EXT</span><span class="p">,</span> <span class="n">grid</span><span class="nf">.height</span><span class="p">());</span>
    <span class="p">}</span>

    <span class="nd">#[test]</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">test_next_number</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">let</span> <span class="nf">PuzzleData</span><span class="p">(</span><span class="n">grid</span><span class="p">)</span> <span class="o">=</span> <span class="nn">PuzzleData</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="n">CONTENT</span><span class="p">);</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"{:?}"</span><span class="p">,</span> <span class="n">grid</span><span class="p">);</span>
        <span class="nd">assert_eq!</span><span class="p">(</span><span class="nf">Some</span><span class="p">((</span><span class="mi">467</span><span class="p">,</span> <span class="n">WIDTH_EXT</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)),</span> <span class="nf">next_number</span><span class="p">(</span><span class="o">&amp;</span><span class="n">grid</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>
        <span class="nd">assert_eq!</span><span class="p">(</span>
            <span class="nf">Some</span><span class="p">((</span><span class="mi">35</span><span class="p">,</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">WIDTH_EXT</span> <span class="o">+</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">)),</span>
            <span class="nf">next_number</span><span class="p">(</span><span class="o">&amp;</span><span class="n">grid</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">WIDTH_EXT</span><span class="p">)</span>
        <span class="p">);</span>
    <span class="p">}</span>

    <span class="nd">#[test]</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">test_star_1</span><span class="p">()</span> <span class="p">{</span>
        <span class="nd">assert_eq!</span><span class="p">(</span><span class="mi">4_361</span><span class="p">,</span> <span class="nf">star_1</span><span class="p">(</span><span class="o">&amp;</span><span class="n">CONTENT</span><span class="nf">.into</span><span class="p">()));</span>
    <span class="p">}</span>

    <span class="nd">#[test]</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">test_star_2</span><span class="p">()</span> <span class="p">{</span>
        <span class="nd">assert_eq!</span><span class="p">(</span><span class="mi">467_835</span><span class="p">,</span> <span class="nf">star_2</span><span class="p">(</span><span class="o">&amp;</span><span class="n">CONTENT</span><span class="nf">.into</span><span class="p">()));</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p><a href="#top">Top</a></p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="sol-rust-4">Rust | Day 4: Scratchcards</h2>
<div class="sectionbody">
<div class="paragraph">
<p><a href="https://rust-lang.org">Rust</a> solution to <a href="https://adventofcode.com/2023/day/4">AoC|2023|4</a>.</p>
</div>
<div class="sect2">
<h3 id="_input_4">Input</h3>
<div class="paragraph">
<p>Today, I directly operate on the input as <code>&amp;str</code>, no pre-processing.</p>
</div>
</div>
<div class="sect2">
<h3 id="_star_1_6">Star 1</h3>
<div class="paragraph">
<p>I build an iterator which yields for every line the number of items that appear in both lists on the scratch card using a hash set. Then I apply the scoring function to those numbers and take the sum:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre></td><td class="code"><pre><span class="k">pub</span> <span class="k">fn</span> <span class="nf">count_winners</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">impl</span> <span class="nb">Iterator</span><span class="o">&lt;</span><span class="n">Item</span> <span class="o">=</span> <span class="n">SolT</span><span class="o">&gt;</span> <span class="o">+</span> <span class="nv">'_</span> <span class="p">{</span>
    <span class="n">data</span><span class="nf">.lines</span><span class="p">()</span>
        <span class="nf">.map</span><span class="p">(|</span><span class="n">line</span><span class="p">|</span> <span class="p">{</span>
            <span class="n">line</span><span class="nf">.split_once</span><span class="p">(</span><span class="sc">':'</span><span class="p">)</span>
                <span class="nf">.and_then</span><span class="p">(|(</span><span class="n">_</span><span class="p">,</span> <span class="n">tail</span><span class="p">)|</span> <span class="n">tail</span><span class="nf">.split_once</span><span class="p">(</span><span class="sc">'|'</span><span class="p">))</span>
                <span class="nf">.unwrap</span><span class="p">()</span>
        <span class="p">})</span>
        <span class="nf">.map</span><span class="p">(|(</span><span class="n">lhs</span><span class="p">,</span> <span class="n">rhs</span><span class="p">)|</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">lhs</span> <span class="o">=</span> <span class="n">lhs</span><span class="nf">.split_ascii_whitespace</span><span class="p">()</span><span class="py">.collect</span><span class="p">::</span><span class="o">&lt;</span><span class="n">HashSet</span><span class="o">&lt;</span><span class="n">_</span><span class="o">&gt;&gt;</span><span class="p">();</span>
            <span class="n">rhs</span><span class="nf">.split_ascii_whitespace</span><span class="p">()</span>
                <span class="nf">.filter</span><span class="p">(|</span><span class="n">value</span><span class="p">|</span> <span class="n">lhs</span><span class="nf">.contains</span><span class="p">(</span><span class="n">value</span><span class="p">))</span>
                <span class="nf">.count</span><span class="p">()</span>
        <span class="p">})</span>
<span class="p">}</span>

<span class="k">pub</span> <span class="k">fn</span> <span class="nf">star_1</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">SolT</span> <span class="p">{</span>
    <span class="nf">count_winners</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="nf">.map</span><span class="p">(|</span><span class="n">c</span><span class="p">|</span> <span class="k">match</span> <span class="n">c</span> <span class="p">{</span>
            <span class="mi">0</span> <span class="k">=&gt;</span> <span class="mi">0</span><span class="p">,</span>
            <span class="n">n</span> <span class="k">=&gt;</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">),</span>
        <span class="p">})</span>
        <span class="nf">.sum</span><span class="p">()</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_star_2_6">Star 2</h3>
<div class="paragraph">
<p>I pass through all cards once to update the number of subsequent cards (in a nested fold). Since the outer fold does not know the total number of cards, I need to initialize enough counters with <code>1</code> (initially, every card is available once).</p>
</div>
<div class="paragraph">
<p>A key statement from the puzzle description for the algorithm to work is "Cards will never make you copy a card past the end of the table."</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
</pre></td><td class="code"><pre><span class="k">pub</span> <span class="k">fn</span> <span class="nf">star_2</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">SolT</span> <span class="p">{</span>
    <span class="nf">count_winners</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="nf">.enumerate</span><span class="p">()</span>
        <span class="nf">.fold</span><span class="p">(</span><span class="nd">vec!</span><span class="p">[],</span> <span class="p">|</span><span class="k">mut</span> <span class="n">counts</span><span class="p">,</span> <span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="n">wins</span><span class="p">)|</span> <span class="p">{</span>
            <span class="n">counts</span><span class="nf">.resize</span><span class="p">(</span><span class="n">counts</span><span class="nf">.len</span><span class="p">()</span><span class="nf">.max</span><span class="p">(</span><span class="n">pos</span> <span class="o">+</span> <span class="n">wins</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="mi">1</span><span class="p">);</span>
            <span class="p">(</span><span class="n">pos</span> <span class="o">+</span> <span class="mi">1</span><span class="o">..=</span><span class="n">pos</span> <span class="o">+</span> <span class="n">wins</span><span class="p">)</span><span class="nf">.fold</span><span class="p">(</span><span class="n">counts</span><span class="p">,</span> <span class="p">|</span><span class="k">mut</span> <span class="n">counts</span><span class="p">,</span> <span class="n">pos_upd</span><span class="p">|</span> <span class="p">{</span>
                <span class="n">counts</span><span class="p">[</span><span class="n">pos_upd</span><span class="p">]</span> <span class="o">+=</span> <span class="n">counts</span><span class="p">[</span><span class="n">pos</span><span class="p">];</span>
                <span class="n">counts</span>
            <span class="p">})</span>
        <span class="p">})</span>
        <span class="nf">.iter</span><span class="p">()</span>
        <span class="nf">.sum</span><span class="p">()</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_tests_4">Tests</h3>
<div class="paragraph">
<p>Nothing special here.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
</pre></td><td class="code"><pre><span class="nd">#[cfg(test)]</span>
<span class="k">mod</span> <span class="n">tests</span> <span class="p">{</span>
    <span class="k">use</span> <span class="k">super</span><span class="p">::</span><span class="o">*</span><span class="p">;</span>

    <span class="k">const</span> <span class="n">CONTENT</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span> <span class="o">=</span> <span class="s">r#"Card 1: 41 48 83 86 17 | 83 86  6 31 17  9 48 53
Card 2: 13 32 20 16 61 | 61 30 68 82 17 32 24 19
Card 3:  1 21 53 59 44 | 69 82 63 72 16 21 14  1
Card 4: 41 92 73 84 69 | 59 84 76 51 58  5 54 83
Card 5: 87 83 26 28 32 | 88 30 70 12 93 22 82 36
Card 6: 31 18 13 56 72 | 74 77 10 23 35 67 36 11
"#</span><span class="p">;</span>

    <span class="nd">#[test]</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">test_count_winners</span><span class="p">()</span> <span class="p">{</span>
        <span class="nd">assert_eq!</span><span class="p">(</span>
            <span class="nd">vec!</span><span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
            <span class="nf">count_winners</span><span class="p">(</span><span class="n">CONTENT</span><span class="p">)</span><span class="py">.collect</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="n">_</span><span class="o">&gt;&gt;</span><span class="p">()</span>
        <span class="p">);</span>
    <span class="p">}</span>

    <span class="nd">#[test]</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">test_star_1</span><span class="p">()</span> <span class="p">{</span>
        <span class="nd">assert_eq!</span><span class="p">(</span><span class="mi">13</span><span class="p">,</span> <span class="nf">star_1</span><span class="p">(</span><span class="n">CONTENT</span><span class="p">));</span>
    <span class="p">}</span>

    <span class="nd">#[test]</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">test_star_2</span><span class="p">()</span> <span class="p">{</span>
        <span class="nd">assert_eq!</span><span class="p">(</span><span class="mi">30</span><span class="p">,</span> <span class="nf">star_2</span><span class="p">(</span><span class="n">CONTENT</span><span class="p">));</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p><a href="#top">Top</a></p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="sol-rust-5">Rust | Day 5: If You Give A Seed A Fertilizer</h2>
<div class="sectionbody">
<div class="paragraph">
<p><a href="https://rust-lang.org">Rust</a> solution to <a href="https://adventofcode.com/2023/day/5">AoC|2023|5</a>.</p>
</div>
<div class="sect2">
<h3 id="_input_5">Input</h3>
<div class="paragraph">
<p>Again a day of quite complicated input parsing that might not be strictly necessary.</p>
</div>
<div class="paragraph">
<p>The parsed input is a struct with a field <code>seeds</code> representing the seeds to be planted and a field 'maps'. The latter is a hash map that maps a source item type (seed, soil, &#8230;&#8203;) to a target item type and the mapping that explains which type of target item type to use with each source item type.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
</pre></td><td class="code"><pre><span class="k">type</span> <span class="n">Map</span> <span class="o">=</span> <span class="p">(</span><span class="n">SolT</span><span class="p">,</span> <span class="n">SolT</span><span class="p">,</span> <span class="n">SolT</span><span class="p">);</span>

<span class="k">pub</span> <span class="k">mod</span> <span class="n">input</span> <span class="p">{</span>
    <span class="k">use</span> <span class="k">crate</span><span class="p">::</span><span class="o">*</span><span class="p">;</span>
    <span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">collections</span><span class="p">::</span><span class="n">HashMap</span><span class="p">;</span>

    <span class="nd">#[derive(Debug)]</span>
    <span class="k">pub</span> <span class="k">struct</span> <span class="n">PuzzleData</span> <span class="p">{</span>
        <span class="k">pub</span> <span class="n">seeds</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">SolT</span><span class="o">&gt;</span><span class="p">,</span>
        <span class="k">pub</span> <span class="n">maps</span><span class="p">:</span> <span class="n">HashMap</span><span class="o">&lt;</span><span class="nb">String</span><span class="p">,</span> <span class="p">(</span><span class="nb">String</span><span class="p">,</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">Map</span><span class="o">&gt;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="nf">parse_ranges</span><span class="p">(</span><span class="n">ranges</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Map</span> <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">numbers</span> <span class="o">=</span> <span class="n">ranges</span><span class="nf">.split_ascii_whitespace</span><span class="p">()</span><span class="nf">.map</span><span class="p">(|</span><span class="n">r</span><span class="p">|</span> <span class="n">r</span><span class="nf">.parse</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">());</span>
        <span class="p">(</span>
            <span class="n">numbers</span><span class="nf">.next</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">(),</span>
            <span class="n">numbers</span><span class="nf">.next</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">(),</span>
            <span class="n">numbers</span><span class="nf">.next</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">(),</span>
        <span class="p">)</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="nf">parse_group</span><span class="p">(</span><span class="n">group</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="p">(</span><span class="nb">String</span><span class="p">,</span> <span class="p">(</span><span class="nb">String</span><span class="p">,</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">Map</span><span class="o">&gt;</span><span class="p">))</span> <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">lines</span> <span class="o">=</span> <span class="n">group</span><span class="nf">.lines</span><span class="p">();</span>

        <span class="k">let</span> <span class="k">mut</span> <span class="n">header</span> <span class="o">=</span> <span class="n">lines</span><span class="nf">.next</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">()</span><span class="nf">.split</span><span class="p">(</span><span class="o">&amp;</span><span class="p">[</span><span class="sc">'-'</span><span class="p">,</span> <span class="sc">' '</span><span class="p">]);</span>
        <span class="k">let</span> <span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">destination</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">header</span><span class="nf">.next</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">()</span><span class="nf">.to_string</span><span class="p">(),</span>
            <span class="n">header</span><span class="nf">.nth</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="nf">.unwrap</span><span class="p">()</span><span class="nf">.to_string</span><span class="p">(),</span>
        <span class="p">);</span>

        <span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="p">(</span><span class="n">destination</span><span class="p">,</span> <span class="n">lines</span><span class="nf">.map</span><span class="p">(</span><span class="n">parse_ranges</span><span class="p">)</span><span class="nf">.collect</span><span class="p">()))</span>
    <span class="p">}</span>

    <span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="p">:</span> <span class="nb">AsRef</span><span class="o">&lt;</span><span class="nb">str</span><span class="o">&gt;&gt;</span> <span class="nb">From</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="k">for</span> <span class="n">PuzzleData</span> <span class="p">{</span>
        <span class="k">fn</span> <span class="nf">from</span><span class="p">(</span><span class="n">s</span><span class="p">:</span> <span class="n">T</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
            <span class="k">let</span> <span class="k">mut</span> <span class="n">groups</span> <span class="o">=</span> <span class="n">s</span><span class="nf">.as_ref</span><span class="p">()</span><span class="nf">.split</span><span class="p">(</span><span class="s">"</span><span class="se">\n\n</span><span class="s">"</span><span class="p">);</span>
            <span class="k">Self</span> <span class="p">{</span>
                <span class="n">seeds</span><span class="p">:</span> <span class="n">groups</span>
                    <span class="nf">.next</span><span class="p">()</span>
                    <span class="nf">.and_then</span><span class="p">(|</span><span class="n">group</span><span class="p">|</span> <span class="n">group</span><span class="nf">.strip_prefix</span><span class="p">(</span><span class="s">"seeds: "</span><span class="p">))</span>
                    <span class="nf">.and_then</span><span class="p">(|</span><span class="n">seeds</span><span class="p">|</span> <span class="p">{</span>
                        <span class="n">seeds</span>
                            <span class="nf">.split_ascii_whitespace</span><span class="p">()</span>
                            <span class="nf">.map</span><span class="p">(|</span><span class="n">seed</span><span class="p">|</span> <span class="n">seed</span><span class="nf">.parse</span><span class="p">())</span>
                            <span class="py">.collect</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">Result</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="n">_</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">_</span><span class="o">&gt;&gt;</span><span class="p">()</span>
                            <span class="nf">.ok</span><span class="p">()</span>
                    <span class="p">})</span>
                    <span class="nf">.unwrap</span><span class="p">(),</span>
                <span class="n">maps</span><span class="p">:</span> <span class="n">groups</span><span class="nf">.map</span><span class="p">(</span><span class="n">parse_group</span><span class="p">)</span><span class="nf">.collect</span><span class="p">(),</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_star_1_7">Star 1</h3>
<div class="paragraph">
<p>What you see here is my solution for star 1 refactored to be re-usable for star 2.</p>
</div>
<div class="paragraph">
<p>It consists of a generic function <code>star</code> that iterates through all mappings until an item type is reached that cannot be further mapped. It then contains the last element produced by the iteration (should be <code>"location"</code>) and extracts the minimum.</p>
</div>
<div class="paragraph">
<p>The initial value, the function to produce the next value and the function to extract the minimum are specific for <code>star_1</code> and <code>star_2</code> and passed as parameters.</p>
</div>
<div class="paragraph">
<p>The step function for <code>star_1</code> simply checks for every item whether it is contained in any of the mapping ranges. If so, the mapping is applied, otherwise, the unmodified item is returned.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
</pre></td><td class="code"><pre><span class="k">fn</span> <span class="n">star</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">M</span><span class="o">&gt;</span><span class="p">(</span>
    <span class="n">maps</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">HashMap</span><span class="o">&lt;</span><span class="nb">String</span><span class="p">,</span> <span class="p">(</span><span class="nb">String</span><span class="p">,</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">Map</span><span class="o">&gt;</span><span class="p">)</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="n">seeds</span><span class="p">:</span> <span class="n">T</span><span class="p">,</span>
    <span class="k">mut</span> <span class="n">step</span><span class="p">:</span> <span class="n">S</span><span class="p">,</span>
    <span class="k">mut</span> <span class="n">minimize</span><span class="p">:</span> <span class="n">M</span><span class="p">,</span>
<span class="p">)</span> <span class="k">-&gt;</span> <span class="n">SolT</span>
<span class="k">where</span>
    <span class="n">R</span><span class="p">:</span> <span class="o">?</span><span class="nb">Sized</span><span class="p">,</span>
    <span class="n">T</span><span class="p">:</span> <span class="nb">AsRef</span><span class="o">&lt;</span><span class="n">R</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="n">S</span><span class="p">:</span> <span class="nf">FnMut</span><span class="p">(</span><span class="o">&amp;</span><span class="n">R</span><span class="p">,</span> <span class="o">&amp;</span><span class="p">[</span><span class="n">Map</span><span class="p">])</span> <span class="k">-&gt;</span> <span class="n">T</span><span class="p">,</span>
    <span class="n">M</span><span class="p">:</span> <span class="nf">FnMut</span><span class="p">(</span><span class="n">T</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">SolT</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">{</span>
    <span class="nf">successors</span><span class="p">(</span><span class="nf">Some</span><span class="p">((</span><span class="s">"seed"</span><span class="p">,</span> <span class="n">seeds</span><span class="p">)),</span> <span class="p">|(</span><span class="n">src</span><span class="p">,</span> <span class="n">items</span><span class="p">)|</span> <span class="p">{</span>
        <span class="n">maps</span><span class="nf">.get</span><span class="p">(</span><span class="o">*</span><span class="n">src</span><span class="p">)</span>
            <span class="nf">.map</span><span class="p">(|(</span><span class="n">dst</span><span class="p">,</span> <span class="n">map</span><span class="p">)|</span> <span class="p">(</span><span class="n">dst</span><span class="nf">.as_str</span><span class="p">(),</span> <span class="nf">step</span><span class="p">(</span><span class="n">items</span><span class="nf">.as_ref</span><span class="p">(),</span> <span class="n">map</span><span class="p">)))</span>
    <span class="p">})</span>
    <span class="nf">.last</span><span class="p">()</span>
    <span class="nf">.and_then</span><span class="p">(|(</span><span class="n">_</span><span class="p">,</span> <span class="n">locations</span><span class="p">)|</span> <span class="nf">minimize</span><span class="p">(</span><span class="n">locations</span><span class="p">))</span>
    <span class="nf">.unwrap</span><span class="p">()</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">step_1</span><span class="p">(</span><span class="n">items</span><span class="p">:</span> <span class="o">&amp;</span><span class="p">[</span><span class="n">SolT</span><span class="p">],</span> <span class="n">map</span><span class="p">:</span> <span class="o">&amp;</span><span class="p">[</span><span class="n">Map</span><span class="p">])</span> <span class="k">-&gt;</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">i64</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="n">items</span>
        <span class="nf">.iter</span><span class="p">()</span>
        <span class="nf">.map</span><span class="p">(|</span><span class="o">&amp;</span><span class="n">item</span><span class="p">|</span> <span class="p">{</span>
            <span class="n">map</span><span class="nf">.iter</span><span class="p">()</span>
                <span class="nf">.find</span><span class="p">(|(</span><span class="n">_</span><span class="p">,</span> <span class="n">src_0</span><span class="p">,</span> <span class="n">len</span><span class="p">)|</span> <span class="p">(</span><span class="o">*</span><span class="n">src_0</span><span class="o">..*</span><span class="n">src_0</span> <span class="o">+</span> <span class="n">len</span><span class="p">)</span><span class="nf">.contains</span><span class="p">(</span><span class="o">&amp;</span><span class="n">item</span><span class="p">))</span>
                <span class="nf">.map</span><span class="p">(|(</span><span class="n">dst_0</span><span class="p">,</span> <span class="n">src_0</span><span class="p">,</span> <span class="n">_</span><span class="p">)|</span> <span class="n">item</span> <span class="o">+</span> <span class="n">dst_0</span> <span class="o">-</span> <span class="n">src_0</span><span class="p">)</span>
                <span class="nf">.unwrap_or</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
        <span class="p">})</span>
        <span class="nf">.collect</span><span class="p">()</span>
<span class="p">}</span>

<span class="k">pub</span> <span class="k">fn</span> <span class="nf">star_1</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">PuzzleData</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">SolT</span> <span class="p">{</span>
    <span class="nf">star</span><span class="p">(</span><span class="o">&amp;</span><span class="n">data</span><span class="py">.maps</span><span class="p">,</span> <span class="n">data</span><span class="py">.seeds</span><span class="nf">.clone</span><span class="p">(),</span> <span class="n">step_1</span><span class="p">,</span> <span class="p">|</span><span class="n">items</span><span class="p">|</span> <span class="p">{</span>
        <span class="n">items</span><span class="nf">.into_iter</span><span class="p">()</span><span class="nf">.min</span><span class="p">()</span>
    <span class="p">})</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_star_2_7">Star 2</h3>
<div class="paragraph">
<p>The general structure of the solution for <code>star_2</code> is the same as the structure for <code>star_1</code>.</p>
</div>
<div class="paragraph">
<p>The initial value is now ranges, i.e., we need to interpret two consecutive seed values as range start and range length.</p>
</div>
<div class="paragraph">
<p>The step function finds for every range an overlapping mapping. If there is one, we distinguish the cases when</p>
</div>
<div class="ulist">
<ul>
<li>
<p>the range is contained in the mapping; then the full range is transformed and added to the result</p>
</li>
<li>
<p>the range is not fully contained in the mapping but overlaps; then the part contained in the mapping is transformed and added to the result, the part not contained in the mapping is processed as additional range</p>
</li>
<li>
<p>the range is not overlapping with any mapping; then it is added to the result as is.</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
</pre></td><td class="code"><pre><span class="k">fn</span> <span class="nf">step_2</span><span class="p">(</span><span class="n">ranges</span><span class="p">:</span> <span class="o">&amp;</span><span class="p">[(</span><span class="n">SolT</span><span class="p">,</span> <span class="n">SolT</span><span class="p">)],</span> <span class="n">map</span><span class="p">:</span> <span class="o">&amp;</span><span class="p">[</span><span class="n">Map</span><span class="p">])</span> <span class="k">-&gt;</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="p">(</span><span class="n">SolT</span><span class="p">,</span> <span class="n">SolT</span><span class="p">)</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="n">ranges</span><span class="nf">.iter</span><span class="p">()</span><span class="nf">.fold</span><span class="p">(</span><span class="nn">Vec</span><span class="p">::</span><span class="nf">new</span><span class="p">(),</span> <span class="p">|</span><span class="k">mut</span> <span class="n">result</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rng</span><span class="p">|</span> <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">rng</span> <span class="o">=</span> <span class="nf">Some</span><span class="p">(</span><span class="n">rng</span><span class="p">);</span>
        <span class="k">while</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">((</span><span class="n">rng_0</span><span class="p">,</span> <span class="n">rng_n</span><span class="p">))</span> <span class="o">=</span> <span class="n">rng</span> <span class="p">{</span>
            <span class="c1">// find a map range that overlaps the current range</span>
            <span class="c1">// return the transformed contained part and optionally</span>
            <span class="c1">// a residual untransformed range</span>
            <span class="k">let</span> <span class="p">(</span><span class="n">transformed</span><span class="p">,</span> <span class="n">residual</span><span class="p">)</span> <span class="o">=</span> <span class="n">map</span>
                <span class="nf">.iter</span><span class="p">()</span>
                <span class="nf">.map</span><span class="p">(|</span><span class="o">&amp;</span><span class="p">(</span><span class="n">dst_0</span><span class="p">,</span> <span class="n">src_0</span><span class="p">,</span> <span class="n">len</span><span class="p">)|</span> <span class="p">(</span><span class="n">dst_0</span> <span class="o">-</span> <span class="n">src_0</span><span class="p">,</span> <span class="n">src_0</span><span class="p">,</span> <span class="n">src_0</span> <span class="o">+</span> <span class="n">len</span><span class="p">))</span>
                <span class="nf">.find</span><span class="p">(|</span><span class="o">&amp;</span><span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="n">src_0</span><span class="p">,</span> <span class="n">src_n</span><span class="p">)|</span> <span class="p">{</span>
                    <span class="p">(</span><span class="n">src_0</span><span class="o">..</span><span class="n">src_n</span><span class="p">)</span><span class="nf">.contains</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rng_0</span><span class="p">)</span> <span class="p">||</span> <span class="p">(</span><span class="n">src_0</span><span class="o">..</span><span class="n">src_n</span><span class="p">)</span><span class="nf">.contains</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">rng_n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
                <span class="p">})</span>
                <span class="nf">.map</span><span class="p">(|(</span><span class="n">dlt</span><span class="p">,</span> <span class="n">src_0</span><span class="p">,</span> <span class="n">src_n</span><span class="p">)|</span> <span class="p">{</span>
                    <span class="k">match</span> <span class="p">(</span>
                        <span class="p">(</span><span class="n">src_0</span><span class="o">..</span><span class="n">src_n</span><span class="p">)</span><span class="nf">.contains</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rng_0</span><span class="p">),</span>
                        <span class="p">(</span><span class="n">src_0</span><span class="o">..</span><span class="n">src_n</span><span class="p">)</span><span class="nf">.contains</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">rng_n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)),</span>
                    <span class="p">)</span> <span class="p">{</span>
                        <span class="p">(</span><span class="k">true</span><span class="p">,</span> <span class="k">false</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">((</span><span class="n">rng_0</span> <span class="o">+</span> <span class="n">dlt</span><span class="p">,</span> <span class="n">src_n</span> <span class="o">+</span> <span class="n">dlt</span><span class="p">),</span> <span class="nf">Some</span><span class="p">((</span><span class="n">src_n</span><span class="p">,</span> <span class="n">rng_n</span><span class="p">))),</span>
                        <span class="p">(</span><span class="k">false</span><span class="p">,</span> <span class="k">true</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">((</span><span class="n">src_0</span> <span class="o">+</span> <span class="n">dlt</span><span class="p">,</span> <span class="n">rng_n</span> <span class="o">+</span> <span class="n">dlt</span><span class="p">),</span> <span class="nf">Some</span><span class="p">((</span><span class="n">rng_0</span><span class="p">,</span> <span class="n">src_0</span><span class="p">))),</span>
                        <span class="n">_</span> <span class="k">=&gt;</span> <span class="p">((</span><span class="n">rng_0</span> <span class="o">+</span> <span class="n">dlt</span><span class="p">,</span> <span class="n">rng_n</span> <span class="o">+</span> <span class="n">dlt</span><span class="p">),</span> <span class="nb">None</span><span class="p">),</span>
                    <span class="p">}</span>
                <span class="p">})</span>
                <span class="nf">.unwrap_or</span><span class="p">(((</span><span class="n">rng_0</span><span class="p">,</span> <span class="n">rng_n</span><span class="p">),</span> <span class="nb">None</span><span class="p">));</span>

            <span class="n">result</span><span class="nf">.push</span><span class="p">(</span><span class="n">transformed</span><span class="p">);</span>
            <span class="n">rng</span> <span class="o">=</span> <span class="n">residual</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">result</span>
    <span class="p">})</span>
<span class="p">}</span>

<span class="k">pub</span> <span class="k">fn</span> <span class="nf">star_2</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">PuzzleData</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">SolT</span> <span class="p">{</span>
    <span class="nf">star</span><span class="p">(</span>
        <span class="o">&amp;</span><span class="n">data</span><span class="py">.maps</span><span class="p">,</span>
        <span class="n">data</span><span class="py">.seeds</span>
            <span class="nf">.iter</span><span class="p">()</span>
            <span class="nf">.step_by</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
            <span class="nf">.zip</span><span class="p">(</span><span class="n">data</span><span class="py">.seeds</span><span class="nf">.iter</span><span class="p">()</span><span class="nf">.skip</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="nf">.step_by</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
            <span class="nf">.map</span><span class="p">(|(</span><span class="o">&amp;</span><span class="n">from</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">len</span><span class="p">)|</span> <span class="p">(</span><span class="n">from</span><span class="p">,</span> <span class="n">from</span> <span class="o">+</span> <span class="n">len</span><span class="p">))</span>
            <span class="py">.collect</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="n">_</span><span class="o">&gt;&gt;</span><span class="p">(),</span>
        <span class="n">step_2</span><span class="p">,</span>
        <span class="p">|</span><span class="n">rng</span><span class="p">|</span> <span class="n">rng</span><span class="nf">.into_iter</span><span class="p">()</span><span class="nf">.map</span><span class="p">(|(</span><span class="n">start</span><span class="p">,</span> <span class="n">_</span><span class="p">)|</span> <span class="n">start</span><span class="p">)</span><span class="nf">.min</span><span class="p">(),</span>
    <span class="p">)</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_tests_5">Tests</h3>
<div class="paragraph">
<p>Tests are as usual.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
</pre></td><td class="code"><pre><span class="nd">#[cfg(test)]</span>
<span class="k">mod</span> <span class="n">tests</span> <span class="p">{</span>
    <span class="k">use</span> <span class="k">super</span><span class="p">::</span><span class="o">*</span><span class="p">;</span>

    <span class="k">const</span> <span class="n">CONTENT</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span> <span class="o">=</span> <span class="s">r#"seeds: 79 14 55 13

seed-to-soil map:
50 98 2
52 50 48

soil-to-fertilizer map:
0 15 37
37 52 2
39 0 15

fertilizer-to-water map:
49 53 8
0 11 42
42 0 7
57 7 4

water-to-light map:
88 18 7
18 25 70

light-to-temperature map:
45 77 23
81 45 19
68 64 13

temperature-to-humidity map:
0 69 1
1 0 69

humidity-to-location map:
60 56 37
56 93 4
"#</span><span class="p">;</span>

    <span class="nd">#[test]</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">test_from</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">data</span> <span class="o">=</span> <span class="nn">PuzzleData</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="n">CONTENT</span><span class="p">);</span>

        <span class="nd">println!</span><span class="p">(</span><span class="s">"{data:?}"</span><span class="p">);</span>

        <span class="c1">// check seeds</span>
        <span class="nd">assert_eq!</span><span class="p">(</span><span class="nd">vec!</span><span class="p">[</span><span class="mi">79</span><span class="p">,</span> <span class="mi">14</span><span class="p">,</span> <span class="mi">55</span><span class="p">,</span> <span class="mi">13</span><span class="p">],</span> <span class="n">data</span><span class="py">.seeds</span><span class="p">);</span>

        <span class="c1">// check that map finds way from seed to location</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">current</span> <span class="o">=</span> <span class="s">"seed"</span><span class="p">;</span>
        <span class="k">while</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">((</span><span class="n">next</span><span class="p">,</span> <span class="n">_</span><span class="p">))</span> <span class="o">=</span> <span class="n">data</span><span class="py">.maps</span><span class="nf">.get</span><span class="p">(</span><span class="n">current</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">current</span> <span class="o">=</span> <span class="n">next</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="nd">assert_eq!</span><span class="p">(</span><span class="s">"location"</span><span class="p">,</span> <span class="n">current</span><span class="p">);</span>

        <span class="c1">// check one map entry</span>
        <span class="nd">assert_eq!</span><span class="p">(</span>
            <span class="nf">Some</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="s">"light"</span><span class="nf">.to_string</span><span class="p">(),</span> <span class="nd">vec!</span><span class="p">[(</span><span class="mi">88</span><span class="p">,</span> <span class="mi">18</span><span class="p">,</span> <span class="mi">7</span><span class="p">),</span> <span class="p">(</span><span class="mi">18</span><span class="p">,</span> <span class="mi">25</span><span class="p">,</span> <span class="mi">70</span><span class="p">)])),</span>
            <span class="n">data</span><span class="py">.maps</span><span class="nf">.get</span><span class="p">(</span><span class="s">"water"</span><span class="p">)</span>
        <span class="p">);</span>
    <span class="p">}</span>

    <span class="nd">#[test]</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">test_star_1</span><span class="p">()</span> <span class="p">{</span>
        <span class="nd">assert_eq!</span><span class="p">(</span><span class="mi">35</span><span class="p">,</span> <span class="nf">star_1</span><span class="p">(</span><span class="o">&amp;</span><span class="n">CONTENT</span><span class="nf">.into</span><span class="p">()));</span>
    <span class="p">}</span>

    <span class="nd">#[test]</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">test_star_2</span><span class="p">()</span> <span class="p">{</span>
        <span class="nd">assert_eq!</span><span class="p">(</span><span class="mi">46</span><span class="p">,</span> <span class="nf">star_2</span><span class="p">(</span><span class="o">&amp;</span><span class="n">CONTENT</span><span class="nf">.into</span><span class="p">()));</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p><a href="#top">Top</a></p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="sol-rust-6">Rust | Day 6: Wait For It</h2>
<div class="sectionbody">
<div class="paragraph">
<p><a href="https://rust-lang.org">Rust</a> solution to <a href="https://adventofcode.com/2023/day/6">AoC|2023|6</a>.</p>
</div>
<div class="sect2">
<h3 id="_star_1_8">Star 1</h3>
<div class="paragraph">
<p>I went the obvious way and did a linear search for the first star.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
</pre></td><td class="code"><pre><span class="k">pub</span> <span class="k">fn</span> <span class="nf">play_naive</span><span class="p">((</span><span class="n">time</span><span class="p">,</span> <span class="n">dist</span><span class="p">):</span> <span class="p">(</span><span class="n">SolT</span><span class="p">,</span> <span class="n">SolT</span><span class="p">))</span> <span class="k">-&gt;</span> <span class="n">SolT</span> <span class="p">{</span>
    <span class="c1">// distance: (time - b) * b</span>
    <span class="p">(</span><span class="mi">0</span><span class="o">..=</span><span class="n">time</span><span class="p">)</span><span class="nf">.filter</span><span class="p">(|</span><span class="o">&amp;</span><span class="n">b</span><span class="p">|</span> <span class="p">(</span><span class="n">time</span> <span class="o">-</span> <span class="n">b</span><span class="p">)</span> <span class="o">*</span> <span class="n">b</span> <span class="o">&gt;</span> <span class="n">dist</span><span class="p">)</span><span class="nf">.count</span><span class="p">()</span> <span class="k">as</span> <span class="n">_</span>
<span class="p">}</span>

<span class="k">pub</span> <span class="k">fn</span> <span class="nf">star_1</span><span class="p">(</span><span class="n">s</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">SolT</span> <span class="p">{</span>
    <span class="nd">#[cfg(feature</span> <span class="nd">=</span> <span class="s">"play_math"</span><span class="nd">)]</span>
    <span class="k">const</span> <span class="n">PLAY</span><span class="p">:</span> <span class="k">fn</span><span class="p">((</span><span class="n">SolT</span><span class="p">,</span> <span class="n">SolT</span><span class="p">))</span> <span class="k">-&gt;</span> <span class="n">SolT</span> <span class="o">=</span> <span class="n">play_math</span><span class="p">;</span>
    <span class="nd">#[cfg(all(not(feature</span> <span class="nd">=</span> <span class="s">"play_math"</span><span class="nd">),</span> <span class="nd">not(feature</span> <span class="nd">=</span> <span class="s">"play_1_smart"</span><span class="nd">)))]</span>
    <span class="k">const</span> <span class="n">PLAY</span><span class="p">:</span> <span class="k">fn</span><span class="p">((</span><span class="n">SolT</span><span class="p">,</span> <span class="n">SolT</span><span class="p">))</span> <span class="k">-&gt;</span> <span class="n">SolT</span> <span class="o">=</span> <span class="n">play_naive</span><span class="p">;</span>
    <span class="nd">#[cfg(all(not(feature</span> <span class="nd">=</span> <span class="s">"play_math"</span><span class="nd">),</span> <span class="nd">feature</span> <span class="nd">=</span> <span class="s">"play_1_smart"</span><span class="nd">))]</span>
    <span class="k">const</span> <span class="n">PLAY</span><span class="p">:</span> <span class="k">fn</span><span class="p">((</span><span class="n">SolT</span><span class="p">,</span> <span class="n">SolT</span><span class="p">))</span> <span class="k">-&gt;</span> <span class="n">SolT</span> <span class="o">=</span> <span class="n">play_smart</span><span class="p">;</span>

    <span class="k">let</span> <span class="k">mut</span> <span class="n">lines</span> <span class="o">=</span> <span class="n">s</span><span class="nf">.lines</span><span class="p">()</span><span class="nf">.map</span><span class="p">(|</span><span class="n">line</span><span class="p">|</span> <span class="p">{</span>
        <span class="n">line</span><span class="nf">.split_ascii_whitespace</span><span class="p">()</span>
            <span class="nf">.skip</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
            <span class="nf">.map</span><span class="p">(|</span><span class="n">value</span><span class="p">|</span> <span class="n">value</span><span class="py">.parse</span><span class="p">::</span><span class="o">&lt;</span><span class="n">SolT</span><span class="o">&gt;</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">())</span>
    <span class="p">});</span>
    <span class="n">lines</span>
        <span class="nf">.next</span><span class="p">()</span>
        <span class="nf">.unwrap</span><span class="p">()</span>
        <span class="nf">.zip</span><span class="p">(</span><span class="n">lines</span><span class="nf">.next</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">())</span>
        <span class="nf">.map</span><span class="p">(</span><span class="n">PLAY</span><span class="p">)</span>
        <span class="nf">.product</span><span class="p">()</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_star_2_8">Star 2</h3>
<div class="paragraph">
<p>A smarter solution to the same problem: bisection (using the fact that the optimal button press time is known), of course solved with an iterator (who wants to see <code>while</code> loops)</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
</pre></td><td class="code"><pre><span class="k">fn</span> <span class="n">bisect</span><span class="o">&lt;</span><span class="n">F</span><span class="p">:</span> <span class="nf">Fn</span><span class="p">(</span><span class="n">SolT</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">bool</span><span class="o">&gt;</span><span class="p">(</span><span class="n">bs</span><span class="p">:</span> <span class="p">(</span><span class="n">SolT</span><span class="p">,</span> <span class="n">SolT</span><span class="p">),</span> <span class="n">test</span><span class="p">:</span> <span class="n">F</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="p">(</span><span class="n">SolT</span><span class="p">,</span> <span class="n">SolT</span><span class="p">)</span> <span class="p">{</span>
    <span class="nf">successors</span><span class="p">(</span><span class="nf">Some</span><span class="p">(</span><span class="n">bs</span><span class="p">),</span> <span class="p">|</span><span class="o">&amp;</span><span class="p">(</span><span class="n">b_l</span><span class="p">,</span> <span class="n">b_r</span><span class="p">)|</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">b</span> <span class="o">=</span> <span class="p">(</span><span class="n">b_l</span> <span class="o">+</span> <span class="n">b_r</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">;</span>
        <span class="k">if</span> <span class="nf">test</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="p">{</span>
            <span class="nf">Some</span><span class="p">((</span><span class="n">b_l</span><span class="p">,</span> <span class="n">b</span><span class="p">))</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="nf">Some</span><span class="p">((</span><span class="n">b</span><span class="p">,</span> <span class="n">b_r</span><span class="p">))</span>
        <span class="p">}</span>
    <span class="p">})</span>
    <span class="nf">.find</span><span class="p">(|(</span><span class="n">b_l</span><span class="p">,</span> <span class="n">b_r</span><span class="p">)|</span> <span class="n">b_r</span> <span class="o">-</span> <span class="n">b_l</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">)</span>
    <span class="nf">.unwrap</span><span class="p">()</span>
<span class="p">}</span>

<span class="k">pub</span> <span class="k">fn</span> <span class="nf">play_smart</span><span class="p">((</span><span class="n">time</span><span class="p">,</span> <span class="n">dist</span><span class="p">):</span> <span class="p">(</span><span class="n">SolT</span><span class="p">,</span> <span class="n">SolT</span><span class="p">))</span> <span class="k">-&gt;</span> <span class="n">SolT</span> <span class="p">{</span>
    <span class="c1">// distance: (time - b) * b</span>
    <span class="c1">// optimum: time - 2 b = 0 =&gt; (time - time &gt;&gt; 1) * (time &gt;&gt; 1)</span>
    <span class="k">let</span> <span class="n">b_opt</span> <span class="o">=</span> <span class="n">time</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">let</span> <span class="p">(</span><span class="n">b_l</span><span class="p">,</span> <span class="n">_</span><span class="p">)</span> <span class="o">=</span> <span class="nf">bisect</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="n">b_opt</span><span class="p">),</span> <span class="p">|</span><span class="n">b</span><span class="p">|</span> <span class="p">(</span><span class="n">time</span> <span class="o">-</span> <span class="n">b</span><span class="p">)</span> <span class="o">*</span> <span class="n">b</span> <span class="o">&gt;</span> <span class="n">dist</span><span class="p">);</span>
    <span class="k">let</span> <span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="n">b_r</span><span class="p">)</span> <span class="o">=</span> <span class="nf">bisect</span><span class="p">((</span><span class="n">b_opt</span><span class="p">,</span> <span class="n">time</span><span class="p">),</span> <span class="p">|</span><span class="n">b</span><span class="p">|</span> <span class="p">(</span><span class="n">time</span> <span class="o">-</span> <span class="n">b</span><span class="p">)</span> <span class="o">*</span> <span class="n">b</span> <span class="o">&lt;=</span> <span class="n">dist</span><span class="p">);</span>
    <span class="n">b_r</span> <span class="o">-</span> <span class="n">b_l</span> <span class="o">-</span> <span class="mi">1</span>
<span class="p">}</span>

<span class="k">pub</span> <span class="k">fn</span> <span class="nf">play_math</span><span class="p">((</span><span class="n">time</span><span class="p">,</span> <span class="n">dist</span><span class="p">):</span> <span class="p">(</span><span class="n">SolT</span><span class="p">,</span> <span class="n">SolT</span><span class="p">))</span> <span class="k">-&gt;</span> <span class="n">SolT</span> <span class="p">{</span>
    <span class="c1">// distance: (time - b) * b &gt; dist</span>
    <span class="c1">// b^2 - time * b + dist = 0</span>
    <span class="c1">// b = (time +/- sqrt(time^2 - 4 dist)) / 2</span>

    <span class="k">let</span> <span class="n">sqrt_d</span> <span class="o">=</span> <span class="p">((</span><span class="n">time</span> <span class="o">*</span> <span class="n">time</span> <span class="o">-</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">dist</span><span class="p">)</span> <span class="k">as</span> <span class="nb">f64</span><span class="p">)</span><span class="nf">.sqrt</span><span class="p">();</span>
    <span class="k">let</span> <span class="n">b1</span> <span class="o">=</span> <span class="p">(((</span><span class="n">time</span> <span class="k">as</span> <span class="nb">f64</span><span class="p">)</span> <span class="o">-</span> <span class="n">sqrt_d</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span><span class="p">)</span><span class="nf">.floor</span><span class="p">()</span> <span class="k">as</span> <span class="n">SolT</span><span class="p">;</span>
    <span class="k">let</span> <span class="n">b2</span> <span class="o">=</span> <span class="p">(((</span><span class="n">time</span> <span class="k">as</span> <span class="nb">f64</span><span class="p">)</span> <span class="o">+</span> <span class="n">sqrt_d</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.0</span><span class="p">)</span><span class="nf">.ceil</span><span class="p">()</span> <span class="k">as</span> <span class="n">SolT</span><span class="p">;</span>

    <span class="n">b2</span> <span class="o">-</span> <span class="n">b1</span> <span class="o">-</span> <span class="mi">1</span>
<span class="p">}</span>

<span class="k">pub</span> <span class="k">fn</span> <span class="nf">star_2</span><span class="p">(</span><span class="n">s</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">SolT</span> <span class="p">{</span>
    <span class="nd">#[cfg(feature</span> <span class="nd">=</span> <span class="s">"play_math"</span><span class="nd">)]</span>
    <span class="k">const</span> <span class="n">PLAY</span><span class="p">:</span> <span class="k">fn</span><span class="p">((</span><span class="n">SolT</span><span class="p">,</span> <span class="n">SolT</span><span class="p">))</span> <span class="k">-&gt;</span> <span class="n">SolT</span> <span class="o">=</span> <span class="n">play_math</span><span class="p">;</span>
    <span class="nd">#[cfg(all(not(feature</span> <span class="nd">=</span> <span class="s">"play_math"</span><span class="nd">),</span> <span class="nd">feature</span> <span class="nd">=</span> <span class="s">"play_2_naive"</span><span class="nd">))]</span>
    <span class="k">const</span> <span class="n">PLAY</span><span class="p">:</span> <span class="k">fn</span><span class="p">((</span><span class="n">SolT</span><span class="p">,</span> <span class="n">SolT</span><span class="p">))</span> <span class="k">-&gt;</span> <span class="n">SolT</span> <span class="o">=</span> <span class="n">play_naive</span><span class="p">;</span>
    <span class="nd">#[cfg(all(not(feature</span> <span class="nd">=</span> <span class="s">"play_math"</span><span class="nd">),</span> <span class="nd">not(feature</span> <span class="nd">=</span> <span class="s">"play_2_naive"</span><span class="nd">)))]</span>
    <span class="k">const</span> <span class="n">PLAY</span><span class="p">:</span> <span class="k">fn</span><span class="p">((</span><span class="n">SolT</span><span class="p">,</span> <span class="n">SolT</span><span class="p">))</span> <span class="k">-&gt;</span> <span class="n">SolT</span> <span class="o">=</span> <span class="n">play_smart</span><span class="p">;</span>

    <span class="k">let</span> <span class="k">mut</span> <span class="n">values</span> <span class="o">=</span> <span class="n">s</span><span class="nf">.lines</span><span class="p">()</span><span class="nf">.map</span><span class="p">(|</span><span class="n">line</span><span class="p">|</span> <span class="p">{</span>
        <span class="n">line</span><span class="nf">.bytes</span><span class="p">()</span>
            <span class="nf">.filter</span><span class="p">(</span><span class="nn">u8</span><span class="p">::</span><span class="n">is_ascii_digit</span><span class="p">)</span>
            <span class="nf">.fold</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="p">|</span><span class="n">val</span><span class="p">,</span> <span class="n">b</span><span class="p">|</span> <span class="mi">10</span> <span class="o">*</span> <span class="n">val</span> <span class="o">+</span> <span class="p">(</span><span class="n">b</span> <span class="o">-</span> <span class="sc">b'0'</span><span class="p">)</span> <span class="k">as</span> <span class="n">SolT</span><span class="p">)</span>
    <span class="p">});</span>
    <span class="nf">PLAY</span><span class="p">((</span><span class="n">values</span><span class="nf">.next</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">(),</span> <span class="n">values</span><span class="nf">.next</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">()))</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p>Later on, I realized that the second part is much more tractable than what I believed and the solution for part 1 is actually good enough. I created features to enable the following variants:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>cargo run --release --features play_1_smart</code> uses the solution for the second part also for the first part (and uses about the same time)</p>
</li>
<li>
<p><code>cargo run --release --features play_2_naive</code> uses the solution for the first part also for the second part (and still finishes in a couple of milliseconds)</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_benchmarks">Benchmarks</h3>
<div class="paragraph">
<p>And because I was curious on how the code really performs, I also created a <code>Criterion.rs</code> bench for the first time:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
</pre></td><td class="code"><pre><span class="k">use</span> <span class="nn">criterion</span><span class="p">::{</span><span class="n">black_box</span><span class="p">,</span> <span class="n">criterion_group</span><span class="p">,</span> <span class="n">criterion_main</span><span class="p">,</span> <span class="n">Criterion</span><span class="p">};</span>
<span class="k">use</span> <span class="nn">mr_kaffee_2023_06</span><span class="p">::</span><span class="o">*</span><span class="p">;</span>

<span class="k">pub</span> <span class="k">fn</span> <span class="nf">criterion_benchmark</span><span class="p">(</span><span class="n">c</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">Criterion</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">data</span> <span class="o">=</span> <span class="nf">parse_input</span><span class="p">();</span>
    <span class="n">c</span><span class="nf">.bench_function</span><span class="p">(</span><span class="s">"star_1"</span><span class="p">,</span> <span class="p">|</span><span class="n">b</span><span class="p">|</span> <span class="n">b</span><span class="nf">.iter</span><span class="p">(||</span> <span class="nf">star_1</span><span class="p">(</span><span class="nf">black_box</span><span class="p">(</span><span class="o">&amp;</span><span class="n">data</span><span class="p">))));</span>
    <span class="n">c</span><span class="nf">.bench_function</span><span class="p">(</span><span class="s">"star_2"</span><span class="p">,</span> <span class="p">|</span><span class="n">b</span><span class="p">|</span> <span class="n">b</span><span class="nf">.iter</span><span class="p">(||</span> <span class="nf">star_2</span><span class="p">(</span><span class="nf">black_box</span><span class="p">(</span><span class="o">&amp;</span><span class="n">data</span><span class="p">))));</span>
<span class="p">}</span>

<span class="nd">criterion_group!</span><span class="p">(</span><span class="n">benches</span><span class="p">,</span> <span class="n">criterion_benchmark</span><span class="p">);</span>
<span class="nd">criterion_main!</span><span class="p">(</span><span class="n">benches</span><span class="p">);</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_tests_6">Tests</h3>
<div class="paragraph">
<p>Not worth mentioning</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
</pre></td><td class="code"><pre><span class="nd">#[cfg(test)]</span>
<span class="k">mod</span> <span class="n">tests</span> <span class="p">{</span>
    <span class="k">use</span> <span class="k">super</span><span class="p">::</span><span class="o">*</span><span class="p">;</span>

    <span class="k">const</span> <span class="n">CONTENT</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span> <span class="o">=</span> <span class="s">r#"Time:      7  15   30
Distance:  9  40  200
"#</span><span class="p">;</span>

    <span class="nd">#[test]</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">test_star_1</span><span class="p">()</span> <span class="p">{</span>
        <span class="nd">assert_eq!</span><span class="p">(</span><span class="mi">288</span><span class="p">,</span> <span class="nf">star_1</span><span class="p">(</span><span class="o">&amp;</span><span class="n">CONTENT</span><span class="p">));</span>
    <span class="p">}</span>

    <span class="nd">#[test]</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">test_star_2</span><span class="p">()</span> <span class="p">{</span>
        <span class="nd">assert_eq!</span><span class="p">(</span><span class="mi">71_503</span><span class="p">,</span> <span class="nf">star_2</span><span class="p">(</span><span class="o">&amp;</span><span class="n">CONTENT</span><span class="p">));</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p><a href="#top">Top</a></p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="sol-rust-7">Rust | Day 7: Camel Cards</h2>
<div class="sectionbody">
<div class="paragraph">
<p><a href="https://rust-lang.org">Rust</a> solution to <a href="https://adventofcode.com/2023/day/7">AoC|2023|7</a>.</p>
</div>
<div class="paragraph">
<p>I still prefer <a href="https://adventofcode.com/2019/day/22">Space Cards</a> over Camel Cards ;)</p>
</div>
<div class="sect2">
<h3 id="_input_6">Input</h3>
<div class="paragraph">
<p>The input is a vector of pairs of cards (as byte array) and bids.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
</pre></td><td class="code"><pre><span class="k">mod</span> <span class="n">input</span> <span class="p">{</span>
    <span class="k">use</span> <span class="k">crate</span><span class="p">::</span><span class="n">SolT</span><span class="p">;</span>

    <span class="nd">#[derive(Debug,</span> <span class="nd">PartialEq,</span> <span class="nd">Eq)]</span>
    <span class="k">pub</span> <span class="k">struct</span> <span class="nf">PuzzleData</span><span class="p">(</span><span class="k">pub</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="p">([</span><span class="nb">u8</span><span class="p">;</span> <span class="mi">5</span><span class="p">],</span> <span class="n">SolT</span><span class="p">)</span><span class="o">&gt;</span><span class="p">);</span>

    <span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="p">:</span> <span class="nb">AsRef</span><span class="o">&lt;</span><span class="nb">str</span><span class="o">&gt;&gt;</span> <span class="nb">From</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="k">for</span> <span class="n">PuzzleData</span> <span class="p">{</span>
        <span class="k">fn</span> <span class="nf">from</span><span class="p">(</span><span class="n">value</span><span class="p">:</span> <span class="n">T</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
            <span class="k">Self</span><span class="p">(</span>
                <span class="n">value</span>
                    <span class="nf">.as_ref</span><span class="p">()</span>
                    <span class="nf">.lines</span><span class="p">()</span>
                    <span class="nf">.filter_map</span><span class="p">(|</span><span class="n">line</span><span class="p">|</span> <span class="n">line</span><span class="nf">.split_once</span><span class="p">(</span><span class="sc">' '</span><span class="p">))</span>
                    <span class="nf">.map</span><span class="p">(|(</span><span class="n">cards</span><span class="p">,</span> <span class="n">bid</span><span class="p">)|</span> <span class="p">{</span>
                        <span class="p">(</span>
                            <span class="n">cards</span><span class="nf">.bytes</span><span class="p">()</span><span class="nf">.take</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span><span class="nf">.enumerate</span><span class="p">()</span><span class="nf">.fold</span><span class="p">(</span>
                                <span class="p">[</span><span class="mi">0</span><span class="p">;</span> <span class="mi">5</span><span class="p">],</span>
                                <span class="p">|</span><span class="k">mut</span> <span class="n">cards</span><span class="p">,</span> <span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="n">card</span><span class="p">)|</span> <span class="p">{</span>
                                    <span class="n">cards</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span> <span class="o">=</span> <span class="n">card</span><span class="p">;</span>
                                    <span class="n">cards</span>
                                <span class="p">},</span>
                            <span class="p">),</span>
                            <span class="n">bid</span><span class="nf">.parse</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">(),</span>
                        <span class="p">)</span>
                    <span class="p">})</span>
                    <span class="nf">.collect</span><span class="p">(),</span>
            <span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_star_1_9">Star 1</h3>
<div class="paragraph">
<p>I refactored my solution a bit to be usable for both parts. The <code>joker</code> parameter that appears as argument in some of the functions is set to false for the first part.</p>
</div>
<div class="paragraph">
<p>The idea is to put the hands in a format so that we can sort a vector of hands to get them sorted by rank. This is achieved by representing hands as a pair of a hand type and a cards array.</p>
</div>
<div class="paragraph">
<p>In the cards array, I cannot use the raw bytes, since that would result in a wrong lexicographically ordering. So I map the raw bytes to an ordinal value using <code>map_cards</code>.</p>
</div>
<div class="paragraph">
<p>The most tricky part is to determine the type of the hand. The algorithm (implemented in <code>HandType::from(&amp;[u8; 5])</code>) is as follows: count the number of occurrences for every card type in a hand (into an array), extract the two biggest numbers (neglecting the card type) and choose the hand based on those (for part 1, the number of jokers is always 0).</p>
</div>
<div class="paragraph">
<p>With this, we can sort the hands by rank and calculate the score with a <code>fold</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
</pre></td><td class="code"><pre><span class="k">pub</span> <span class="k">fn</span> <span class="nf">map_cards</span><span class="p">(</span><span class="n">cards</span><span class="p">:</span> <span class="o">&amp;</span><span class="p">[</span><span class="nb">u8</span><span class="p">;</span> <span class="mi">5</span><span class="p">],</span> <span class="n">joker</span><span class="p">:</span> <span class="nb">bool</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="p">[</span><span class="nb">u8</span><span class="p">;</span> <span class="mi">5</span><span class="p">]</span> <span class="p">{</span>
    <span class="n">cards</span><span class="nf">.map</span><span class="p">(|</span><span class="n">b</span><span class="p">|</span> <span class="k">match</span> <span class="n">b</span> <span class="p">{</span>
        <span class="sc">b'A'</span> <span class="k">=&gt;</span> <span class="mi">14</span><span class="p">,</span>
        <span class="sc">b'K'</span> <span class="k">=&gt;</span> <span class="mi">13</span><span class="p">,</span>
        <span class="sc">b'Q'</span> <span class="k">=&gt;</span> <span class="mi">12</span><span class="p">,</span>
        <span class="sc">b'J'</span> <span class="k">if</span> <span class="n">joker</span> <span class="k">=&gt;</span> <span class="mi">0</span><span class="p">,</span>
        <span class="sc">b'J'</span> <span class="k">=&gt;</span> <span class="mi">11</span><span class="p">,</span>
        <span class="sc">b'T'</span> <span class="k">=&gt;</span> <span class="mi">10</span><span class="p">,</span>
        <span class="n">b</span> <span class="k">=&gt;</span> <span class="n">b</span> <span class="o">-</span> <span class="sc">b'0'</span><span class="p">,</span>
    <span class="p">})</span>
<span class="p">}</span>

<span class="nd">#[derive(Debug,</span> <span class="nd">PartialEq,</span> <span class="nd">Eq,</span> <span class="nd">PartialOrd,</span> <span class="nd">Ord,</span> <span class="nd">Clone,</span> <span class="nd">Copy)]</span>
<span class="k">pub</span> <span class="k">enum</span> <span class="n">HandType</span> <span class="p">{</span>
    <span class="n">HighCard</span><span class="p">,</span>
    <span class="n">OnePair</span><span class="p">,</span>
    <span class="n">TwoPair</span><span class="p">,</span>
    <span class="n">ThreeOfAKind</span><span class="p">,</span>
    <span class="n">FullHouse</span><span class="p">,</span>
    <span class="n">FourOfAKind</span><span class="p">,</span>
    <span class="n">FiveOfAKind</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="nb">From</span><span class="o">&lt;&amp;</span><span class="p">[</span><span class="nb">u8</span><span class="p">;</span> <span class="mi">5</span><span class="p">]</span><span class="o">&gt;</span> <span class="k">for</span> <span class="n">HandType</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">from</span><span class="p">(</span><span class="n">cards</span><span class="p">:</span> <span class="o">&amp;</span><span class="p">[</span><span class="nb">u8</span><span class="p">;</span> <span class="mi">5</span><span class="p">])</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">map</span> <span class="o">=</span> <span class="n">cards</span><span class="nf">.iter</span><span class="p">()</span><span class="nf">.fold</span><span class="p">([</span><span class="mi">0</span><span class="p">;</span> <span class="mi">15</span><span class="p">],</span> <span class="p">|</span><span class="k">mut</span> <span class="n">map</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">card</span><span class="p">|</span> <span class="p">{</span>
            <span class="n">map</span><span class="p">[</span><span class="n">card</span> <span class="k">as</span> <span class="nb">usize</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
            <span class="n">map</span>
        <span class="p">});</span>

        <span class="k">let</span> <span class="n">jokers</span> <span class="o">=</span> <span class="n">map</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
        <span class="k">let</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="o">=</span> <span class="n">map</span><span class="p">[</span><span class="mi">2</span><span class="o">..</span><span class="p">]</span>
            <span class="nf">.iter</span><span class="p">()</span>
            <span class="nf">.fold</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">|(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">v</span><span class="p">|</span> <span class="k">match</span> <span class="p">(</span><span class="n">v</span> <span class="o">&gt;</span> <span class="n">a</span><span class="p">,</span> <span class="n">v</span> <span class="o">&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
                <span class="p">(</span><span class="k">true</span><span class="p">,</span> <span class="n">_</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">a</span><span class="p">),</span>
                <span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="k">true</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">v</span><span class="p">),</span>
                <span class="n">_</span> <span class="k">=&gt;</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">),</span>
            <span class="p">});</span>

        <span class="k">match</span> <span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="n">jokers</span><span class="p">,</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span> <span class="o">+</span> <span class="n">jokers</span><span class="p">)</span> <span class="p">{</span>
            <span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="n">_</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="k">Self</span><span class="p">::</span><span class="n">FiveOfAKind</span><span class="p">,</span>
            <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="n">_</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="k">Self</span><span class="p">::</span><span class="n">FourOfAKind</span><span class="p">,</span>
            <span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="k">Self</span><span class="p">::</span><span class="n">FullHouse</span><span class="p">,</span>
            <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">_</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="k">Self</span><span class="p">::</span><span class="n">ThreeOfAKind</span><span class="p">,</span>
            <span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="k">Self</span><span class="p">::</span><span class="n">TwoPair</span><span class="p">,</span>
            <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">_</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="k">Self</span><span class="p">::</span><span class="n">OnePair</span><span class="p">,</span>
            <span class="n">_</span> <span class="k">=&gt;</span> <span class="k">Self</span><span class="p">::</span><span class="n">HighCard</span><span class="p">,</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">pub</span> <span class="k">fn</span> <span class="nf">star</span><span class="p">(</span><span class="nf">PuzzleData</span><span class="p">(</span><span class="n">input</span><span class="p">):</span> <span class="o">&amp;</span><span class="n">PuzzleData</span><span class="p">,</span> <span class="n">joker</span><span class="p">:</span> <span class="nb">bool</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">SolT</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">hands</span> <span class="o">=</span> <span class="n">input</span>
        <span class="nf">.iter</span><span class="p">()</span>
        <span class="nf">.map</span><span class="p">(|(</span><span class="n">cards</span><span class="p">,</span> <span class="n">bid</span><span class="p">)|</span> <span class="p">(</span><span class="nf">map_cards</span><span class="p">(</span><span class="n">cards</span><span class="p">,</span> <span class="n">joker</span><span class="p">),</span> <span class="o">*</span><span class="n">bid</span><span class="p">))</span>
        <span class="nf">.map</span><span class="p">(|(</span><span class="n">cards</span><span class="p">,</span> <span class="n">bid</span><span class="p">)|</span> <span class="p">((</span><span class="nn">HandType</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cards</span><span class="p">),</span> <span class="n">cards</span><span class="p">),</span> <span class="n">bid</span><span class="p">))</span>
        <span class="py">.collect</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="n">_</span><span class="o">&gt;&gt;</span><span class="p">();</span>

    <span class="n">hands</span><span class="nf">.sort_unstable</span><span class="p">();</span>

    <span class="n">hands</span>
        <span class="nf">.iter</span><span class="p">()</span>
        <span class="nf">.enumerate</span><span class="p">()</span>
        <span class="nf">.map</span><span class="p">(|(</span><span class="n">pos</span><span class="p">,</span> <span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="n">bid</span><span class="p">))|</span> <span class="p">(</span><span class="n">pos</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">bid</span><span class="p">)</span>
        <span class="nf">.sum</span><span class="p">()</span>
<span class="p">}</span>

<span class="k">pub</span> <span class="k">fn</span> <span class="nf">star_1</span><span class="p">(</span><span class="n">input</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">PuzzleData</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">SolT</span> <span class="p">{</span>
    <span class="nf">star</span><span class="p">(</span><span class="n">input</span><span class="p">,</span> <span class="k">false</span><span class="p">)</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_star_2_9">Star 2</h3>
<div class="paragraph">
<p>In the second part, the symbol <code>J</code> no longer signifies a Jack but a Joker that can stand in for any card but has a lower ordinal number than any other card. This is implemented in <code>map_cards</code> in the line <code>b&#8217;J' if joker &#8658; 0</code> and with the guard conditions in the <code>match</code> statement in <code>HandType::from(&amp;[u8; 5])</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno">1
2
3
</pre></td><td class="code"><pre><span class="k">pub</span> <span class="k">fn</span> <span class="nf">star_2</span><span class="p">(</span><span class="n">input</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">PuzzleData</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">SolT</span> <span class="p">{</span>
    <span class="nf">star</span><span class="p">(</span><span class="n">input</span><span class="p">,</span> <span class="k">true</span><span class="p">)</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_tests_7">Tests</h3>
<div class="paragraph">
<p>One special test today verifies that a hand does not get worse with jokers (on the actual input data)</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
</pre></td><td class="code"><pre><span class="nd">#[cfg(test)]</span>
<span class="k">mod</span> <span class="n">tests</span> <span class="p">{</span>
    <span class="k">use</span> <span class="k">super</span><span class="p">::</span><span class="o">*</span><span class="p">;</span>

    <span class="k">const</span> <span class="n">CONTENT</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span> <span class="o">=</span> <span class="s">r#"32T3K 765
T55J5 684
KK677 28
KTJJT 220
QQQJA 483
"#</span><span class="p">;</span>

    <span class="nd">#[test]</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">test_input_from</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">data</span> <span class="o">=</span> <span class="nn">PuzzleData</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="n">CONTENT</span><span class="p">);</span>
        <span class="nd">assert_eq!</span><span class="p">(</span>
            <span class="nf">PuzzleData</span><span class="p">(</span><span class="nd">vec!</span><span class="p">[</span>
                <span class="p">([</span><span class="sc">b'3'</span><span class="p">,</span> <span class="sc">b'2'</span><span class="p">,</span> <span class="sc">b'T'</span><span class="p">,</span> <span class="sc">b'3'</span><span class="p">,</span> <span class="sc">b'K'</span><span class="p">],</span> <span class="mi">765</span><span class="p">),</span>
                <span class="p">([</span><span class="sc">b'T'</span><span class="p">,</span> <span class="sc">b'5'</span><span class="p">,</span> <span class="sc">b'5'</span><span class="p">,</span> <span class="sc">b'J'</span><span class="p">,</span> <span class="sc">b'5'</span><span class="p">],</span> <span class="mi">684</span><span class="p">),</span>
                <span class="p">([</span><span class="sc">b'K'</span><span class="p">,</span> <span class="sc">b'K'</span><span class="p">,</span> <span class="sc">b'6'</span><span class="p">,</span> <span class="sc">b'7'</span><span class="p">,</span> <span class="sc">b'7'</span><span class="p">],</span> <span class="mi">28</span><span class="p">),</span>
                <span class="p">([</span><span class="sc">b'K'</span><span class="p">,</span> <span class="sc">b'T'</span><span class="p">,</span> <span class="sc">b'J'</span><span class="p">,</span> <span class="sc">b'J'</span><span class="p">,</span> <span class="sc">b'T'</span><span class="p">],</span> <span class="mi">220</span><span class="p">),</span>
                <span class="p">([</span><span class="sc">b'Q'</span><span class="p">,</span> <span class="sc">b'Q'</span><span class="p">,</span> <span class="sc">b'Q'</span><span class="p">,</span> <span class="sc">b'J'</span><span class="p">,</span> <span class="sc">b'A'</span><span class="p">],</span> <span class="mi">483</span><span class="p">)</span>
            <span class="p">]),</span>
            <span class="n">data</span>
        <span class="p">);</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"{data:?}"</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="nd">#[test]</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">test_star_1</span><span class="p">()</span> <span class="p">{</span>
        <span class="nd">assert_eq!</span><span class="p">(</span><span class="mi">6440</span><span class="p">,</span> <span class="nf">star_1</span><span class="p">(</span><span class="o">&amp;</span><span class="n">CONTENT</span><span class="nf">.into</span><span class="p">()));</span>
    <span class="p">}</span>

    <span class="nd">#[test]</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">test_star_2</span><span class="p">()</span> <span class="p">{</span>
        <span class="nd">assert_eq!</span><span class="p">(</span><span class="mi">5905</span><span class="p">,</span> <span class="nf">star_2</span><span class="p">(</span><span class="o">&amp;</span><span class="n">CONTENT</span><span class="nf">.into</span><span class="p">()));</span>
    <span class="p">}</span>

    <span class="nd">#[test]</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">test_joker</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">let</span> <span class="nf">PuzzleData</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">=</span> <span class="nf">parse_input</span><span class="p">();</span>

        <span class="k">for</span> <span class="p">(</span><span class="n">cards</span><span class="p">,</span> <span class="n">_</span><span class="p">)</span> <span class="k">in</span> <span class="n">data</span><span class="nf">.iter</span><span class="p">()</span> <span class="p">{</span>
            <span class="nd">assert!</span><span class="p">(</span>
                <span class="nn">HandType</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="o">&amp;</span><span class="nf">map_cards</span><span class="p">(</span><span class="n">cards</span><span class="p">,</span> <span class="kc">true</span><span class="p">))</span> <span class="o">&gt;=</span> <span class="nn">HandType</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="o">&amp;</span><span class="nf">map_cards</span><span class="p">(</span><span class="n">cards</span><span class="p">,</span> <span class="kc">false</span><span class="p">)),</span>
                <span class="s">"Hand got worse with jokers: {:?}"</span><span class="p">,</span>
                <span class="n">cards</span>
            <span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p><a href="#top">Top</a></p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="sol-rust-8">Rust | Day 8: Haunted Wasteland</h2>
<div class="sectionbody">
<div class="paragraph">
<p><a href="https://rust-lang.org">Rust</a> solution to <a href="https://adventofcode.com/2023/day/8">AoC|2023|8</a>.</p>
</div>
<div class="sect2">
<h3 id="_input_7">Input</h3>
<div class="paragraph">
<p>The input is parsed into a tuple of a byte array representing directions and a hash map representing the map.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
</pre></td><td class="code"><pre><span class="k">pub</span> <span class="k">mod</span> <span class="n">input</span> <span class="p">{</span>
    <span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">collections</span><span class="p">::</span><span class="n">HashMap</span><span class="p">;</span>

    <span class="nd">#[derive(Debug,</span> <span class="nd">PartialEq,</span> <span class="nd">Eq)]</span>
    <span class="k">pub</span> <span class="k">struct</span> <span class="n">PuzzleData</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span><span class="p">(</span><span class="k">pub</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="p">[</span><span class="nb">u8</span><span class="p">],</span> <span class="k">pub</span> <span class="n">HashMap</span><span class="o">&lt;&amp;</span><span class="nv">'a</span> <span class="nb">str</span><span class="p">,</span> <span class="p">(</span><span class="o">&amp;</span><span class="nv">'a</span> <span class="nb">str</span><span class="p">,</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="nb">str</span><span class="p">)</span><span class="o">&gt;</span><span class="p">);</span>

    <span class="k">impl</span><span class="o">&lt;</span><span class="nv">'a</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="nb">From</span><span class="o">&lt;&amp;</span><span class="nv">'a</span> <span class="n">T</span><span class="o">&gt;</span> <span class="k">for</span> <span class="n">PuzzleData</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span>
    <span class="k">where</span>
        <span class="n">T</span><span class="p">:</span> <span class="nb">AsRef</span><span class="o">&lt;</span><span class="nb">str</span><span class="o">&gt;</span> <span class="o">+</span> <span class="nv">'a</span> <span class="o">+</span> <span class="o">?</span><span class="nb">Sized</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="k">fn</span> <span class="nf">from</span><span class="p">(</span><span class="n">s</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="n">T</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
            <span class="k">let</span> <span class="k">mut</span> <span class="n">lines</span> <span class="o">=</span> <span class="n">s</span><span class="nf">.as_ref</span><span class="p">()</span><span class="nf">.lines</span><span class="p">();</span>

            <span class="k">let</span> <span class="n">dirs</span> <span class="o">=</span> <span class="n">lines</span><span class="nf">.next</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">()</span><span class="nf">.as_bytes</span><span class="p">();</span>
            <span class="k">let</span> <span class="n">map</span> <span class="o">=</span> <span class="n">lines</span>
                <span class="nf">.skip</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
                <span class="nf">.filter_map</span><span class="p">(|</span><span class="n">line</span><span class="p">|</span> <span class="n">line</span><span class="nf">.split_once</span><span class="p">(</span><span class="s">" = "</span><span class="p">))</span>
                <span class="nf">.map</span><span class="p">(|(</span><span class="n">key</span><span class="p">,</span> <span class="n">values</span><span class="p">)|</span> <span class="p">{</span>
                    <span class="p">(</span>
                        <span class="n">key</span><span class="p">,</span>
                        <span class="n">values</span>
                            <span class="nf">.strip_prefix</span><span class="p">(</span><span class="sc">'('</span><span class="p">)</span>
                            <span class="nf">.and_then</span><span class="p">(|</span><span class="n">values</span><span class="p">|</span> <span class="n">values</span><span class="nf">.strip_suffix</span><span class="p">(</span><span class="sc">')'</span><span class="p">))</span>
                            <span class="nf">.and_then</span><span class="p">(|</span><span class="n">values</span><span class="p">|</span> <span class="n">values</span><span class="nf">.split_once</span><span class="p">(</span><span class="s">", "</span><span class="p">))</span>
                            <span class="nf">.unwrap</span><span class="p">(),</span>
                    <span class="p">)</span>
                <span class="p">})</span>
                <span class="nf">.collect</span><span class="p">();</span>
            <span class="k">Self</span><span class="p">(</span><span class="n">dirs</span><span class="p">,</span> <span class="n">map</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_star_1_10">Star 1</h3>
<div class="paragraph">
<p>The iterator returned by <code>map_iter</code> navigates the map step by step. The solution just iterates until <code>ZZZ</code> is reached.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
</pre></td><td class="code"><pre><span class="k">pub</span> <span class="k">fn</span> <span class="n">map_iter</span><span class="o">&lt;</span><span class="nv">'a</span><span class="o">&gt;</span><span class="p">(</span>
    <span class="n">dirs</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="p">[</span><span class="nb">u8</span><span class="p">],</span>
    <span class="n">map</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="n">HashMap</span><span class="o">&lt;&amp;</span><span class="nv">'a</span> <span class="nb">str</span><span class="p">,</span> <span class="p">(</span><span class="o">&amp;</span><span class="nv">'a</span> <span class="nb">str</span><span class="p">,</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="nb">str</span><span class="p">)</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="n">node</span><span class="p">:</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="nb">str</span><span class="p">,</span>
<span class="p">)</span> <span class="k">-&gt;</span> <span class="k">impl</span> <span class="nb">Iterator</span><span class="o">&lt;</span><span class="n">Item</span> <span class="o">=</span> <span class="p">(</span><span class="nb">usize</span><span class="p">,</span> <span class="o">&amp;</span><span class="nv">'a</span> <span class="nb">str</span><span class="p">)</span><span class="o">&gt;</span> <span class="o">+</span> <span class="nv">'a</span> <span class="p">{</span>
    <span class="nf">successors</span><span class="p">(</span><span class="nf">Some</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="n">node</span><span class="p">)),</span> <span class="p">|</span><span class="o">&amp;</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">node</span><span class="p">)|</span> <span class="p">{</span>
        <span class="n">map</span><span class="nf">.get</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
            <span class="nf">.map</span><span class="p">(|</span><span class="o">&amp;</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">)|</span> <span class="k">match</span> <span class="n">dirs</span><span class="p">[</span><span class="n">k</span> <span class="o">%</span> <span class="n">dirs</span><span class="nf">.len</span><span class="p">()]</span> <span class="p">{</span>
                <span class="sc">b'L'</span> <span class="k">=&gt;</span> <span class="p">(</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">left</span><span class="p">),</span>
                <span class="n">_</span> <span class="k">=&gt;</span> <span class="p">(</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">right</span><span class="p">),</span>
            <span class="p">})</span>
    <span class="p">})</span>
<span class="p">}</span>

<span class="k">pub</span> <span class="k">fn</span> <span class="nf">star_1</span><span class="p">(</span><span class="nf">PuzzleData</span><span class="p">(</span><span class="n">dirs</span><span class="p">,</span> <span class="n">map</span><span class="p">):</span> <span class="o">&amp;</span><span class="n">PuzzleData</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">SolT</span> <span class="p">{</span>
    <span class="nf">map_iter</span><span class="p">(</span><span class="n">dirs</span><span class="p">,</span> <span class="n">map</span><span class="p">,</span> <span class="s">"AAA"</span><span class="p">)</span>
        <span class="nf">.find</span><span class="p">(|</span><span class="o">&amp;</span><span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="n">node</span><span class="p">)|</span> <span class="n">node</span> <span class="o">==</span> <span class="s">"ZZZ"</span><span class="p">)</span>
        <span class="nf">.map</span><span class="p">(|(</span><span class="n">steps</span><span class="p">,</span> <span class="n">_</span><span class="p">)|</span> <span class="n">steps</span><span class="p">)</span>
        <span class="nf">.unwrap</span><span class="p">()</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_star_2_10">Star 2</h3>
<div class="paragraph">
<p>The solution is based on a periodicity assumption: Let <code>r</code> be the number of directions given in the puzzle input. Given any start node <code>A</code>, let <code>n_A</code> be the smallest number such that <code>n_A</code> is an integer multiple of <code>r</code> and a target node <code>Z</code> is reached after <code>n_A</code> steps. Then this situation will repeat exactly every <code>n_A</code> steps.</p>
</div>
<div class="paragraph">
<p>In that case, the solution is the least common multiple (LCM) of all <code>n_A</code> for any possible start node <code>A</code> (for my puzzle, it turned out that any <code>n_A</code> is a prime number multiplied by <code>r</code>, so the LCM calculation could be replaced by simpler multiplications).</p>
</div>
<div class="paragraph">
<p>The periodicity assumption is essentially a guess, it cannot be derived from the puzzle description. With the feature <code>check-periodicity</code> enabled, the code will verify it (at the cost of doubling the execution time for part 2).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
</pre></td><td class="code"><pre><span class="k">pub</span> <span class="k">fn</span> <span class="nf">star_2</span><span class="p">(</span><span class="nf">PuzzleData</span><span class="p">(</span><span class="n">dirs</span><span class="p">,</span> <span class="n">map</span><span class="p">):</span> <span class="o">&amp;</span><span class="n">PuzzleData</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">SolT</span> <span class="p">{</span>
    <span class="n">map</span><span class="nf">.keys</span><span class="p">()</span>
        <span class="nf">.filter</span><span class="p">(|</span><span class="n">key</span><span class="p">|</span> <span class="n">key</span><span class="nf">.ends_with</span><span class="p">(</span><span class="sc">'A'</span><span class="p">))</span>
        <span class="nf">.map</span><span class="p">(|</span><span class="o">&amp;</span><span class="n">node</span><span class="p">|</span> <span class="p">{</span>
            <span class="k">let</span> <span class="k">mut</span> <span class="n">it</span> <span class="o">=</span> <span class="nf">map_iter</span><span class="p">(</span><span class="n">dirs</span><span class="p">,</span> <span class="n">map</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span>
                <span class="nf">.step_by</span><span class="p">(</span><span class="n">dirs</span><span class="nf">.len</span><span class="p">())</span> <span class="c1">// only find result that used all dirs</span>
                <span class="nf">.filter</span><span class="p">(|(</span><span class="n">_</span><span class="p">,</span> <span class="n">node</span><span class="p">)|</span> <span class="n">node</span><span class="nf">.ends_with</span><span class="p">(</span><span class="sc">'Z'</span><span class="p">));</span>
            <span class="k">let</span> <span class="p">(</span><span class="n">steps_0</span><span class="p">,</span> <span class="n">node_0</span><span class="p">)</span> <span class="o">=</span> <span class="n">it</span><span class="nf">.next</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">();</span>
            <span class="k">if</span> <span class="nd">cfg!</span><span class="p">(</span><span class="n">feature</span> <span class="o">=</span> <span class="s">"check-periodicity"</span><span class="p">)</span> <span class="p">{</span>
                <span class="c1">// the solution assumes periodicity, so let's check it</span>
                <span class="k">let</span> <span class="p">(</span><span class="n">steps_1</span><span class="p">,</span> <span class="n">node_1</span><span class="p">)</span> <span class="o">=</span> <span class="n">it</span><span class="nf">.next</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">();</span>
                <span class="k">if</span> <span class="n">steps_1</span> <span class="o">!=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">steps_0</span> <span class="p">||</span> <span class="n">node_1</span> <span class="o">!=</span> <span class="n">node_0</span> <span class="p">{</span>
                    <span class="nd">panic!</span><span class="p">(</span><span class="s">"Periodicity assumption not satisfied!"</span><span class="p">);</span>
                <span class="p">}</span>
            <span class="p">}</span>
            <span class="n">steps_0</span>
        <span class="p">})</span>
        <span class="nf">.fold</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="p">|</span><span class="n">result</span><span class="p">,</span> <span class="n">steps</span><span class="p">|</span> <span class="n">result</span> <span class="o">*</span> <span class="n">steps</span> <span class="o">/</span> <span class="nf">gcd</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">steps</span><span class="p">))</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_tests_8">Tests</h3>
<div class="paragraph">
<p>The special "test" <code>test_understand</code> is used to get insight into to puzzle data and verify periodicity. It is supposed to run with the <code>--nocapture</code> option, because printing to <code>stdout</code> is really all it does.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
</pre></td><td class="code"><pre><span class="nd">#[cfg(test)]</span>
<span class="k">mod</span> <span class="n">tests</span> <span class="p">{</span>
    <span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">collections</span><span class="p">::</span><span class="n">HashMap</span><span class="p">;</span>

    <span class="k">use</span> <span class="k">super</span><span class="p">::</span><span class="o">*</span><span class="p">;</span>

    <span class="k">const</span> <span class="n">CONTENT</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span> <span class="o">=</span> <span class="s">r#"LLR

AAA = (BBB, BBB)
BBB = (AAA, ZZZ)
ZZZ = (ZZZ, ZZZ)
"#</span><span class="p">;</span>

    <span class="nd">#[test]</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">test_from</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">data</span> <span class="o">=</span> <span class="nn">PuzzleData</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="n">CONTENT</span><span class="p">);</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"{data:?}"</span><span class="p">);</span>
        <span class="nd">assert_eq!</span><span class="p">(</span>
            <span class="nf">PuzzleData</span><span class="p">(</span>
                <span class="s">"LLR"</span><span class="nf">.as_bytes</span><span class="p">(),</span>
                <span class="nn">HashMap</span><span class="p">::</span><span class="nf">from</span><span class="p">([</span>
                    <span class="p">(</span><span class="s">"AAA"</span><span class="p">,</span> <span class="p">(</span><span class="s">"BBB"</span><span class="p">,</span> <span class="s">"BBB"</span><span class="p">)),</span>
                    <span class="p">(</span><span class="s">"BBB"</span><span class="p">,</span> <span class="p">(</span><span class="s">"AAA"</span><span class="p">,</span> <span class="s">"ZZZ"</span><span class="p">)),</span>
                    <span class="p">(</span><span class="s">"ZZZ"</span><span class="p">,</span> <span class="p">(</span><span class="s">"ZZZ"</span><span class="p">,</span> <span class="s">"ZZZ"</span><span class="p">))</span>
                <span class="p">])</span>
            <span class="p">),</span>
            <span class="n">data</span>
        <span class="p">);</span>
    <span class="p">}</span>

    <span class="nd">#[test]</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">test_star_1</span><span class="p">()</span> <span class="p">{</span>
        <span class="nd">assert_eq!</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="nf">star_1</span><span class="p">(</span><span class="o">&amp;</span><span class="n">CONTENT</span><span class="nf">.into</span><span class="p">()));</span>
    <span class="p">}</span>

    <span class="k">const</span> <span class="n">CONTENT_2</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span> <span class="o">=</span> <span class="s">r#"LR

11A = (11B, XXX)
11B = (XXX, 11Z)
11Z = (11B, XXX)
22A = (22B, XXX)
22B = (22C, 22C)
22C = (22Z, 22Z)
22Z = (22B, 22B)
XXX = (XXX, XXX)
"#</span><span class="p">;</span>

    <span class="nd">#[test]</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">test_star_2</span><span class="p">()</span> <span class="p">{</span>
        <span class="nd">assert_eq!</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="nf">star_2</span><span class="p">(</span><span class="o">&amp;</span><span class="n">CONTENT_2</span><span class="nf">.into</span><span class="p">()));</span>
    <span class="p">}</span>

    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">do_understand</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">let</span> <span class="nf">PuzzleData</span><span class="p">(</span><span class="n">dirs</span><span class="p">,</span> <span class="n">map</span><span class="p">)</span> <span class="o">=</span> <span class="n">data</span><span class="nf">.into</span><span class="p">();</span>
        <span class="k">for</span> <span class="n">node</span> <span class="k">in</span> <span class="n">map</span>
            <span class="nf">.keys</span><span class="p">()</span>
            <span class="nf">.filter</span><span class="p">(|</span><span class="n">node</span><span class="p">|</span> <span class="n">node</span><span class="nf">.ends_with</span><span class="p">(</span><span class="sc">'A'</span><span class="p">))</span>
            <span class="nf">.map</span><span class="p">(|</span><span class="n">node</span><span class="p">|</span> <span class="o">*</span><span class="n">node</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="nd">println!</span><span class="p">(</span><span class="s">"Node {}"</span><span class="p">,</span> <span class="n">node</span><span class="p">);</span>
            <span class="k">let</span> <span class="k">mut</span> <span class="n">base</span> <span class="o">=</span> <span class="nb">None</span><span class="p">;</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span> <span class="k">in</span> <span class="nf">map_iter</span><span class="p">(</span><span class="n">dirs</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">map</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span>
                <span class="nf">.step_by</span><span class="p">(</span><span class="n">dirs</span><span class="nf">.len</span><span class="p">())</span>
                <span class="nf">.filter</span><span class="p">(|</span><span class="o">&amp;</span><span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="n">x</span><span class="p">)|</span> <span class="n">x</span><span class="nf">.ends_with</span><span class="p">(</span><span class="sc">'Z'</span><span class="p">))</span>
                <span class="nf">.take</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="k">let</span> <span class="n">base</span> <span class="o">=</span> <span class="o">*</span><span class="n">base</span><span class="nf">.get_or_insert</span><span class="p">(</span><span class="n">pos</span><span class="p">);</span>
                <span class="nd">println!</span><span class="p">(</span>
                    <span class="s">"    reached {} at step {} = {} * {} + {} = {} * {} + {}"</span><span class="p">,</span>
                    <span class="n">node</span><span class="p">,</span>
                    <span class="n">pos</span><span class="p">,</span>
                    <span class="n">pos</span> <span class="o">/</span> <span class="n">base</span><span class="p">,</span>
                    <span class="n">base</span><span class="p">,</span>
                    <span class="n">pos</span> <span class="o">%</span> <span class="n">base</span><span class="p">,</span>
                    <span class="n">pos</span> <span class="o">/</span> <span class="n">dirs</span><span class="nf">.len</span><span class="p">(),</span>
                    <span class="n">dirs</span><span class="nf">.len</span><span class="p">(),</span>
                    <span class="n">pos</span> <span class="o">%</span> <span class="n">dirs</span><span class="nf">.len</span><span class="p">()</span>
                <span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="nd">#[test]</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">test_understand</span><span class="p">()</span> <span class="p">{</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">Sample data 2"</span><span class="p">);</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"============="</span><span class="p">);</span>
        <span class="nf">do_understand</span><span class="p">(</span><span class="n">CONTENT_2</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>

        <span class="nd">println!</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">Puzzle input"</span><span class="p">);</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"============"</span><span class="p">);</span>
        <span class="nf">do_understand</span><span class="p">(</span><span class="o">&amp;</span><span class="nf">read_input</span><span class="p">(),</span> <span class="mi">2</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p><a href="#top">Top</a></p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="sol-rust-9">Rust | Day 9: Mirage Maintenance</h2>
<div class="sectionbody">
<div class="paragraph">
<p><a href="https://rust-lang.org">Rust</a> solution to <a href="https://adventofcode.com/2023/day/9">AoC|2023|9</a>.</p>
</div>
<div class="sect2">
<h3 id="_input_8">Input</h3>
<div class="paragraph">
<p>Lines of lists into <code>Vec&lt;Vec&lt;&#8230;&#8203;&gt;&gt;</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
</pre></td><td class="code"><pre><span class="k">pub</span> <span class="k">mod</span> <span class="n">input</span> <span class="p">{</span>
    <span class="k">use</span> <span class="k">crate</span><span class="p">::</span><span class="n">SolT</span><span class="p">;</span>

    <span class="nd">#[derive(Debug,</span> <span class="nd">PartialEq,</span> <span class="nd">Eq)]</span>
    <span class="k">pub</span> <span class="k">struct</span> <span class="nf">PuzzleData</span><span class="p">(</span><span class="k">pub</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="n">SolT</span><span class="o">&gt;&gt;</span><span class="p">);</span>

    <span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="nb">From</span><span class="o">&lt;&amp;</span><span class="n">T</span><span class="o">&gt;</span> <span class="k">for</span> <span class="n">PuzzleData</span>
    <span class="k">where</span>
        <span class="n">T</span><span class="p">:</span> <span class="nb">AsRef</span><span class="o">&lt;</span><span class="nb">str</span><span class="o">&gt;</span> <span class="o">+</span> <span class="o">?</span><span class="nb">Sized</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="k">fn</span> <span class="nf">from</span><span class="p">(</span><span class="n">s</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">T</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
            <span class="k">Self</span><span class="p">(</span>
                <span class="n">s</span><span class="nf">.as_ref</span><span class="p">()</span>
                    <span class="nf">.lines</span><span class="p">()</span>
                    <span class="nf">.map</span><span class="p">(|</span><span class="n">line</span><span class="p">|</span> <span class="p">{</span>
                        <span class="n">line</span><span class="nf">.split_ascii_whitespace</span><span class="p">()</span>
                            <span class="nf">.map</span><span class="p">(</span><span class="nn">str</span><span class="p">::</span><span class="n">parse</span><span class="p">)</span>
                            <span class="py">.collect</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">Result</span><span class="o">&lt;</span><span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="o">&gt;&gt;</span><span class="p">()</span>
                    <span class="p">})</span>
                    <span class="py">.collect</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">Result</span><span class="o">&lt;</span><span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="o">&gt;&gt;</span><span class="p">()</span>
                    <span class="nf">.unwrap</span><span class="p">(),</span>
            <span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_star_1_11">Star 1</h3>
<div class="paragraph">
<p>I wanted to avoid to allocate a new vector in every iteration step, so I do the processing in place. This results in a <code>successors</code> iterator with side effects on the mutable <code>values</code> vector. Maybe a while loop would be cleaner in that case, but I had to give in to my iterator fetish.</p>
</div>
<div class="paragraph">
<p>The tail values of all iterations equally contribute to the prediction in a simple sum.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
</pre></td><td class="code"><pre><span class="k">pub</span> <span class="k">fn</span> <span class="n">extrapolate_back</span><span class="o">&lt;</span><span class="n">T</span><span class="p">:</span> <span class="nb">AsRef</span><span class="o">&lt;</span><span class="p">[</span><span class="n">SolT</span><span class="p">]</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">values</span><span class="p">:</span> <span class="n">T</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">SolT</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">values</span> <span class="o">=</span> <span class="n">values</span><span class="nf">.as_ref</span><span class="p">()</span><span class="nf">.to_owned</span><span class="p">();</span>
    <span class="nf">successors</span><span class="p">(</span><span class="nf">Some</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="n">values</span><span class="nf">.len</span><span class="p">())),</span> <span class="p">|</span><span class="o">&amp;</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">len</span><span class="p">)|</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="mi">0</span><span class="o">..</span><span class="n">len</span><span class="p">)</span><span class="nf">.all</span><span class="p">(|</span><span class="n">k</span><span class="p">|</span> <span class="n">values</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="nb">None</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">tail</span> <span class="o">=</span> <span class="n">values</span><span class="p">[</span><span class="n">len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
            <span class="k">for</span> <span class="n">k</span> <span class="k">in</span> <span class="mi">0</span><span class="o">..</span><span class="n">len</span> <span class="o">-</span> <span class="mi">1</span> <span class="p">{</span>
                <span class="n">values</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">values</span><span class="p">[</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">values</span><span class="p">[</span><span class="n">k</span><span class="p">];</span>
            <span class="p">}</span>
            <span class="nf">Some</span><span class="p">((</span><span class="n">result</span> <span class="o">+</span> <span class="n">tail</span><span class="p">,</span> <span class="n">len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
        <span class="p">}</span>
    <span class="p">})</span>
    <span class="nf">.last</span><span class="p">()</span>
    <span class="nf">.map</span><span class="p">(|(</span><span class="n">result</span><span class="p">,</span> <span class="n">_</span><span class="p">)|</span> <span class="n">result</span><span class="p">)</span>
    <span class="nf">.unwrap_or</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">pub</span> <span class="k">fn</span> <span class="nf">star_1</span><span class="p">(</span><span class="nf">PuzzleData</span><span class="p">(</span><span class="n">values</span><span class="p">):</span> <span class="o">&amp;</span><span class="n">PuzzleData</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">SolT</span> <span class="p">{</span>
    <span class="n">values</span><span class="nf">.iter</span><span class="p">()</span><span class="nf">.map</span><span class="p">(</span><span class="n">extrapolate_back</span><span class="p">)</span><span class="nf">.sum</span><span class="p">()</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_star_2_11">Star 2</h3>
<div class="paragraph">
<p>I was expecting much more complicated. It took a short moment to get the signs right, but essentially, just a duplication of part 1.</p>
</div>
<div class="paragraph">
<p>The head values of all iterations contribute to the prediction through an alternating sum. The head of the original data contributes positively.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
</pre></td><td class="code"><pre><span class="k">pub</span> <span class="k">fn</span> <span class="n">extrapolate_front</span><span class="o">&lt;</span><span class="n">T</span><span class="p">:</span> <span class="nb">AsRef</span><span class="o">&lt;</span><span class="p">[</span><span class="n">SolT</span><span class="p">]</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">values</span><span class="p">:</span> <span class="n">T</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">SolT</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">values</span> <span class="o">=</span> <span class="n">values</span><span class="nf">.as_ref</span><span class="p">()</span><span class="nf">.to_owned</span><span class="p">();</span>
    <span class="nf">successors</span><span class="p">(</span><span class="nf">Some</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">values</span><span class="nf">.len</span><span class="p">())),</span> <span class="p">|</span><span class="o">&amp;</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">sign</span><span class="p">,</span> <span class="n">len</span><span class="p">)|</span> <span class="p">{</span>
        <span class="k">if</span> <span class="n">len</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">||</span> <span class="p">(</span><span class="mi">0</span><span class="o">..</span><span class="n">len</span><span class="p">)</span><span class="nf">.all</span><span class="p">(|</span><span class="n">k</span><span class="p">|</span> <span class="n">values</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="nb">None</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">head</span> <span class="o">=</span> <span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
            <span class="k">for</span> <span class="n">k</span> <span class="k">in</span> <span class="mi">0</span><span class="o">..</span><span class="n">len</span> <span class="o">-</span> <span class="mi">1</span> <span class="p">{</span>
                <span class="n">values</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">values</span><span class="p">[</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">values</span><span class="p">[</span><span class="n">k</span><span class="p">];</span>
            <span class="p">}</span>
            <span class="nf">Some</span><span class="p">((</span><span class="n">result</span> <span class="o">+</span> <span class="n">sign</span> <span class="o">*</span> <span class="n">head</span><span class="p">,</span> <span class="o">-</span><span class="n">sign</span><span class="p">,</span> <span class="n">len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
        <span class="p">}</span>
    <span class="p">})</span>
    <span class="nf">.last</span><span class="p">()</span>
    <span class="nf">.map</span><span class="p">(|(</span><span class="n">result</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">)|</span> <span class="n">result</span><span class="p">)</span>
    <span class="nf">.unwrap_or</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">pub</span> <span class="k">fn</span> <span class="nf">star_2</span><span class="p">(</span><span class="nf">PuzzleData</span><span class="p">(</span><span class="n">values</span><span class="p">):</span> <span class="o">&amp;</span><span class="n">PuzzleData</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">SolT</span> <span class="p">{</span>
    <span class="n">values</span><span class="nf">.iter</span><span class="p">()</span><span class="nf">.map</span><span class="p">(</span><span class="n">extrapolate_front</span><span class="p">)</span><span class="nf">.sum</span><span class="p">()</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_tests_9">Tests</h3>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
</pre></td><td class="code"><pre><span class="nd">#[cfg(test)]</span>
<span class="k">mod</span> <span class="n">tests</span> <span class="p">{</span>
    <span class="k">use</span> <span class="k">super</span><span class="p">::</span><span class="o">*</span><span class="p">;</span>

    <span class="k">const</span> <span class="n">CONTENT</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span> <span class="o">=</span> <span class="s">r#"0 3 6 9 12 15
1 3 6 10 15 21
10 13 16 21 30 45
"#</span><span class="p">;</span>

    <span class="nd">#[test]</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">test_from</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">data</span> <span class="o">=</span> <span class="nn">PuzzleData</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="n">CONTENT</span><span class="p">);</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"{data:?}"</span><span class="p">);</span>
        <span class="nd">assert_eq!</span><span class="p">(</span>
            <span class="nf">PuzzleData</span><span class="p">(</span><span class="nd">vec!</span><span class="p">[</span>
                <span class="nd">vec!</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">15</span><span class="p">],</span>
                <span class="nd">vec!</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">21</span><span class="p">],</span>
                <span class="nd">vec!</span><span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">13</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">21</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">45</span><span class="p">]</span>
            <span class="p">]),</span>
            <span class="n">data</span>
        <span class="p">);</span>
    <span class="p">}</span>

    <span class="nd">#[test]</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">test_star_1</span><span class="p">()</span> <span class="p">{</span>
        <span class="nd">assert_eq!</span><span class="p">(</span><span class="mi">114</span><span class="p">,</span> <span class="nf">star_1</span><span class="p">(</span><span class="o">&amp;</span><span class="n">CONTENT</span><span class="nf">.into</span><span class="p">()));</span>
    <span class="p">}</span>

    <span class="nd">#[test]</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">test_extrapolate_front</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">front</span> <span class="o">=</span> <span class="nf">extrapolate_front</span><span class="p">([</span><span class="mi">10</span><span class="p">,</span> <span class="mi">13</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">21</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">45</span><span class="p">]);</span>
        <span class="nd">assert_eq!</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="n">front</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="nd">#[test]</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">test_star_2</span><span class="p">()</span> <span class="p">{</span>
        <span class="nd">assert_eq!</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="nf">star_2</span><span class="p">(</span><span class="o">&amp;</span><span class="n">CONTENT</span><span class="nf">.into</span><span class="p">()));</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p><a href="#top">Top</a></p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="sol-rust-10">Rust | Day 10: Pipe Maze</h2>
<div class="sectionbody">
<div class="paragraph">
<p><a href="https://rust-lang.org">Rust</a> solution to <a href="https://adventofcode.com/2023/day/10">AoC|2023|10</a>.</p>
</div>
<div class="paragraph">
<p>I was a little bit scared when one of the first words I read in the description was "maze"&#8230;&#8203;</p>
</div>
<div class="sect2">
<h3 id="_input_9">Input</h3>
<div class="paragraph">
<p>I use my utility <code>Grid</code> implementation. A layer of '.' is added around the original grid to avoid special treatment of elements on the boundary.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
</pre></td><td class="code"><pre><span class="k">pub</span> <span class="k">mod</span> <span class="n">input</span> <span class="p">{</span>
    <span class="k">use</span> <span class="nn">mr_kaffee_utils</span><span class="p">::</span><span class="nn">grids</span><span class="p">::{</span><span class="n">Grid</span><span class="p">,</span> <span class="n">MakeGrid</span><span class="p">};</span>

    <span class="nd">#[derive(Debug)]</span>
    <span class="k">pub</span> <span class="k">struct</span> <span class="nf">PuzzleData</span><span class="p">(</span><span class="k">pub</span> <span class="n">Grid</span><span class="p">);</span>

    <span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="nb">From</span><span class="o">&lt;&amp;</span><span class="n">T</span><span class="o">&gt;</span> <span class="k">for</span> <span class="n">PuzzleData</span>
    <span class="k">where</span>
        <span class="n">T</span><span class="p">:</span> <span class="nb">AsRef</span><span class="o">&lt;</span><span class="p">[</span><span class="nb">u8</span><span class="p">]</span><span class="o">&gt;</span> <span class="o">+</span> <span class="o">?</span><span class="nb">Sized</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="k">fn</span> <span class="nf">from</span><span class="p">(</span><span class="n">s</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">T</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
            <span class="k">Self</span><span class="p">(</span><span class="n">s</span><span class="nf">.make_grid</span><span class="p">(</span><span class="nf">Some</span><span class="p">(</span><span class="sc">b'.'</span><span class="p">)))</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_star_1_12">Star 1</h3>
<div class="paragraph">
<p>Walk the loop (since we need to walk the entire loop, there is no advantage in doing a BFS), the max distance is half of the loop length (which is always even). The information which position belongs to the loop is stored in a vector of booleans.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
</pre></td><td class="code"><pre><span class="k">fn</span> <span class="nf">deduce_pipe</span><span class="p">(</span><span class="n">grid</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Grid</span><span class="p">,</span> <span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="n">row</span><span class="p">):</span> <span class="p">(</span><span class="nb">usize</span><span class="p">,</span> <span class="nb">usize</span><span class="p">))</span> <span class="k">-&gt;</span> <span class="nb">u8</span> <span class="p">{</span>
    <span class="k">const</span> <span class="n">TO_EAST</span><span class="p">:</span> <span class="p">[</span><span class="nb">u8</span><span class="p">;</span> <span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="sc">b'-'</span><span class="p">,</span> <span class="sc">b'J'</span><span class="p">,</span> <span class="sc">b'7'</span><span class="p">];</span>
    <span class="k">const</span> <span class="n">TO_NORTH</span><span class="p">:</span> <span class="p">[</span><span class="nb">u8</span><span class="p">;</span> <span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="sc">b'|'</span><span class="p">,</span> <span class="sc">b'F'</span><span class="p">,</span> <span class="sc">b'7'</span><span class="p">];</span>
    <span class="k">const</span> <span class="n">TO_WEST</span><span class="p">:</span> <span class="p">[</span><span class="nb">u8</span><span class="p">;</span> <span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="sc">b'-'</span><span class="p">,</span> <span class="sc">b'F'</span><span class="p">,</span> <span class="sc">b'L'</span><span class="p">];</span>
    <span class="k">const</span> <span class="n">TO_SOUTH</span><span class="p">:</span> <span class="p">[</span><span class="nb">u8</span><span class="p">;</span> <span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="sc">b'|'</span><span class="p">,</span> <span class="sc">b'L'</span><span class="p">,</span> <span class="sc">b'J'</span><span class="p">];</span>

    <span class="k">match</span> <span class="p">(</span>
        <span class="n">TO_EAST</span><span class="nf">.contains</span><span class="p">(</span><span class="o">&amp;</span><span class="n">grid</span><span class="p">[(</span><span class="n">col</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">row</span><span class="p">)]),</span>
        <span class="n">TO_NORTH</span><span class="nf">.contains</span><span class="p">(</span><span class="o">&amp;</span><span class="n">grid</span><span class="p">[(</span><span class="n">col</span><span class="p">,</span> <span class="n">row</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)]),</span>
        <span class="n">TO_WEST</span><span class="nf">.contains</span><span class="p">(</span><span class="o">&amp;</span><span class="n">grid</span><span class="p">[(</span><span class="n">col</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">row</span><span class="p">)]),</span>
        <span class="n">TO_SOUTH</span><span class="nf">.contains</span><span class="p">(</span><span class="o">&amp;</span><span class="n">grid</span><span class="p">[(</span><span class="n">col</span><span class="p">,</span> <span class="n">row</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]),</span>
    <span class="p">)</span> <span class="p">{</span>
        <span class="p">(</span><span class="k">true</span><span class="p">,</span> <span class="k">true</span><span class="p">,</span> <span class="k">false</span><span class="p">,</span> <span class="k">false</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="sc">b'L'</span><span class="p">,</span>
        <span class="p">(</span><span class="k">true</span><span class="p">,</span> <span class="k">false</span><span class="p">,</span> <span class="k">true</span><span class="p">,</span> <span class="k">false</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="sc">b'-'</span><span class="p">,</span>
        <span class="p">(</span><span class="k">true</span><span class="p">,</span> <span class="k">false</span><span class="p">,</span> <span class="k">false</span><span class="p">,</span> <span class="k">true</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="sc">b'F'</span><span class="p">,</span>
        <span class="p">(</span><span class="k">false</span><span class="p">,</span> <span class="k">true</span><span class="p">,</span> <span class="k">true</span><span class="p">,</span> <span class="k">false</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="sc">b'J'</span><span class="p">,</span>
        <span class="p">(</span><span class="k">false</span><span class="p">,</span> <span class="k">true</span><span class="p">,</span> <span class="k">false</span><span class="p">,</span> <span class="k">true</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="sc">b'|'</span><span class="p">,</span>
        <span class="p">(</span><span class="k">false</span><span class="p">,</span> <span class="k">false</span><span class="p">,</span> <span class="k">true</span><span class="p">,</span> <span class="k">true</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="sc">b'7'</span><span class="p">,</span>
        <span class="n">_</span> <span class="k">=&gt;</span> <span class="nd">panic!</span><span class="p">(),</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">pub</span> <span class="k">fn</span> <span class="nf">find_loop</span><span class="p">(</span><span class="n">grid</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">Grid</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="p">(</span><span class="n">SolT</span><span class="p">,</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">bool</span><span class="o">&gt;</span><span class="p">,</span> <span class="nb">u8</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">start</span> <span class="o">=</span> <span class="n">grid</span><span class="nf">.data</span><span class="p">()</span><span class="nf">.iter</span><span class="p">()</span><span class="nf">.position</span><span class="p">(|</span><span class="o">&amp;</span><span class="n">b</span><span class="p">|</span> <span class="n">b</span> <span class="o">==</span> <span class="sc">b'S'</span><span class="p">)</span><span class="nf">.unwrap</span><span class="p">();</span>
    <span class="k">let</span> <span class="n">start_pipe</span> <span class="o">=</span> <span class="nf">deduce_pipe</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">grid</span><span class="nf">.to_col_row</span><span class="p">(</span><span class="n">start</span><span class="p">));</span>

    <span class="k">let</span> <span class="p">(</span><span class="n">len</span><span class="p">,</span> <span class="n">pipe_loop</span><span class="p">)</span> <span class="o">=</span> <span class="nf">successors</span><span class="p">(</span><span class="nf">Some</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="n">start</span><span class="p">)),</span> <span class="p">|</span><span class="o">&amp;</span><span class="p">(</span><span class="n">prev_idx</span><span class="p">,</span> <span class="n">cur_idx</span><span class="p">)|</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">cur</span> <span class="o">=</span> <span class="k">match</span> <span class="n">grid</span><span class="p">[</span><span class="n">cur_idx</span><span class="p">]</span> <span class="p">{</span>
            <span class="sc">b'S'</span> <span class="k">=&gt;</span> <span class="n">start_pipe</span><span class="p">,</span>
            <span class="n">b</span> <span class="k">=&gt;</span> <span class="n">b</span><span class="p">,</span>
        <span class="p">};</span>

        <span class="k">let</span> <span class="p">(</span><span class="n">idx_a</span><span class="p">,</span> <span class="n">idx_b</span><span class="p">)</span> <span class="o">=</span> <span class="k">match</span> <span class="n">cur</span> <span class="p">{</span>
            <span class="sc">b'-'</span> <span class="k">=&gt;</span> <span class="p">(</span><span class="n">cur_idx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">cur_idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span>
            <span class="sc">b'|'</span> <span class="k">=&gt;</span> <span class="p">(</span><span class="n">cur_idx</span> <span class="o">-</span> <span class="n">grid</span><span class="nf">.width</span><span class="p">(),</span> <span class="n">cur_idx</span> <span class="o">+</span> <span class="n">grid</span><span class="nf">.width</span><span class="p">()),</span>
            <span class="sc">b'J'</span> <span class="k">=&gt;</span> <span class="p">(</span><span class="n">cur_idx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">cur_idx</span> <span class="o">-</span> <span class="n">grid</span><span class="nf">.width</span><span class="p">()),</span>
            <span class="sc">b'7'</span> <span class="k">=&gt;</span> <span class="p">(</span><span class="n">cur_idx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">cur_idx</span> <span class="o">+</span> <span class="n">grid</span><span class="nf">.width</span><span class="p">()),</span>
            <span class="sc">b'F'</span> <span class="k">=&gt;</span> <span class="p">(</span><span class="n">cur_idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">cur_idx</span> <span class="o">+</span> <span class="n">grid</span><span class="nf">.width</span><span class="p">()),</span>
            <span class="sc">b'L'</span> <span class="k">=&gt;</span> <span class="p">(</span><span class="n">cur_idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">cur_idx</span> <span class="o">-</span> <span class="n">grid</span><span class="nf">.width</span><span class="p">()),</span>
            <span class="n">_</span> <span class="k">=&gt;</span> <span class="nd">panic!</span><span class="p">(),</span>
        <span class="p">};</span>

        <span class="k">if</span> <span class="n">prev_idx</span> <span class="o">!=</span> <span class="n">idx_a</span> <span class="o">&amp;&amp;</span> <span class="n">start</span> <span class="o">!=</span> <span class="n">idx_a</span> <span class="p">{</span>
            <span class="nf">Some</span><span class="p">((</span><span class="n">cur_idx</span><span class="p">,</span> <span class="n">idx_a</span><span class="p">))</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="n">prev_idx</span> <span class="o">!=</span> <span class="n">idx_b</span> <span class="o">&amp;&amp;</span> <span class="n">start</span> <span class="o">!=</span> <span class="n">idx_b</span> <span class="p">{</span>
            <span class="nf">Some</span><span class="p">((</span><span class="n">cur_idx</span><span class="p">,</span> <span class="n">idx_b</span><span class="p">))</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="nb">None</span>
        <span class="p">}</span>
    <span class="p">})</span>
    <span class="nf">.fold</span><span class="p">(</span>
        <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nd">vec!</span><span class="p">[</span><span class="kc">false</span><span class="p">;</span> <span class="n">grid</span><span class="nf">.len</span><span class="p">()]),</span>
        <span class="p">|(</span><span class="n">len</span><span class="p">,</span> <span class="k">mut</span> <span class="n">pipe_loop</span><span class="p">),</span> <span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="n">idx</span><span class="p">)|</span> <span class="p">{</span>
            <span class="n">pipe_loop</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="k">true</span><span class="p">;</span>
            <span class="p">(</span><span class="n">len</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">pipe_loop</span><span class="p">)</span>
        <span class="p">},</span>
    <span class="p">);</span>

    <span class="p">(</span><span class="n">len</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">,</span> <span class="n">pipe_loop</span><span class="p">,</span> <span class="n">start_pipe</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">pub</span> <span class="k">fn</span> <span class="nf">star_1</span><span class="p">(</span><span class="nf">PuzzleData</span><span class="p">(</span><span class="n">grid</span><span class="p">):</span> <span class="o">&amp;</span><span class="n">PuzzleData</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">SolT</span> <span class="p">{</span>
    <span class="k">let</span> <span class="p">(</span><span class="n">mx</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">)</span> <span class="o">=</span> <span class="nf">find_loop</span><span class="p">(</span><span class="n">grid</span><span class="p">);</span>
    <span class="n">mx</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_star_2_12">Star 2</h3>
<div class="paragraph">
<p>The easy part was to figure out that a point is inside the loop if going from that point outwards, we cross the loop an odd number of times.</p>
</div>
<div class="paragraph">
<p>The tricky part was how to figure out the number of crossings. I decided to always go east. To count the number of crossings, we are only interested in the points that are contained in the pipe, and we can ignore <code>-</code> elements to which we are strictly tangent. Doing so, we just need the current and the previous element to decide whether we crossed the loop. This is the case exactly if the current element is '|' or when the previous and current element are 'L', '7' or 'F', 'J'.</p>
</div>
<div class="paragraph">
<p>My initial solution checked point by point, adding quite a bit of overhead (the solution is still available by setting feature <code>point-by-point</code>). It is a quite easy modification to count the points inside the loop line by line.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
</pre></td><td class="code"><pre><span class="nd">#[cfg(feature</span> <span class="nd">=</span> <span class="s">"point-by-point"</span><span class="nd">)]</span>
<span class="k">pub</span> <span class="k">fn</span> <span class="nf">star_2</span><span class="p">(</span><span class="nf">PuzzleData</span><span class="p">(</span><span class="n">grid</span><span class="p">):</span> <span class="o">&amp;</span><span class="n">PuzzleData</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">SolT</span> <span class="p">{</span>
    <span class="k">let</span> <span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="n">pipe_loop</span><span class="p">,</span> <span class="n">start_pipe</span><span class="p">)</span> <span class="o">=</span> <span class="nf">find_loop</span><span class="p">(</span><span class="n">grid</span><span class="p">);</span>

    <span class="p">(</span><span class="mi">0</span><span class="o">..</span><span class="n">grid</span><span class="nf">.len</span><span class="p">())</span>
        <span class="nf">.map</span><span class="p">(|</span><span class="n">pos</span><span class="p">|</span> <span class="n">grid</span><span class="nf">.to_col_row</span><span class="p">(</span><span class="n">pos</span><span class="p">))</span>
        <span class="nf">.filter</span><span class="p">(|</span><span class="o">&amp;</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="n">row</span><span class="p">)|</span> <span class="o">!</span><span class="n">pipe_loop</span><span class="p">[</span><span class="n">col</span> <span class="o">+</span> <span class="n">grid</span><span class="nf">.width</span><span class="p">()</span> <span class="o">*</span> <span class="n">row</span><span class="p">])</span>
        <span class="nf">.filter</span><span class="p">(|</span><span class="o">&amp;</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="n">row</span><span class="p">)|</span> <span class="p">{</span>
            <span class="c1">// count crossings of pipe</span>
            <span class="k">let</span> <span class="p">(</span><span class="n">cnt</span><span class="p">,</span> <span class="n">_</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="n">col</span> <span class="o">+</span> <span class="mi">1</span><span class="o">..</span><span class="n">grid</span><span class="nf">.width</span><span class="p">())</span>
                <span class="c1">// skip elements not part of pipe</span>
                <span class="nf">.filter</span><span class="p">(|</span><span class="o">&amp;</span><span class="n">col</span><span class="p">|</span> <span class="n">pipe_loop</span><span class="p">[</span><span class="n">col</span> <span class="o">+</span> <span class="n">grid</span><span class="nf">.width</span><span class="p">()</span> <span class="o">*</span> <span class="n">row</span><span class="p">])</span>
                <span class="c1">// map to elements (substituting 'S')</span>
                <span class="nf">.map</span><span class="p">(|</span><span class="n">col</span><span class="p">|</span> <span class="k">match</span> <span class="n">grid</span><span class="p">[(</span><span class="n">col</span><span class="p">,</span> <span class="n">row</span><span class="p">)]</span> <span class="p">{</span>
                    <span class="sc">b'S'</span> <span class="k">=&gt;</span> <span class="n">start_pipe</span><span class="p">,</span>
                    <span class="n">b</span> <span class="k">=&gt;</span> <span class="n">b</span><span class="p">,</span>
                <span class="p">})</span>
                <span class="c1">// skip purely tangent elements</span>
                <span class="nf">.filter</span><span class="p">(|</span><span class="o">&amp;</span><span class="n">b</span><span class="p">|</span> <span class="n">b</span> <span class="o">!=</span> <span class="sc">b'-'</span><span class="p">)</span>
                <span class="c1">// count crossings</span>
                <span class="nf">.fold</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="sc">b'.'</span><span class="p">),</span> <span class="p">|(</span><span class="n">cnt</span><span class="p">,</span> <span class="n">prev</span><span class="p">),</span> <span class="n">cur</span><span class="p">|</span> <span class="k">match</span> <span class="p">(</span><span class="n">prev</span><span class="p">,</span> <span class="n">cur</span><span class="p">)</span> <span class="p">{</span>
                    <span class="c1">// "|", "L7", and "FJ" are crossings</span>
                    <span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="sc">b'|'</span><span class="p">)</span> <span class="p">|</span> <span class="p">(</span><span class="sc">b'L'</span><span class="p">,</span> <span class="sc">b'7'</span><span class="p">)</span> <span class="p">|</span> <span class="p">(</span><span class="sc">b'F'</span><span class="p">,</span> <span class="sc">b'J'</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">(</span><span class="n">cnt</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">cur</span><span class="p">),</span>
                    <span class="n">_</span> <span class="k">=&gt;</span> <span class="p">(</span><span class="n">cnt</span><span class="p">,</span> <span class="n">cur</span><span class="p">),</span> <span class="c1">// anything else ("LJ", "F7", ...) is not a crossing</span>
                <span class="p">});</span>
            <span class="c1">// odd crossing count is inside</span>
            <span class="n">cnt</span> <span class="o">&amp;</span> <span class="mi">1</span> <span class="o">==</span> <span class="mi">1</span>
        <span class="p">})</span>
        <span class="nf">.count</span><span class="p">()</span>
<span class="p">}</span>

<span class="nd">#[cfg(not(feature</span> <span class="nd">=</span> <span class="s">"point-by-point"</span><span class="nd">))]</span>
<span class="k">pub</span> <span class="k">fn</span> <span class="nf">star_2</span><span class="p">(</span><span class="nf">PuzzleData</span><span class="p">(</span><span class="n">grid</span><span class="p">):</span> <span class="o">&amp;</span><span class="n">PuzzleData</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">SolT</span> <span class="p">{</span>
    <span class="k">let</span> <span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="n">pipe_loop</span><span class="p">,</span> <span class="n">start_pipe</span><span class="p">)</span> <span class="o">=</span> <span class="nf">find_loop</span><span class="p">(</span><span class="n">grid</span><span class="p">);</span>

    <span class="p">(</span><span class="mi">0</span><span class="o">..</span><span class="n">grid</span><span class="nf">.height</span><span class="p">())</span>
        <span class="nf">.map</span><span class="p">(|</span><span class="n">row</span><span class="p">|</span> <span class="p">{</span>
            <span class="k">let</span> <span class="p">(</span><span class="n">cnt</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="o">..</span><span class="n">grid</span><span class="nf">.width</span><span class="p">())</span>
                <span class="nf">.map</span><span class="p">(</span>
                    <span class="p">|</span><span class="n">col</span><span class="p">|</span> <span class="k">match</span> <span class="p">(</span><span class="n">pipe_loop</span><span class="p">[</span><span class="n">col</span> <span class="o">+</span> <span class="n">grid</span><span class="nf">.width</span><span class="p">()</span> <span class="o">*</span> <span class="n">row</span><span class="p">],</span> <span class="n">grid</span><span class="p">[(</span><span class="n">col</span><span class="p">,</span> <span class="n">row</span><span class="p">)])</span> <span class="p">{</span>
                        <span class="p">(</span><span class="k">true</span><span class="p">,</span> <span class="sc">b'S'</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="n">start_pipe</span><span class="p">,</span>
                        <span class="p">(</span><span class="k">true</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="n">b</span><span class="p">,</span>
                        <span class="n">_</span> <span class="k">=&gt;</span> <span class="sc">b'.'</span><span class="p">,</span>
                    <span class="p">},</span>
                <span class="p">)</span>
                <span class="nf">.filter</span><span class="p">(|</span><span class="o">&amp;</span><span class="n">b</span><span class="p">|</span> <span class="n">b</span> <span class="o">!=</span> <span class="sc">b'-'</span><span class="p">)</span>
                <span class="nf">.fold</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="sc">b'.'</span><span class="p">,</span> <span class="k">false</span><span class="p">),</span> <span class="p">|(</span><span class="n">cnt</span><span class="p">,</span> <span class="n">prev</span><span class="p">,</span> <span class="n">inside</span><span class="p">),</span> <span class="n">cur</span><span class="p">|</span> <span class="p">{</span>
                    <span class="k">match</span> <span class="p">(</span><span class="n">inside</span><span class="p">,</span> <span class="n">prev</span><span class="p">,</span> <span class="n">cur</span><span class="p">)</span> <span class="p">{</span>
                        <span class="p">(</span><span class="k">true</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="sc">b'.'</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">(</span><span class="n">cnt</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">cur</span><span class="p">,</span> <span class="k">true</span><span class="p">),</span>
                        <span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="sc">b'|'</span><span class="p">)</span> <span class="p">|</span> <span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="sc">b'F'</span><span class="p">,</span> <span class="sc">b'J'</span><span class="p">)</span> <span class="p">|</span> <span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="sc">b'L'</span><span class="p">,</span> <span class="sc">b'7'</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">(</span><span class="n">cnt</span><span class="p">,</span> <span class="n">cur</span><span class="p">,</span> <span class="o">!</span><span class="n">inside</span><span class="p">),</span>
                        <span class="n">_</span> <span class="k">=&gt;</span> <span class="p">(</span><span class="n">cnt</span><span class="p">,</span> <span class="n">cur</span><span class="p">,</span> <span class="n">inside</span><span class="p">),</span>
                    <span class="p">}</span>
                <span class="p">});</span>
            <span class="n">cnt</span>
        <span class="p">})</span>
        <span class="nf">.sum</span><span class="p">()</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_tests_10">Tests</h3>
<div class="paragraph">
<p>I needed a few test inputs for the second part until I got all the edge cases right. The last missing step, which did actually not fail any of my tests, was to replace 'S' with the pipe type hidden below.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
</pre></td><td class="code"><pre><span class="nd">#[cfg(test)]</span>
<span class="k">mod</span> <span class="n">tests</span> <span class="p">{</span>
    <span class="k">use</span> <span class="k">super</span><span class="p">::</span><span class="o">*</span><span class="p">;</span>

    <span class="k">const</span> <span class="n">CONTENT</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span> <span class="o">=</span> <span class="s">r#"7-F7-
.FJ|7
SJLL7
|F--J
LJ.LJ
"#</span><span class="p">;</span>
    <span class="k">const</span> <span class="n">EXP_STAR_1</span><span class="p">:</span> <span class="n">SolT</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span>

    <span class="nd">#[test]</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">test_from</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">data</span> <span class="o">=</span> <span class="nn">PuzzleData</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="n">CONTENT</span><span class="p">);</span>
        <span class="nd">assert_eq!</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="n">data</span><span class="na">.0</span><span class="nf">.width</span><span class="p">());</span>
        <span class="nd">assert_eq!</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="n">data</span><span class="na">.0</span><span class="nf">.height</span><span class="p">());</span>
    <span class="p">}</span>

    <span class="nd">#[test]</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">test_star_1</span><span class="p">()</span> <span class="p">{</span>
        <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">EXP_STAR_1</span><span class="p">,</span> <span class="nf">star_1</span><span class="p">(</span><span class="o">&amp;</span><span class="n">CONTENT</span><span class="nf">.into</span><span class="p">()));</span>
    <span class="p">}</span>

    <span class="k">const</span> <span class="n">CONTENT_2</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span> <span class="o">=</span> <span class="s">r#"FF7FSF7F7F7F7F7F---7
L|LJ||||||||||||F--J
FL-7LJLJ||||||LJL-77
F--JF--7||LJLJ7F7FJ-
L---JF-JLJ.||-FJLJJ7
|F|F-JF---7F7-L7L|7|
|FFJF7L7F-JF7|JL---7
7-L-JL7||F7|L7F-7F7|
L.L7LFJ|||||FJL7||LJ
L7JLJL-JLJLJL--JLJ.L
"#</span><span class="p">;</span>
    <span class="k">const</span> <span class="n">EXP_2_STAR_2</span><span class="p">:</span> <span class="n">SolT</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>

    <span class="k">const</span> <span class="n">CONTENT_3</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span> <span class="o">=</span> <span class="s">r#"...........
.S-------7.
.|F-----7|.
.||.....||.
.||.....||.
.|L-7.F-J|.
.|..|.|..|.
.L--J.L--J.
...........
"#</span><span class="p">;</span>
    <span class="k">const</span> <span class="n">EXP_3_STAR_2</span><span class="p">:</span> <span class="n">SolT</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>

    <span class="k">const</span> <span class="n">CONTENT_4</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span> <span class="o">=</span> <span class="s">r#".F----7F7F7F7F-7....
.|F--7||||||||FJ....
.||.FJ||||||||L7....
FJL7L7LJLJ||LJ.L-7..
L--J.L7...LJS7F-7L7.
....F-J..F7FJ|L7L7L7
....L7.F7||L7|.L7L7|
.....|FJLJ|FJ|F7|.LJ
....FJL-7.||.||||...
....L---J.LJ.LJLJ...
"#</span><span class="p">;</span>
    <span class="k">const</span> <span class="n">EXP_4_STAR_2</span><span class="p">:</span> <span class="n">SolT</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span>

    <span class="nd">#[test]</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">test_star_2</span><span class="p">()</span> <span class="p">{</span>
        <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">EXP_2_STAR_2</span><span class="p">,</span> <span class="nf">star_2</span><span class="p">(</span><span class="o">&amp;</span><span class="n">CONTENT_2</span><span class="nf">.into</span><span class="p">()));</span>
        <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">EXP_3_STAR_2</span><span class="p">,</span> <span class="nf">star_2</span><span class="p">(</span><span class="o">&amp;</span><span class="n">CONTENT_3</span><span class="nf">.into</span><span class="p">()));</span>
        <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">EXP_4_STAR_2</span><span class="p">,</span> <span class="nf">star_2</span><span class="p">(</span><span class="o">&amp;</span><span class="n">CONTENT_4</span><span class="nf">.into</span><span class="p">()));</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p><a href="#top">Top</a></p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="sol-rust-11">Day 11: Cosmic Expansion</h2>
<div class="sectionbody">
<div class="paragraph">
<p><a href="https://rust-lang.org">Rust</a> solution to <a href="https://adventofcode.com/2023/day/11">AoC|2023|11</a>.</p>
</div>
<div class="sect2">
<h3 id="_input_10">Input</h3>
<div class="paragraph">
<p>I store the coordinates of each galaxy in a vector and create two more vectors with the galaxy counts in very column/row.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
</pre></td><td class="code"><pre><span class="k">pub</span> <span class="k">mod</span> <span class="n">input</span> <span class="p">{</span>
    <span class="nd">#[derive(Debug,</span> <span class="nd">PartialEq,</span> <span class="nd">Eq,</span> <span class="nd">Default)]</span>
    <span class="k">pub</span> <span class="k">struct</span> <span class="n">PuzzleData</span> <span class="p">{</span>
        <span class="k">pub</span> <span class="n">galaxies</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="p">(</span><span class="nb">usize</span><span class="p">,</span> <span class="nb">usize</span><span class="p">)</span><span class="o">&gt;</span><span class="p">,</span>
        <span class="k">pub</span> <span class="n">count_in_cols</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span><span class="p">,</span>
        <span class="k">pub</span> <span class="n">count_in_rows</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="p">}</span>

    <span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="nb">From</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="k">for</span> <span class="n">PuzzleData</span>
    <span class="k">where</span>
        <span class="n">T</span><span class="p">:</span> <span class="nb">AsRef</span><span class="o">&lt;</span><span class="nb">str</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="p">{</span>
        <span class="k">fn</span> <span class="nf">from</span><span class="p">(</span><span class="n">s</span><span class="p">:</span> <span class="n">T</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
            <span class="n">s</span><span class="nf">.as_ref</span><span class="p">()</span>
                <span class="nf">.lines</span><span class="p">()</span>
                <span class="nf">.enumerate</span><span class="p">()</span>
                <span class="nf">.fold</span><span class="p">(</span><span class="nn">PuzzleData</span><span class="p">::</span><span class="nf">default</span><span class="p">(),</span> <span class="p">|</span><span class="k">mut</span> <span class="n">data</span><span class="p">,</span> <span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">line</span><span class="p">)|</span> <span class="p">{</span>
                    <span class="n">data</span><span class="py">.count_in_rows</span><span class="nf">.push</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
                    <span class="n">line</span><span class="nf">.bytes</span><span class="p">()</span><span class="nf">.enumerate</span><span class="p">()</span><span class="nf">.filter</span><span class="p">(|(</span><span class="n">_</span><span class="p">,</span> <span class="n">b</span><span class="p">)|</span> <span class="n">b</span> <span class="o">==</span> <span class="o">&amp;</span><span class="sc">b'#'</span><span class="p">)</span><span class="nf">.fold</span><span class="p">(</span>
                        <span class="n">data</span><span class="p">,</span>
                        <span class="p">|</span><span class="k">mut</span> <span class="n">data</span><span class="p">,</span> <span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="n">_</span><span class="p">)|</span> <span class="p">{</span>
                            <span class="n">data</span><span class="py">.galaxies</span><span class="nf">.push</span><span class="p">((</span><span class="n">col</span><span class="p">,</span> <span class="n">row</span><span class="p">));</span>
                            <span class="n">data</span><span class="py">.count_in_cols</span>
                                <span class="nf">.resize</span><span class="p">(</span><span class="n">data</span><span class="py">.count_in_cols</span><span class="nf">.len</span><span class="p">()</span><span class="nf">.max</span><span class="p">(</span><span class="n">col</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
                            <span class="n">data</span><span class="py">.count_in_cols</span><span class="p">[</span><span class="n">col</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
                            <span class="n">data</span><span class="py">.count_in_rows</span><span class="p">[</span><span class="n">row</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
                            <span class="n">data</span>
                        <span class="p">},</span>
                    <span class="p">)</span>
                <span class="p">})</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_star_1_13">Star 1</h3>
<div class="paragraph">
<p>The basic approach was kind of straight forward. I experimented a bit with possibilities for optimization ending up with computing vectors with the offsets for each column and row that are indexed by the original positions of the galaxies (before expansion of the universe), to calculate the shortest distances in a single pass through all (unordered) pairs of galaxies.</p>
</div>
<div class="paragraph">
<p>I also experimented a bit with <code>flat_map</code> vs <code>map</code> for the nested iterators. In theory, <code>iter_a.flat_map(|a| iter_b.map(move |b| calc_val(a, b))).sum()</code> should create a bit of overhead compared to <code>iter_a.map(|a| iter_b.map(|b| calc_val(a, b)).sum()).sum()</code>. In practice, the differences were hardly in the range of fluctuations of the overall solution time.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
</pre></td><td class="code"><pre><span class="k">fn</span> <span class="nf">calc_offsets</span><span class="p">(</span><span class="n">counts</span><span class="p">:</span> <span class="o">&amp;</span><span class="p">[</span><span class="nb">usize</span><span class="p">],</span> <span class="n">expansion</span><span class="p">:</span> <span class="n">SolT</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">SolT</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="n">counts</span>
        <span class="nf">.iter</span><span class="p">()</span>
        <span class="nf">.scan</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="p">|</span><span class="n">cum_sum</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cnt</span><span class="p">|</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">val</span> <span class="o">=</span> <span class="nf">Some</span><span class="p">(</span><span class="o">*</span><span class="n">cum_sum</span><span class="p">);</span>
            <span class="o">*</span><span class="n">cum_sum</span> <span class="o">+=</span> <span class="k">if</span> <span class="n">cnt</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="p">{</span> <span class="mi">1</span> <span class="p">}</span> <span class="k">else</span> <span class="p">{</span> <span class="n">expansion</span> <span class="p">};</span>
            <span class="n">val</span>
        <span class="p">})</span>
        <span class="nf">.collect</span><span class="p">()</span>
<span class="p">}</span>

<span class="k">pub</span> <span class="k">fn</span> <span class="nf">sum_shortest_path</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">PuzzleData</span><span class="p">,</span> <span class="n">expansion</span><span class="p">:</span> <span class="n">SolT</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">SolT</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">col_offsets</span> <span class="o">=</span> <span class="nf">calc_offsets</span><span class="p">(</span><span class="o">&amp;</span><span class="n">data</span><span class="py">.count_in_cols</span><span class="p">,</span> <span class="n">expansion</span><span class="p">);</span>
    <span class="k">let</span> <span class="n">row_offsets</span> <span class="o">=</span> <span class="nf">calc_offsets</span><span class="p">(</span><span class="o">&amp;</span><span class="n">data</span><span class="py">.count_in_rows</span><span class="p">,</span> <span class="n">expansion</span><span class="p">);</span>
    <span class="n">data</span><span class="py">.galaxies</span>
        <span class="nf">.iter</span><span class="p">()</span>
        <span class="nf">.map</span><span class="p">(|</span><span class="o">&amp;</span><span class="p">(</span><span class="n">col_a</span><span class="p">,</span> <span class="n">row_a</span><span class="p">)|</span> <span class="p">(</span><span class="n">col_offsets</span><span class="p">[</span><span class="n">col_a</span><span class="p">],</span> <span class="n">row_offsets</span><span class="p">[</span><span class="n">row_a</span><span class="p">]))</span>
        <span class="nf">.enumerate</span><span class="p">()</span>
        <span class="nf">.map</span><span class="p">(|(</span><span class="n">pos</span><span class="p">,</span> <span class="p">(</span><span class="n">col_a</span><span class="p">,</span> <span class="n">row_a</span><span class="p">))|</span> <span class="p">{</span>
            <span class="n">data</span><span class="py">.galaxies</span><span class="p">[</span><span class="n">pos</span> <span class="o">+</span> <span class="mi">1</span><span class="o">..</span><span class="p">]</span>
                <span class="nf">.iter</span><span class="p">()</span>
                <span class="nf">.map</span><span class="p">(|</span><span class="o">&amp;</span><span class="p">(</span><span class="n">col_a</span><span class="p">,</span> <span class="n">row_a</span><span class="p">)|</span> <span class="p">(</span><span class="n">col_offsets</span><span class="p">[</span><span class="n">col_a</span><span class="p">],</span> <span class="n">row_offsets</span><span class="p">[</span><span class="n">row_a</span><span class="p">]))</span>
                <span class="nf">.map</span><span class="p">(|(</span><span class="n">col_b</span><span class="p">,</span> <span class="n">row_b</span><span class="p">)|</span> <span class="p">{</span>
                    <span class="n">col_b</span><span class="nf">.max</span><span class="p">(</span><span class="n">col_a</span><span class="p">)</span> <span class="o">-</span> <span class="n">col_b</span><span class="nf">.min</span><span class="p">(</span><span class="n">col_a</span><span class="p">)</span> <span class="o">+</span> <span class="n">row_b</span><span class="nf">.max</span><span class="p">(</span><span class="n">row_a</span><span class="p">)</span> <span class="o">-</span> <span class="n">row_b</span><span class="nf">.min</span><span class="p">(</span><span class="n">row_a</span><span class="p">)</span>
                <span class="p">})</span>
                <span class="py">.sum</span><span class="p">::</span><span class="o">&lt;</span><span class="n">SolT</span><span class="o">&gt;</span><span class="p">()</span>
        <span class="p">})</span>
        <span class="nf">.sum</span><span class="p">()</span>
<span class="p">}</span>

<span class="k">pub</span> <span class="k">fn</span> <span class="nf">star_1</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">PuzzleData</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">SolT</span> <span class="p">{</span>
    <span class="nf">sum_shortest_path</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_star_2_13">Star 2</h3>
<div class="paragraph">
<p>Even in my very first version, I did not alter the grid at all but just adjusted coordinates. So the second part was mostly for free (the only catch was to realize that I need to multiply by one million, not add one million).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno">1
2
3
</pre></td><td class="code"><pre><span class="k">pub</span> <span class="k">fn</span> <span class="nf">star_2</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">PuzzleData</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">SolT</span> <span class="p">{</span>
    <span class="nf">sum_shortest_path</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="mi">1_000_000</span><span class="p">)</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_tests_11">Tests</h3>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="rust"><table class="linenotable"><tbody><tr><td class="linenos gl"><pre class="lineno"> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
</pre></td><td class="code"><pre><span class="nd">#[cfg(test)]</span>
<span class="k">mod</span> <span class="n">tests</span> <span class="p">{</span>
    <span class="k">use</span> <span class="k">super</span><span class="p">::</span><span class="o">*</span><span class="p">;</span>

    <span class="k">const</span> <span class="n">CONTENT</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span> <span class="o">=</span> <span class="s">r#"...#......
.......#..
#.........
..........
......#...
.#........
.........#
..........
.......#..
#...#.....
"#</span><span class="p">;</span>

    <span class="nd">#[test]</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">test_from</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">data</span> <span class="o">=</span> <span class="nn">PuzzleData</span><span class="p">::</span><span class="nf">from</span><span class="p">(</span><span class="n">CONTENT</span><span class="p">);</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"{data:?}"</span><span class="p">);</span>
        <span class="nd">assert_eq!</span><span class="p">(</span>
            <span class="n">PuzzleData</span> <span class="p">{</span>
                <span class="n">galaxies</span><span class="p">:</span> <span class="nd">vec!</span><span class="p">[</span>
                    <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
                    <span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
                    <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span>
                    <span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span>
                    <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span>
                    <span class="p">(</span><span class="mi">9</span><span class="p">,</span> <span class="mi">6</span><span class="p">),</span>
                    <span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">),</span>
                    <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">9</span><span class="p">),</span>
                    <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">9</span><span class="p">)</span>
                <span class="p">],</span>
                <span class="n">count_in_cols</span><span class="p">:</span> <span class="nd">vec!</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
                <span class="n">count_in_rows</span><span class="p">:</span> <span class="nd">vec!</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span>
            <span class="p">},</span>
            <span class="n">data</span>
        <span class="p">);</span>
    <span class="p">}</span>

    <span class="nd">#[test]</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">test_star_1</span><span class="p">()</span> <span class="p">{</span>
        <span class="nd">assert_eq!</span><span class="p">(</span><span class="mi">374</span><span class="p">,</span> <span class="nf">star_1</span><span class="p">(</span><span class="o">&amp;</span><span class="n">CONTENT</span><span class="nf">.into</span><span class="p">()));</span>
    <span class="p">}</span>

    <span class="nd">#[test]</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">test_star_2</span><span class="p">()</span> <span class="p">{</span>
        <span class="nd">assert_eq!</span><span class="p">(</span><span class="mi">1_030</span><span class="p">,</span> <span class="nf">sum_shortest_path</span><span class="p">(</span><span class="o">&amp;</span><span class="n">CONTENT</span><span class="nf">.into</span><span class="p">(),</span> <span class="mi">10</span><span class="p">));</span>
        <span class="nd">assert_eq!</span><span class="p">(</span><span class="mi">8_410</span><span class="p">,</span> <span class="nf">sum_shortest_path</span><span class="p">(</span><span class="o">&amp;</span><span class="n">CONTENT</span><span class="nf">.into</span><span class="p">(),</span> <span class="mi">100</span><span class="p">));</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre>
</div>
</div>
<div class="paragraph">
<p><a href="#top">Top</a></p>
</div>
</div>
</div>
</div>
</div>
<div id="footer">
    <div id="footer-text">
        Generated from <a href="https://github.com/mr-kaffee/aoc-2023/">github.com/mr-kaffee/aoc-2023/</a> on 2023-12-11 11:31:15 UTC
        with <a href="https://asciidoctor.org">asciidoctor</a>.
    </div>
</div>
</body>
</html>